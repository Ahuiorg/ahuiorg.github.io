<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>vue 原理 | Lee Blog</title><meta name="keywords" content="js,vue,vue2,vu3"><meta name="author" content="李鹏辉,ahuinet@163.com"><meta name="copyright" content="李鹏辉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="从 Object.defineProperty 到 Proxy一切的一切还得从 Object.defineProperty 开始讲起，那是一个不一样的 API … （bgm 响起，自行体会） Object.definePropertyObject.defineProperty(obj, prop, descriptor) 方法会直接在一个对象上定义一个 新属性，或修改一个 对象 的 现有属性，并返">
<meta property="og:type" content="article">
<meta property="og:title" content="vue 原理">
<meta property="og:url" content="https://leejs.cn/8114936a/index.html">
<meta property="og:site_name" content="Lee Blog">
<meta property="og:description" content="从 Object.defineProperty 到 Proxy一切的一切还得从 Object.defineProperty 开始讲起，那是一个不一样的 API … （bgm 响起，自行体会） Object.definePropertyObject.defineProperty(obj, prop, descriptor) 方法会直接在一个对象上定义一个 新属性，或修改一个 对象 的 现有属性，并返">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images-origin.wallwiz.link/58860f026e9f6a00013b9428_1">
<meta property="article:published_time" content="2023-05-15T05:38:12.000Z">
<meta property="article:modified_time" content="2023-05-15T05:40:24.960Z">
<meta property="article:author" content="李鹏辉">
<meta property="article:tag" content="js">
<meta property="article:tag" content="vue">
<meta property="article:tag" content="vue2">
<meta property="article:tag" content="vu3">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images-origin.wallwiz.link/58860f026e9f6a00013b9428_1"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://leejs.cn/8114936a/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'vue 原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-15 13:40:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">72</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> Media</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-image"></i><span> Gallery</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://images-origin.wallwiz.link/58860f026e9f6a00013b9428_1')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lee Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> Media</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-image"></i><span> Gallery</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">vue 原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-15T05:38:12.000Z" title="发表于 2023-05-15 13:38:12">2023-05-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-15T05:40:24.960Z" title="更新于 2023-05-15 13:40:24">2023-05-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/vue/">vue</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="vue 原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="从-Object-defineProperty-到-Proxy"><a href="#从-Object-defineProperty-到-Proxy" class="headerlink" title="从 Object.defineProperty 到 Proxy"></a>从 <code>Object.defineProperty</code> 到 <code>Proxy</code></h1><p>一切的一切还得从 <strong><code>Object.defineProperty</code></strong> 开始讲起，那是一个不一样的 <code>API</code> … <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/963bb547f1dd4d45898045ed9e6877be~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="1221E745.gif">（<del><code>bgm 响起，自行体会</code></del>）</p>
<h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h2><p><strong><code>Object.defineProperty(obj, prop, descriptor)</code></strong> 方法会直接在一个对象上定义一个 <strong>新属性</strong>，或修改一个 <strong>对象</strong> 的 <strong>现有属性</strong>，并返回此对象，其参数具体为：</p>
<ul>
<li><code>obj</code>：要定义属性的对象</li>
<li><code>prop</code>：要定义或修改的 <strong>属性名称</strong> 或 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol"><strong><code>Symbol</code></strong></a> </li>
<li><code>descriptor</code>：要定义或修改的 <strong>属性描述符</strong></li>
</ul>
<p>从以上的描述就可以看出一些限制，比如：</p>
<ul>
<li><p>目标是 <strong>对象属性</strong>，不是 <strong>整个对象</strong></p>
</li>
<li><p>一次只能 </p>
<p>定义或修改一个属性</p>
<ul>
<li>当然有对应的一次处理多个属性的方法 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties"><code>Object.defineProperties()</code></a>，但在 <code>vue</code> 中并不适用，因为 <code>vue</code> 不能提前知道用户传入的对象都有什么属性，因此还是得经过类似 <code>Object.keys() + for</code> 循环的方式获取所有的 <code>key -&gt; value</code>，而这其实是没有必要使用 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties"><code>Object.defineProperties()</code></a></li>
</ul>
</li>
</ul>
<h3 id="在-Vue2-中的缺陷"><a href="#在-Vue2-中的缺陷" class="headerlink" title="在 Vue2 中的缺陷"></a>在 Vue2 中的缺陷</h3><p><code>Object.defineProperty()</code> 实际是通过 <strong>定义</strong> 或 <strong>修改</strong> <strong><code>对象属性</code></strong> 的描述符来实现 <strong>数据劫持</strong>，其对应的缺点也是没法被忽略的：</p>
<ul>
<li><p>只能拦截对象属性的 <code>get</code> 和 <code>set</code> 操作，比如无法拦截 <code>delete</code>、<code>in</code>、<code>方法调用</code> 等操作</p>
</li>
<li><p>动态添加新属性（响应式丢失）</p>
<ul>
<li>保证后续使用的属性要在初始化声明 <code>data</code> 时进行定义</li>
<li>使用 <code>this.$set()</code> 设置新属性</li>
</ul>
</li>
<li><p>通过 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete</span><br></pre></td></tr></table></figure>

<p> 删除属性（响应式丢失）</p>
<ul>
<li>使用 <code>this.$delete()</code> 删除属性</li>
</ul>
</li>
<li><p>使用数组索引 </p>
<p>替换&#x2F;新增</p>
<p> 元素（响应式丢失）</p>
<ul>
<li>使用 <code>this.$set()</code> 设置新元素</li>
</ul>
</li>
<li><p>使用数组 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push、pop、shift、unshift、splice、sort、reverse</span><br></pre></td></tr></table></figure>

<p> 等 </p>
<p>原生方法</p>
<p> 改变原数组时（响应式丢失）</p>
<ul>
<li>使用 <strong>重写&#x2F;增强</strong> 后的 <code>push、pop、shift、unshift、splice、sort、reverse</code> 方法</li>
</ul>
</li>
<li><p>一次只能对一个属性实现 <strong>数据劫持</strong>，需要遍历对所有属性进行劫持</p>
</li>
<li><p>数据结构复杂时（属性值为 <strong>引用类型数据</strong>），需要通过 <strong>递归</strong> 进行处理</p>
</li>
</ul>
<h3 id="【扩展】Object-defineProperty-和-Array-？"><a href="#【扩展】Object-defineProperty-和-Array-？" class="headerlink" title="【扩展】Object.defineProperty 和 Array ？"></a><strong>【扩展】<code>Object.defineProperty</code> 和 <code>Array</code> ？</strong></h3><p>它们有啥关系，其实没有啥关系，只是大家习惯性的会回答 <code>Object.defineProperty</code> 不能拦截 <code>Array</code> 的操作，这句话说得对但也不对<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f846bb2d62ca452ca04901da51c2928e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="1AE7D8B2.gif">。</p>
<blockquote>
<p><strong>使用 Object.defineProperty 拦截 Array</strong></p>
</blockquote>
<p><code>Object.defineProperty</code> 可用于实现对象属性的 <code>get</code> 和 <code>set</code> 拦截，而数组其实也是对象，那自然是可以实现对应的拦截操作，如下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a1cca9905c042bfab33b26c80f7fde9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de9d533f8aa0461eb2f998fc24d23448~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p>
<blockquote>
<p><strong>Vue2 为什么不使用 Object.defineProperty 拦截 Array？</strong></p>
</blockquote>
<p>尤大在曾在 <code>GitHub</code> 的 <code>Issue</code> 中做过如下回复：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c361447131bf4aca9ee549610568040d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p>
<p>说实话性能问题到底指的是什么呢？<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba6ee76556f74efdbae5a983bb4775f3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="2A593790.gif"> 下面是总结了一些目前看到过的回答：</p>
<ul>
<li><strong>数组 和 普通对象 在使用场景下有区别</strong>，在项目中使用数组的目的大多是为了 <strong>遍历</strong>，即比较少会使用 <code>array[index] = xxx</code> 的形式，更多的是使用数组的 <code>Api</code> 的方式</li>
<li><strong>数组长度是多变的，不可能像普通对象一样先在 <code>data</code> 选项中提前声明好所有元素</strong>，比如通过 <code>array[index] = xxx</code> 方式赋值时，一旦 <code>index</code> 的值超过了现有的最大索引值，那么当前的添加的新元素也不会具有响应式</li>
<li><strong>数组存储的元素比较多，不可能为每个数组元素都设置 <code>getter/setter</code></strong></li>
<li><strong>无法拦截数组原生方法如 <code>push、pop、shift、unshift</code> 等的调用</strong>，最终仍需 <strong>重写&#x2F;增强</strong> 原生方法</li>
</ul>
<h2 id="Proxy-amp-Reflect"><a href="#Proxy-amp-Reflect" class="headerlink" title="Proxy &amp; Reflect"></a>Proxy &amp; Reflect</h2><p>由于在 <code>Vue2</code> 中使用 <code>Object.defineProperty</code> 带来的缺陷，导致在 <code>Vue2</code> 中不得不提供了一些额外的方法（如：<code>Vue.set、Vue.delete()</code>）解决问题，而在 <code>Vue3</code> 中使用了 <code>Proxy</code> 的方式来实现 <strong>数据劫持</strong>，而上述的问题在 <code>Proxy</code> 中都可以得到解决。</p>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy"><strong><code>Proxy</code></strong></a> 主要用于创建一个 <strong>对象的代理</strong>，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等），本质上是通过拦截对象 <strong>内部方法</strong> 的执行实现代理，而对象本身根据规范定义的不同又会区分为 <strong>常规对象</strong> 和 <strong>异质对象</strong>（这不是重点，可自行了解）。</p>
<ul>
<li><p><strong><code>new Proxy(target, handler)</code></strong> 是针对整个对象进行的代理，不是某个属性</p>
</li>
<li><p>代理对象属性拥有 </p>
<p>读取、修改、删除、新增、是否存在属性</p>
<p> 等操作相应的捕捉器，</p>
<p><strong>更多可见</strong></p>
<ul>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/get"><code>get()</code></a> 属性 <strong>读取</strong> 操作的捕捉器</li>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/set"><code>set()</code></a> 属性 <strong>设置</strong> 操作的捕捉器</li>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/deleteProperty"><code>deleteProperty()</code></a> 是 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete"><code>delete</code></a> 操作符的捕捉器</li>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/ownKeys"><code>ownKeys()</code></a> 是 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames"><code>Object.getOwnPropertyNames</code></a> 方法和 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols"><code>Object.getOwnPropertySymbols</code></a> 方法的捕捉器</li>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/has"><code>has()</code></a> 是 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in"><code>in</code></a> 操作符的捕捉器</li>
</ul>
</li>
</ul>
<h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect"><strong><code>Reflect</code></strong></a> 是一个内置的对象，它提供拦截 <code>JavaScript</code> 操作的方法，这些方法与 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy"><strong><code>Proxy handlers</code></strong></a> 提供的的方法是一一对应的，且 <code>Reflect</code> 不是一个函数对象，即不能进行实例化，其所有属性和方法都是静态的。</p>
<ul>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/get"><code>Reflect.get(target, propertyKey[, receiver])</code></a> 获取对象身上某个属性的值，类似于 <code>target[name]</code></li>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/set"><code>Reflect.set(target, propertyKey, value[, receiver])</code></a> 将值分配给属性的函数。返回一个<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><code>Boolean</code></a>，如果更新成功，则返回<code>true</code></li>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/deleteProperty"><code>Reflect.deleteProperty(target, propertyKey)</code></a> 作为函数的<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete"><code>delete</code></a>操作符，相当于执行 <code>delete target[name]</code></li>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys"><code>Reflect.ownKeys(target)</code></a> 返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys"><code>Object.keys()</code></a>, 但不会受<code>enumerable</code> 影响)</li>
<li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/has"><code>Reflect.has(target, propertyKey)</code></a> 判断一个对象是否存在某个属性，和 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in"><code>in</code> 运算符</a> 的功能完全相同</li>
</ul>
<p><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect"><strong>更多方法点此可见</strong></a></p>
<h3 id="Proxy-为什么需要-Reflect-呢？"><a href="#Proxy-为什么需要-Reflect-呢？" class="headerlink" title="Proxy 为什么需要 Reflect 呢？"></a>Proxy 为什么需要 Reflect 呢？</h3><p>在 <strong><code>Proxy</code></strong> 的 <strong><code>get(target, key, receiver)、set(target, key, newVal, receiver)</code></strong> 的捕获器中都能接到前面所列举的参数：</p>
<ul>
<li><strong><code>target</code></strong> 指的是 <strong>原始数据对象</strong></li>
<li><strong><code>key</code></strong> 指的是当前操作的 <strong>属性名</strong></li>
<li><strong><code>newVal</code></strong> 指的是当前操作接收到的 <strong>最新值</strong></li>
<li><strong><code>receiver</code></strong> 指向的是当前操作 <strong>正确的上下文</strong></li>
</ul>
<h4 id="怎么理解-Proxy-handler-中-receiver-指向的是当前操作正确上的下文呢？"><a href="#怎么理解-Proxy-handler-中-receiver-指向的是当前操作正确上的下文呢？" class="headerlink" title="怎么理解 Proxy handler 中 receiver 指向的是当前操作正确上的下文呢？"></a>怎么理解 <code>Proxy handler</code> 中 <code>receiver</code> 指向的是当前操作正确上的下文呢？</h4><ul>
<li><p>正常情况下，**<code>receiver</code>** 指向的是 <strong>当前的代理对象</strong></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e081017679354c869afe9d851eeeea83~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p>
</li>
<li><p>特殊情况下，**<code>receiver</code>** 指向的是 <strong>引发当前操作的对象</strong></p>
<ul>
<li>通过 <code>Object.setPrototypeOf()</code> 方法将代理对象 <code>proxy</code> 设置为普通对象 <code>obj</code> 的原型</li>
<li>通过 <code>obj.name</code> 访问其不存在的 <code>name</code> 属性，由于原型链的存在，最终会访问到 <code>proxy.name</code> 上，即触发 <code>get</code> 捕获器</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b838ee907265400aa30365407c316c21~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p>
</li>
</ul>
<p>在 <strong><code>Reflect</code></strong> 的方法中通常只需要传递 <code>target、key、newVal</code> 等，但为了能够处理上述提到的特殊情况，一般也需要传递 <code>receiver</code> 参数，因为 <strong>Reflect 方法中传递的 receiver 参数代表执行原始操作时的 <code>this</code> 指向</strong>，比如：<code>Reflect.get(target, key , receiver)</code>、<code>Reflect.set(target, key, newVal, receiver)</code>。</p>
<p><strong>总结</strong>：**<code>Reflect</code>** 是为了在执行对应的拦截操作的方法时能 <strong>传递正确的 <code>this</code> 上下文</strong>。</p>
<h1 id="Vue3-如何使用-Proxy-实现数据劫持？"><a href="#Vue3-如何使用-Proxy-实现数据劫持？" class="headerlink" title="Vue3 如何使用 Proxy 实现数据劫持？"></a>Vue3 如何使用 Proxy 实现数据劫持？</h1><p><strong><code>Vue3</code></strong> 中提供了 <strong><code>reactive()</code></strong> 和 <strong><code>ref()</code></strong> 两个方法用来将 <strong>目标数据</strong> 变成 <strong>响应式数据</strong>，而通过 <code>Proxy</code> 来实现 <strong>数据劫持（或代理）</strong> 的具体实现就在其中，下面一起来看看吧！</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a87316a7b41b459dbea1b2ed260657dc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="2528D3FF.png"></p>
<h2 id="reactive-函数"><a href="#reactive-函数" class="headerlink" title="reactive 函数"></a>reactive 函数</h2><p>从源码来看，其核心其实就是 <code>createReactiveObject(...)</code> 函数，那么继续往下查看对应的内容</p>
<p><strong>源码位置：<code>packages\reactivity\src\reactive.ts</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">复制代码<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">target: object</span>) &#123;</span><br><span class="line">  <span class="comment">// if trying to observe a readonly proxy, return the readonly version.</span></span><br><span class="line">  <span class="comment">// 若目标对象是响应式的只读数据，则直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isReadonly</span>(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 否则将目标数据尝试变成响应式数据</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(</span><br><span class="line">    target,</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    mutableHandlers, <span class="comment">// 对象类型的 handlers</span></span><br><span class="line">    mutableCollectionHandlers, <span class="comment">// 集合类型的 handlers</span></span><br><span class="line">    reactiveMap</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="createReactiveObject-函数"><a href="#createReactiveObject-函数" class="headerlink" title="createReactiveObject() 函数"></a>createReactiveObject() 函数</h3><p>源码的体现也是非常简单，无非就是做一些前置判断处理：</p>
<ul>
<li><p>若目标数据是 <strong>原始值类型</strong>，直接向返回 <strong>原数据</strong></p>
</li>
<li><p>若目标数据的 <code>__v_raw</code> 属性为 <code>true</code>，且是【非响应式数据】或 不是通过调用 <code>readonly()</code> 方法，则直接返回 <strong>原数据</strong></p>
</li>
<li><p>若目标数据已存在相应的 <code>proxy</code> 代理对象，则直接返回 <strong>对应的代理对象</strong></p>
</li>
<li><p>若目标数据不存在对应的 </p>
<p>白名单数据类型</p>
<p> 中，则直接返回原数据，支持响应式的数据类型如下：</p>
<ul>
<li><strong>可扩展的对象</strong>，即是否可以在它上面添加新的属性</li>
<li><strong>__v_skip 属性不存在或值为 false 的对象</strong></li>
<li><strong>数据类型为 <code>Object、Array、Map、Set、WeakMap、WeakSet</code> 的对象</strong></li>
<li>其他数据都统一被认为是 <strong>无效的响应式数据对象</strong></li>
</ul>
</li>
<li><p>通过 <strong><code>Proxy</code></strong> 创建代理对象，根据目标数据类型选择不同的 <strong><code>Proxy handlers</code></strong></p>
</li>
</ul>
<p>看来具体的实现又在不同数据类型的 <strong>捕获器</strong> 中，即下面源码的 <strong><code>collectionHandlers</code></strong> 和 **<code>baseHandlers </code>**，而它们则对应的是在上述 <code>reactive()</code> 函数中为 <code>createReactiveObject()</code> 函数传递的 <code>mutableCollectionHandlers</code> 和 <code>mutableHandlers</code> 参数。</p>
<p><strong>源码位置：<code>packages\reactivity\src\reactive.ts</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">复制代码<span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: Target,</span></span><br><span class="line"><span class="params">  isReadonly: boolean,</span></span><br><span class="line"><span class="params">  baseHandlers: ProxyHandler&lt;any&gt;,</span></span><br><span class="line"><span class="params">  collectionHandlers: ProxyHandler&lt;any&gt;,</span></span><br><span class="line"><span class="params">  proxyMap: <span class="built_in">WeakMap</span>&lt;Target, any&gt;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非对象类型直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(target)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`value cannot be made reactive: <span class="subst">$&#123;<span class="built_in">String</span>(target)&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 目标数据的 __v_raw 属性若为 true，且是【非响应式数据】或 不是通过调用 readonly() 方法，则直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    target[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>] &amp;&amp;</span><br><span class="line">    !(isReadonly &amp;&amp; target[<span class="title class_">ReactiveFlags</span>.<span class="property">IS_REACTIVE</span>])</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 目标对象已存在相应的 proxy 代理对象，则直接返回</span></span><br><span class="line">  <span class="keyword">const</span> existingProxy = proxyMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (existingProxy) &#123;</span><br><span class="line">    <span class="keyword">return</span> existingProxy</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只有在白名单中的值类型才可以被代理监测，否则直接返回</span></span><br><span class="line">  <span class="keyword">const</span> targetType = <span class="title function_">getTargetType</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (targetType === <span class="title class_">TargetType</span>.<span class="property">INVALID</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> target     </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建代理对象</span></span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">    target,</span><br><span class="line">    <span class="comment">// 若目标对象是集合类型（Set、Map）则使用集合类型对应的捕获器，否则使用基础捕获器</span></span><br><span class="line">    targetType === <span class="title class_">TargetType</span>.<span class="property">COLLECTION</span> ? collectionHandlers : baseHandlers </span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将对应的代理对象存储在 proxyMap 中</span></span><br><span class="line">  proxyMap.<span class="title function_">set</span>(target, proxy)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> proxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="捕获器-Handlers"><a href="#捕获器-Handlers" class="headerlink" title="捕获器 Handlers"></a>捕获器 Handlers</h2><h3 id="对象类型的捕获器-—-mutableHandlers"><a href="#对象类型的捕获器-—-mutableHandlers" class="headerlink" title="对象类型的捕获器 — mutableHandlers"></a>对象类型的捕获器 — <code>mutableHandlers</code></h3><p>这里的对象类型指的是 <strong>数组</strong> 和 <strong>普通对象</strong></p>
<p><strong>源码位置：<code>packages\reactivity\src\baseHandlers.ts</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">复制代码<span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">mutableHandlers</span>: <span class="title class_">ProxyHandler</span>&lt;object&gt; = &#123;</span><br><span class="line">  get,</span><br><span class="line">  set,</span><br><span class="line">  deleteProperty,</span><br><span class="line">  has,</span><br><span class="line">  ownKeys</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上这些捕获器其实就是我们在上述 <code>Proxy</code> 部分列举出来的捕获器，显然可以拦截对普通对象的如下操作：</p>
<ul>
<li><strong>读取</strong>，如 <strong><code>obj.name</code></strong></li>
<li><strong>设置</strong>，如 <strong><code>obj.name = &#39;zs&#39;</code></strong></li>
<li><strong>删除属性</strong>，如 <strong><code>delete obj.name</code></strong></li>
<li><strong>判断是否存在对应属性</strong>，如 <strong><code>name in obj</code></strong></li>
<li><strong>获取对象自身的属性值</strong>，如 <strong><code>obj.getOwnPropertyNames()</code> 和 <code>obj.getOwnPropertySymbols()</code></strong></li>
</ul>
<h4 id="get-捕获器"><a href="#get-捕获器" class="headerlink" title="get 捕获器"></a><code>get</code> 捕获器</h4><p>具体信息在下面的注释中，这里只列举核心内容：</p>
<ul>
<li><p>若当前数据对象是 </p>
<p>数组</p>
<p>，则 </p>
<p>重写&#x2F;增强</p>
<p> 数组对应的方法</p>
<ul>
<li>数组元素的 <strong>查找方法</strong>：<code>includes、indexOf、lastIndexOf</code></li>
<li><strong>修改原数组</strong> 的方法：<code>push、pop、unshift、shift、splice</code></li>
</ul>
</li>
<li><p>若当前数据对象是 </p>
<p>普通对象</p>
<p>，且非 </p>
<p>只读</p>
<p> 的则通过 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">track(target, TrackOpTypes.GET, key)</span><br></pre></td></tr></table></figure>

<p> 进行 </p>
<p>依赖收集</p>
<ul>
<li>若当前数据对象是 <strong>浅层响应</strong> 的，则直接返回其对应属性值</li>
<li>若当前数据对象是 <strong>ref</strong> 类型的，则会进行 <strong>自动脱 ref</strong></li>
</ul>
</li>
<li><p>若当前数据对象的属性值是 </p>
<p>对象类型</p>
<ul>
<li>若当前属性值属于 <strong>只读的</strong>，则通过 <code>readonly(res)</code> 向外返回其结果</li>
<li>否则会将当前属性值以 <code>reactive(res)</code> 向外返回 <strong>proxy 代理对象</strong></li>
</ul>
</li>
<li><p>否则直接向外返回对应的 <strong>属性值</strong></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">复制代码<span class="keyword">function</span> <span class="title function_">createGetter</span>(<span class="params">isReadonly = <span class="literal">false</span>, shallow = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">target: Target, key: string | symbol, receiver: object</span>) &#123;</span><br><span class="line">    <span class="comment">// 当直接通过指定 key 访问 vue 内置自定义的对象属性时，返回其对应的值</span></span><br><span class="line">    <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_REACTIVE</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> !isReadonly</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_READONLY</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> isReadonly</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_SHALLOW</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> shallow</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      key === <span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span> &amp;&amp;</span><br><span class="line">      receiver ===</span><br><span class="line">        (isReadonly</span><br><span class="line">          ? shallow</span><br><span class="line">            ? shallowReadonlyMap</span><br><span class="line">            : readonlyMap</span><br><span class="line">          : shallow</span><br><span class="line">          ? shallowReactiveMap</span><br><span class="line">          : reactiveMap</span><br><span class="line">        ).<span class="title function_">get</span>(target)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> target</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否为数组类型</span></span><br><span class="line">    <span class="keyword">const</span> targetIsArray = <span class="title function_">isArray</span>(target)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组对象</span></span><br><span class="line">    <span class="keyword">if</span> (!isReadonly &amp;&amp; targetIsArray &amp;&amp; <span class="title function_">hasOwn</span>(arrayInstrumentations, key)) &#123;</span><br><span class="line">      <span class="comment">// 重写/增强数组的方法： </span></span><br><span class="line">      <span class="comment">//  - 查找方法：includes、indexOf、lastIndexOf</span></span><br><span class="line">      <span class="comment">//  - 修改原数组的方法：push、pop、unshift、shift、splice</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(arrayInstrumentations, key, receiver)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应属性值</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isSymbol</span>(key) ? builtInSymbols.<span class="title function_">has</span>(key) : <span class="title function_">isNonTrackableKeys</span>(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依赖收集</span></span><br><span class="line">    <span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">      <span class="title function_">track</span>(target, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 浅层响应</span></span><br><span class="line">    <span class="keyword">if</span> (shallow) &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若是 ref 类型响应式数据，会进行【自动脱 ref】，但不支持【数组】+【索引】的访问方式</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isRef</span>(res)) &#123;</span><br><span class="line">      <span class="keyword">const</span> shouldUnwrap = !targetIsArray || !<span class="title function_">isIntegerKey</span>(key)</span><br><span class="line">      <span class="keyword">return</span> shouldUnwrap ? res.<span class="property">value</span> : res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性值是对象类型：</span></span><br><span class="line">    <span class="comment">//  - 是只读属性，则通过 readonly() 返回结果，</span></span><br><span class="line">    <span class="comment">//  - 且是非只读属性，则递归调用 reactive 向外返回 proxy 代理对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isObject</span>(res)) &#123;</span><br><span class="line">      <span class="keyword">return</span> isReadonly ? <span class="title function_">readonly</span>(res) : <span class="title function_">reactive</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="set-捕获器"><a href="#set-捕获器" class="headerlink" title="set 捕获器"></a><code>set</code> 捕获器</h4><p>除去额外的边界处理，其实核心还是 <strong>更新属性值</strong>，并通过 <code>trigger(...)</code> 触发依赖更新</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">复制代码<span class="keyword">function</span> <span class="title function_">createSetter</span>(<span class="params">shallow = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">set</span>(<span class="params"></span></span><br><span class="line"><span class="params">    target: object,</span></span><br><span class="line"><span class="params">    key: string | symbol,</span></span><br><span class="line"><span class="params">    value: unknown,</span></span><br><span class="line"><span class="params">    receiver: object</span></span><br><span class="line"><span class="params">  </span>): boolean &#123;</span><br><span class="line">    <span class="comment">// 保存旧的数据</span></span><br><span class="line">    <span class="keyword">let</span> oldValue = (target <span class="keyword">as</span> any)[key]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若原数据值属于 只读 且 ref 类型，并且新数据值不属于 ref 类型，则意味着修改失败</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isReadonly</span>(oldValue) &amp;&amp; <span class="title function_">isRef</span>(oldValue) &amp;&amp; !<span class="title function_">isRef</span>(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!shallow &amp;&amp; !<span class="title function_">isReadonly</span>(value)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">isShallow</span>(value)) &#123;</span><br><span class="line">        value = <span class="title function_">toRaw</span>(value)</span><br><span class="line">        oldValue = <span class="title function_">toRaw</span>(oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">isArray</span>(target) &amp;&amp; <span class="title function_">isRef</span>(oldValue) &amp;&amp; !<span class="title function_">isRef</span>(value)) &#123;</span><br><span class="line">        oldValue.<span class="property">value</span> = value</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// in shallow mode, objects are set as-is regardless of reactive or not</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否存在对应的 key</span></span><br><span class="line">    <span class="keyword">const</span> hadKey =</span><br><span class="line">      <span class="title function_">isArray</span>(target) &amp;&amp; <span class="title function_">isIntegerKey</span>(key)</span><br><span class="line">        ? <span class="title class_">Number</span>(key) &lt; target.<span class="property">length</span></span><br><span class="line">        : <span class="title function_">hasOwn</span>(target, key)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置对应值</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若目标对象是原始原型链上的内容（非自定义添加），则不触发依赖更新</span></span><br><span class="line">    <span class="keyword">if</span> (target === <span class="title function_">toRaw</span>(receiver)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">        <span class="comment">// 目标对象不存在对应的 key，则为新增操作</span></span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>, key, value)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(value, oldValue)) &#123;</span><br><span class="line">        <span class="comment">// 目标对象存在对应的值，则为修改操作</span></span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>, key, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回修改结果</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="deleteProperty-amp-has-amp-ownKeys-捕获器"><a href="#deleteProperty-amp-has-amp-ownKeys-捕获器" class="headerlink" title="deleteProperty &amp; has &amp; ownKeys 捕获器"></a><code>deleteProperty</code> &amp; <code>has</code> &amp; <code>ownKeys</code> 捕获器</h4><p>这三个捕获器内容非常简洁，其中 <code>has</code> 和 <code>ownKeys</code> 本质也属于 <strong>读取操作</strong>，因此需要通过 <code>track()</code> 进行依赖收集，而 <code>deleteProperty</code> 相当于修改操作，因此需要 <code>trigger()</code> 触发更新</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">复制代码<span class="keyword">function</span> <span class="title function_">deleteProperty</span>(<span class="params">target: object, key: string | symbol</span>): boolean &#123;</span><br><span class="line">  <span class="keyword">const</span> hadKey = <span class="title function_">hasOwn</span>(target, key)</span><br><span class="line">  <span class="keyword">const</span> oldValue = (target <span class="keyword">as</span> any)[key]</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key)</span><br><span class="line">  <span class="comment">// 目标对象上存在对应的 key ，并且能成功删除，才会触发依赖更新</span></span><br><span class="line">  <span class="keyword">if</span> (result &amp;&amp; hadKey) &#123;</span><br><span class="line">    <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">DELETE</span>, key, <span class="literal">undefined</span>, oldValue)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">has</span>(<span class="params">target: object, key: string | symbol</span>): boolean &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">has</span>(target, key)</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isSymbol</span>(key) || !builtInSymbols.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">    <span class="title function_">track</span>(target, <span class="title class_">TrackOpTypes</span>.<span class="property">HAS</span>, key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ownKeys</span>(<span class="params">target: object</span>): (string | symbol)[] &#123;</span><br><span class="line">  <span class="title function_">track</span>(target, <span class="title class_">TrackOpTypes</span>.<span class="property">ITERATE</span>, <span class="title function_">isArray</span>(target) ? <span class="string">&#x27;length&#x27;</span> : <span class="variable constant_">ITERATE_KEY</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组类型捕获器-——-arrayInstrumentations"><a href="#数组类型捕获器-——-arrayInstrumentations" class="headerlink" title="数组类型捕获器 —— arrayInstrumentations"></a>数组类型捕获器 —— <code>arrayInstrumentations</code></h3><p><strong>数组类型</strong> 和 <strong>对象类型</strong> 的大部分操作是可以共用的，比如 <code>obj.name</code> 和 <code>arr[index]</code> 等，但数组类型的操作还是会比对象类型更丰富一些，而这些就需要特殊处理。</p>
<blockquote>
<p><strong>源码位置：<code>packages\reactivity\src\baseHandlers.ts</code></strong></p>
</blockquote>
<h4 id="处理数组索引-index-和-length"><a href="#处理数组索引-index-和-length" class="headerlink" title="处理数组索引 index 和 length"></a>处理数组索引 <code>index</code> 和 <code>length</code></h4><p>数组的 <code>index</code> 和 <code>length</code> 是会相互影响的，比如存在数组 <code>const arr = [1]</code> ：</p>
<ul>
<li><code>arr[1] = 2</code> 的操作会隐式修改 <code>length</code> 的属性值</li>
<li><code>arr.length = 0</code> 的操作会导致原索引位的值发生变更</li>
</ul>
<p>为了能够合理触发和 <code>length</code> 相关副作用函数的执行，在 <code>set()</code> 捕获器中会判断当前操作的类型：</p>
<ul>
<li>当 <code>Number(key) &lt; target.length</code> 证明是修改操作，对应 <code>TriggerOpTypes.SET</code> 类型，即当前操作不会改变 <code>length</code> 的值，<strong>不需要</strong> 触发和 <code>length</code> 相关副作用函数的执行</li>
<li>当 <code>Number(key) &gt;= target.length</code> 证明是新增操作，<code>TriggerOpTypes.ADD</code> 类型，即当前操作会改变 <code>length</code> 的值，<strong>需要</strong> 触发和 <code>length</code> 相关副作用函数的执行</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">复制代码<span class="keyword">function</span> <span class="title function_">createSetter</span>(<span class="params">shallow = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">set</span>(<span class="params"></span></span><br><span class="line"><span class="params">    target: object,</span></span><br><span class="line"><span class="params">    key: string | symbol,</span></span><br><span class="line"><span class="params">    value: unknown,</span></span><br><span class="line"><span class="params">    receiver: object</span></span><br><span class="line"><span class="params">  </span>): boolean &#123;</span><br><span class="line">  </span><br><span class="line">   省略其他代码</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">const</span> hadKey =</span><br><span class="line">      <span class="title function_">isArray</span>(target) &amp;&amp; <span class="title function_">isIntegerKey</span>(key)</span><br><span class="line">        ? <span class="title class_">Number</span>(key) &lt; target.<span class="property">length</span></span><br><span class="line">        : <span class="title function_">hasOwn</span>(target, key)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">    <span class="comment">// don&#x27;t trigger if target is something up in the prototype chain of original</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (target === <span class="title function_">toRaw</span>(receiver)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>, key, value)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(value, oldValue)) &#123;</span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>, key, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="处理数组的查找方法"><a href="#处理数组的查找方法" class="headerlink" title="处理数组的查找方法"></a>处理数组的查找方法</h4><p>数组的查找方法包括 <code>includes</code>、<code>indexOf</code>、<code>lastIndexOf</code>，这些方法通常情况下是能够按预期进行工作，但还是需要对某些特殊情况进行处理：</p>
<ul>
<li><p><strong>当查找的目标数据是响应式数据本身时</strong>，得到的就不是预期结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">复制代码<span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="title function_">reactive</span>([obj])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="title function_">includs</span>(proxy[<span class="number">0</span>])) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>【<strong>产生原因</strong>】首先这里涉及到了两次读取操作，<strong>第一次</strong> 是 <code>proxy[0]</code> 此时会触发 <code>get</code> 捕获器并为 <code>obj</code> 生成对应代理对象并返回，<strong>第二次</strong> 是 <code>proxy.includs()</code> 的调用，它会遍历数组的每个元素，即会触发 <code>get</code> 捕获器，并又生成一个新的代理对象并返回，而这两次生成的代理对象不是同一个，因此返回 <code>false</code></li>
<li>【<strong>解决方案</strong>】源码中会在 <code>get</code> 中设置一个名为 <code>proxyMap</code> 的 <code>WeakMap</code> 集合用于存储每个响应式对象，在触发 <code>get</code> 时优先返回 <code>proxyMap</code> 存在的响应式对象，这样不管触发多少次 <code>get</code> 都能返回相同的响应式数据</li>
</ul>
</li>
<li><p><strong>当在响应式对象中查找原始数据时</strong>，得到的就不是预期结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">复制代码<span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="title function_">reactive</span>([obj])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="title function_">includs</span>(obj)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>【<strong>产生原因</strong>】<code>proxy.includes()</code> 会触发 <code>get</code> 捕获器并为 <code>obj</code> 生成对应代理对象并返回，而 <code>includes</code> 方法的参数传递的是 <strong>原始数据</strong>，相当于此时是 <strong>响应式对象</strong> 和 <strong>原始数据对象</strong> 进行比较，因此对应的结果一定是为 <code>false</code></p>
</li>
<li><p>【</p>
<p>解决方案</p>
<p>】核心就是将它们的数据类型统一，即统一都使用 </p>
<p>原始值数据对比</p>
<p> 或 </p>
<p>响应式数据对比</p>
<p>，由于 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">includes()</span><br></pre></td></tr></table></figure>

<p> 的方法本身并不支持对传入参数或内部响应式数据的处理，因此需要自定义以上对应的数组查找方法</p>
<ul>
<li>在 重写&#x2F;增强 的 <code>includes</code>、<code>indexOf</code>、<code>lastIndexOf</code> 等方法中，会将当前方法内部访问到的响应式数据转换为原始数据，然后调用数组对应的原始方法进行查找，若查找结果为 <code>true</code> 则直接返回结果</li>
<li>若以上操作没有查找到，则通过将当前方法传入的参数转换为原始数据，在调用数组的原始方法，此时直接将对应的结果向外进行返回</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>源码位置：<code>packages\reactivity\src\baseHandlers.ts</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">复制代码;([<span class="string">&#x27;includes&#x27;</span>, <span class="string">&#x27;indexOf&#x27;</span>, <span class="string">&#x27;lastIndexOf&#x27;</span>] <span class="keyword">as</span> <span class="keyword">const</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    instrumentations[key] = <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: unknown[], ...args: unknown[]</span>) &#123;</span><br><span class="line">      <span class="comment">// 外部调用上述方法，默认其内的 this 指向的是代理数组对象，</span></span><br><span class="line">      <span class="comment">// 但实际上是需要通过原始数组中进行遍历查找</span></span><br><span class="line">      <span class="keyword">const</span> arr = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>) <span class="keyword">as</span> any</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="variable language_">this</span>.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="title function_">track</span>(arr, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, i + <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// we run the method using the original args first (which may be reactive)</span></span><br><span class="line">      <span class="keyword">const</span> res = arr[key](...args)</span><br><span class="line">      <span class="keyword">if</span> (res === -<span class="number">1</span> || res === <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// if that didn&#x27;t work, run it again using raw values.</span></span><br><span class="line">        <span class="keyword">return</span> arr[key](...args.<span class="title function_">map</span>(toRaw))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="处理数组影响-length-的方法"><a href="#处理数组影响-length-的方法" class="headerlink" title="处理数组影响 length 的方法"></a>处理数组影响 <code>length</code> 的方法</h4><p>隐式修改数组长度的原型方法包括 <strong><code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code></strong> 等，在调用这些方法的同时会间接的读取数组的 <code>length</code> 属性，又因为这些方法具有修改数组长度的能力，即相当于 <code>length</code> 的设置操作，若不进行特殊处理，会导致与 <code>length</code> 属性相关的副作用函数被重复执行，即 <strong>栈溢出</strong>，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">复制代码<span class="keyword">const</span> proxy = <span class="title function_">reactive</span>([])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个副作用函数</span></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  proxy.<span class="title function_">push</span>(<span class="number">1</span>) <span class="comment">// 读取 + 设置 操作</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个副作用函数</span></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  proxy.<span class="title function_">push</span>(<span class="number">2</span>) <span class="comment">// 读取 + 设置 操作（此时进行 trigger 时，会触发包括第一个副作用函数的内容，然后循环导致栈溢出）</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在源码中还是通过 <strong>重写&#x2F;增强</strong> 上述对应数组方法的形式实现自定义的逻辑处理：</p>
<ul>
<li>在调用真正的数组原型方法前，会通过设置 <code>pauseTracking()</code> 方法来禁止 <code>track</code> 依赖收集</li>
<li>在调用数组原生方法后，在通过 <code>resetTracking()</code> 方法恢复 <code>track</code> 进行依赖收集</li>
<li>实际上以上的两个方法就是通过控制 <code>shouldTrack</code> 变量为 <code>true</code> 或 <code>false</code>，使得在 <code>track</code> 函数执行时是否要执行原来的依赖收集逻辑</li>
</ul>
<p><strong>源码位置：<code>packages\reactivity\src\baseHandlers.ts</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">复制代码;([<span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;shift&#x27;</span>, <span class="string">&#x27;unshift&#x27;</span>, <span class="string">&#x27;splice&#x27;</span>] <span class="keyword">as</span> <span class="keyword">const</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    instrumentations[key] = <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: unknown[], ...args: unknown[]</span>) &#123;</span><br><span class="line">      <span class="title function_">pauseTracking</span>()</span><br><span class="line">      <span class="keyword">const</span> res = (<span class="title function_">toRaw</span>(<span class="variable language_">this</span>) <span class="keyword">as</span> any)[key].<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">      <span class="title function_">resetTracking</span>()</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="集合类型的捕获器-—-mutableCollectionHandlers"><a href="#集合类型的捕获器-—-mutableCollectionHandlers" class="headerlink" title="集合类型的捕获器 — mutableCollectionHandlers"></a>集合类型的捕获器 — <code>mutableCollectionHandlers</code></h3><p><strong>集合类型</strong> 包括 <code>Map</code>、<code>WeakMap</code>、<code>Set</code>、<code>WeakSet</code> 等，而对 <strong>集合类型</strong> 的 <strong>代理模式</strong> 和 <strong>对象类型</strong> 需要有所不同，因为 <strong>集合类型</strong> 和 <strong>对象类型</strong> 的操作方法是不同的，比如：</p>
<blockquote>
<p><strong><code>Map</code> 类型</strong> 的原型 <strong>属性</strong> 和 <strong>方法</strong> 如下，<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map%23%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><strong>详情可见</strong></a>：</p>
</blockquote>
<ul>
<li>size</li>
<li>clear()</li>
<li>delete(key)</li>
<li>has(key)</li>
<li>get(key)</li>
<li>set(key)</li>
<li>keys()</li>
<li>values()</li>
<li>entries()</li>
<li>forEach(cb)</li>
</ul>
<blockquote>
<p><strong><code>Set</code> 类型</strong> 的原型 <strong>属性</strong> 和 <strong>方法</strong> 如下，<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set"><strong>详情可见</strong></a>：</p>
</blockquote>
<ul>
<li>size</li>
<li>add(value)</li>
<li>clear()</li>
<li>delete(value)</li>
<li>has(value)</li>
<li>keys()</li>
<li>values()</li>
<li>entries()</li>
<li>forEach(cb)</li>
</ul>
<blockquote>
<p><strong>源码位置：<code>packages\reactivity\src\collectionHandlers.ts</code></strong></p>
</blockquote>
<h4 id="解决-代理对象-无法访问-集合类型-对应的-属性-和-方法"><a href="#解决-代理对象-无法访问-集合类型-对应的-属性-和-方法" class="headerlink" title="解决 代理对象 无法访问 集合类型 对应的 属性 和 方法"></a>解决 <code>代理对象</code> 无法访问 <code>集合类型</code> 对应的 <code>属性</code> 和 <code>方法</code></h4><p>代理集合类型的第一个问题，就是代理对象没法获取到集合类型的属性和方法，比如：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c80031a2d6a149fba3083db82d57a0b1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p>
<p>从报错信息可以看出 <code>size</code> 属性是一个访问器属性，所以它被作为方法调用了，而主要错误原因就是在这个访问器中的 <code>this</code> 指向的是 <strong>代理对象</strong>，在源码中就是通过为这些特定的 <strong>属性</strong> 和 <strong>方法</strong> 定义对应的 <strong>key</strong> 的 <strong>mutableInstrumentations</strong> 对象，并且在其对应的 <strong>属性</strong> 和 <strong>方法</strong> 中将 <code>this</code>指向为 <strong>原对象</strong>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">复制代码<span class="keyword">function</span> <span class="title function_">has</span>(<span class="params"><span class="variable language_">this</span>: CollectionTypes, key: unknown, isReadonly = <span class="literal">false</span></span>): boolean &#123;</span><br><span class="line">  <span class="keyword">const</span> target = (<span class="variable language_">this</span> <span class="keyword">as</span> any)[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>]</span><br><span class="line">  <span class="keyword">const</span> rawTarget = <span class="title function_">toRaw</span>(target)</span><br><span class="line">  <span class="keyword">const</span> rawKey = <span class="title function_">toRaw</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (key !== rawKey) &#123;</span><br><span class="line">    !isReadonly &amp;&amp; <span class="title function_">track</span>(rawTarget, <span class="title class_">TrackOpTypes</span>.<span class="property">HAS</span>, key)</span><br><span class="line">  &#125;</span><br><span class="line">  !isReadonly &amp;&amp; <span class="title function_">track</span>(rawTarget, <span class="title class_">TrackOpTypes</span>.<span class="property">HAS</span>, rawKey)</span><br><span class="line">  <span class="keyword">return</span> key === rawKey</span><br><span class="line">    ? target.<span class="title function_">has</span>(key)</span><br><span class="line">    : target.<span class="title function_">has</span>(key) || target.<span class="title function_">has</span>(rawKey)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">size</span>(<span class="params">target: IterableCollections, isReadonly = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  target = (target <span class="keyword">as</span> any)[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>]</span><br><span class="line">  !isReadonly &amp;&amp; <span class="title function_">track</span>(<span class="title function_">toRaw</span>(target), <span class="title class_">TrackOpTypes</span>.<span class="property">ITERATE</span>, <span class="variable constant_">ITERATE_KEY</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, <span class="string">&#x27;size&#x27;</span>, target)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">省略其他代码</span><br></pre></td></tr></table></figure>

<h4 id="处理集合类型的响应式"><a href="#处理集合类型的响应式" class="headerlink" title="处理集合类型的响应式"></a>处理集合类型的响应式</h4><p>集合建立响应式核心还是 <code>track</code> 和 <code>trigger</code>，转而思考的问题就变成，什么时候需要 <code>track</code>、什么时候需要 <code>trigger</code>:</p>
<ul>
<li><code>track</code> 时机：<code>get()、get size()、has()、forEach()</code></li>
<li><code>trigger</code> 时机：<code>add()、set()、delete()、clear()</code></li>
</ul>
<p>这里涉及一些优化的内容，比如：</p>
<ul>
<li>在 <code>add()</code> 中通过 <code>has()</code> 判断当前添加的元素是否已经存在于 <code>Set</code> 集合中时，若已存在就不需要进行 <code>trigger()</code> 操作，因为 <code>Set</code> 集合本身的一个特性就是 <strong>去重</strong></li>
<li>在 <code>delete()</code> 中通过 <code>has()</code> 判断当前删除的元素或属性是否存在，若不存在就不需要进行 <code>trigger()</code> 操作，因为此时的删除操作是 <strong>无效的</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">复制代码<span class="keyword">function</span> <span class="title function_">createInstrumentations</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">mutableInstrumentations</span>: <span class="title class_">Record</span>&lt;string, <span class="title class_">Function</span>&gt; = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"><span class="variable language_">this</span>: MapTypes, key: unknown</span>) &#123;<span class="comment">// track</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">get</span>(<span class="variable language_">this</span>, key)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">size</span>() &#123;<span class="comment">// track</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">size</span>(<span class="variable language_">this</span> <span class="keyword">as</span> unknown <span class="keyword">as</span> <span class="title class_">IterableCollections</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    has,<span class="comment">// track</span></span><br><span class="line">    add,<span class="comment">// trigger</span></span><br><span class="line">    set,<span class="comment">// trigger</span></span><br><span class="line">    <span class="attr">delete</span>: deleteEntry,<span class="comment">// trigger</span></span><br><span class="line">    clear,<span class="comment">// trigger</span></span><br><span class="line">    <span class="attr">forEach</span>: <span class="title function_">createForEach</span>(<span class="literal">false</span>, <span class="literal">false</span>) <span class="comment">// track</span></span><br><span class="line">  &#125;</span><br><span class="line">  省略其他代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="避免污染原始数据"><a href="#避免污染原始数据" class="headerlink" title="避免污染原始数据"></a>避免污染原始数据</h4><p>通过重写集合类型的方法并手动指定其中的 <code>this</code> 指向为 <strong>原始对象</strong> 的方式，解决 <strong>代理对象</strong> 无法访问 <strong>集合类型</strong> 对应的 <strong>属性</strong> 和 <strong>方法</strong> 的问题，但这样的实现方式也带来了另一个问题：**<code>原始数据被污染</code>** 。</p>
<p>简单来说，我们只希望 <strong>代理对象（<code>响应式对象</code>）</strong> 才具备 <strong>依赖收集(<code>track</code>)</strong> 和 <strong>依赖更新(<code>trigger</code>)</strong> 的能力，而通过 <strong>原始数据</strong> 进行的操作不应该具有响应式的能力。</p>
<p>如果只是单纯的把所有操作直接作用到 <strong>原始对象</strong> 上就不能保证这个结果，比如：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac3faae0cc8b483faa22f009ba7cfbfb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="0021E3A8.gif"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">复制代码 <span class="comment">// 原数数据 originalData1</span></span><br><span class="line">  <span class="keyword">const</span> originalData1 = <span class="keyword">new</span> <span class="title class_">Map</span>(&#123;&#125;);</span><br><span class="line">  <span class="comment">// 代理对象 proxyData1</span></span><br><span class="line">  <span class="keyword">const</span> proxyData1 = <span class="title function_">reactive</span>(originalData1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 另一个代理对象 proxyData2</span></span><br><span class="line">  <span class="keyword">const</span> proxyData2 = <span class="title function_">reactive</span>(<span class="keyword">new</span> <span class="title class_">Map</span>(&#123;&#125;));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 proxyData2 做为 proxyData1 一个键值</span></span><br><span class="line">  <span class="comment">// 【注意】此时的 set() 经过重写，其内部 this 已经指向 原始对象（originalData1），等价于 原始对象 originalData1 上存储了一个 响应式对象 proxyData2</span></span><br><span class="line">  proxyData1.<span class="title function_">set</span>(<span class="string">&quot;proxyData2&quot;</span>, proxyData2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 若不做额外处理，如下基于 原始数据的操作 就会触发 track 和 trigger</span></span><br><span class="line">  originalData1.<span class="title function_">get</span>(<span class="string">&quot;proxyData2&quot;</span>).<span class="title function_">set</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zs&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在源码中的解决方案也是很简单，直接通过 <code>value = toRaw(value)</code> 获取当前设置值对应的 <strong>原始数据</strong>，这样旧可以避免 <strong>响应式数据对原始数据的污染</strong>。</p>
<h4 id="处理-forEach-回调参数"><a href="#处理-forEach-回调参数" class="headerlink" title="处理 forEach 回调参数"></a>处理 <code>forEach</code> 回调参数</h4><p>首先 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach"><code>Map.prototype.forEach(callbackFn [, thisArg])</code></a>  其中 <code>callbackFn</code> 回调函数会接收三个参数：</p>
<ul>
<li>当前的 <strong>值 <code>value</code></strong></li>
<li>当前的 <strong>键 <code>key</code></strong></li>
<li>正在被遍历的 <strong><code>Map</code> 对象</strong>（原始对象）</li>
</ul>
<p><strong>遍历操作</strong> 等价于 <strong>读取操作</strong>，在处理 <strong>普通对象</strong> 的 <code>get()</code> 捕获器中有一个处理，如果当前访问的属性值是 <strong>对象类型</strong> 那么就会向外返回其对应的 <strong>代理对象</strong>，目的是实现 <strong>惰性响应</strong> 和 <strong>深层响应</strong>，这个处理也同样适用于 <strong>集合类型</strong>。</p>
<p>因此，在源码中通过 <code>callback.call(thisArg, wrap(value), wrap(key), observed)</code> 的方式将 <code>Map</code> 类型的 <strong>键</strong> 和 <strong>值</strong> 进行响应式处理，以及进行 <code>track</code> 操作，因为 <code>Map</code> 类型关注的就是 <strong>键</strong> 和 <strong>值</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">复制代码<span class="keyword">function</span> <span class="title function_">createForEach</span>(<span class="params">isReadonly: boolean, isShallow: boolean</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">forEach</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="variable language_">this</span>: IterableCollections,</span></span><br><span class="line"><span class="params">    callback: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">    thisArg?: unknown</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> observed = <span class="variable language_">this</span> <span class="keyword">as</span> any</span><br><span class="line">    <span class="keyword">const</span> target = observed[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>]</span><br><span class="line">    <span class="keyword">const</span> rawTarget = <span class="title function_">toRaw</span>(target)</span><br><span class="line">    <span class="keyword">const</span> wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive</span><br><span class="line">    !isReadonly &amp;&amp; <span class="title function_">track</span>(rawTarget, <span class="title class_">TrackOpTypes</span>.<span class="property">ITERATE</span>, <span class="variable constant_">ITERATE_KEY</span>)</span><br><span class="line">    <span class="keyword">return</span> target.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value: unknown, key: unknown</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// important: make sure the callback is</span></span><br><span class="line">      <span class="comment">// 1. invoked with the reactive map as `this` and 3rd arg</span></span><br><span class="line">      <span class="comment">// 2. the value received should be a corresponding reactive/readonly.</span></span><br><span class="line">      <span class="keyword">return</span> callback.<span class="title function_">call</span>(thisArg, <span class="title function_">wrap</span>(value), <span class="title function_">wrap</span>(key), observed)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="处理迭代器"><a href="#处理迭代器" class="headerlink" title="处理迭代器"></a>处理迭代器</h4><p>集合类型的迭代器方法：</p>
<ul>
<li><code>entries()</code></li>
<li><code>keys()</code></li>
<li><code>values()</code></li>
</ul>
<p><code>Map</code> 和 <code>Set</code> 都实现了 <strong>可迭代协议</strong>（即 <code>Symbol.iterator</code> 方法，而 <strong>迭代器协议</strong> 是指 一个对象实现了 <code>next</code> 方法），因此它们还可以通过 <code>for...of</code> 的方式进行遍历。</p>
<p>根据对 <code>forEach</code> 的处理，不难知道涉及遍历的方法，终究还是得将其对应的遍历的 <strong>键、值</strong> 进行响应式包裹的处理，以及进行 <code>track</code> 操作，而原本的的迭代器方法没办法实现，因此需要内部自定义迭代器协议。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">复制代码<span class="keyword">const</span> iteratorMethods = [<span class="string">&#x27;keys&#x27;</span>, <span class="string">&#x27;values&#x27;</span>, <span class="string">&#x27;entries&#x27;</span>, <span class="title class_">Symbol</span>.<span class="property">iterator</span>]</span><br><span class="line">  iteratorMethods.<span class="title function_">forEach</span>(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">    mutableInstrumentations[method <span class="keyword">as</span> string] = <span class="title function_">createIterableMethod</span>(</span><br><span class="line">      method,</span><br><span class="line">      <span class="literal">false</span>,</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    )</span><br><span class="line">    省略其他代码</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>这一部分的源码涉及的内容比较多，以上只是简单的总结一下，更详细的内容可查看对应的源码内容。</p>
<h2 id="ref-函数-—-原始值的响应式"><a href="#ref-函数-—-原始值的响应式" class="headerlink" title="ref 函数 — 原始值的响应式"></a>ref 函数 — 原始值的响应式</h2><p>原始值指的是 <strong><code>Boolean、Number、BigInt、String、Symbol、undefined、null</code></strong> 等类型的值，我们知道用 <strong><code>Object.defineProperty</code></strong> 肯定是不支持，因为它拦截的就是对象属性的操作，都说 <strong><code>Proxy</code></strong> 比 <strong><code>Object.defineProperty</code></strong> 强，那么它能不能直接支持呢？</p>
<p>直接支持是肯定不能的，别忘了 <code>Proxy</code> 代理的目标也还是对象类型呀，它的强是在自己的所属领域，跨领域也是遭不住的。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7d5e41284184a2fa1a2cd2eb01ddd01~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="036479D5.png"></p>
<p>因此在 <code>Vue3</code> 的 <code>ref</code> 函数中对原始值的处理方式是通过为 <strong>原始值类型</strong> 提供一个通过 <code>new RefImpl(rawValue, shallow)</code> 实例化得到的 <strong>包裹对象</strong>，说白了还是将原始值类型变成对象类型，但 <code>ref</code> 函数的参数并 <strong>不限制数据类型</strong>：</p>
<ul>
<li><p><strong>原始值类型</strong>，<code>ref</code> 函数中会为原始值类型数据创建 <code>RefImpl</code> 实例对象（必须通过 <code>.value</code> 的方式访问数据），并且实现自定义的 <code>get、set</code> 用于分别进行 <strong>依赖收集</strong> 和 <strong>依赖更新</strong>，注意的是这里并不会通过 <code>Proxy</code> 为原始值类型创建代理对象，准确的说在 <code>RefImpl</code> 内部自定义实现的 <code>get、set</code> 就实现了对原始值类型的拦截操作，**<code>因为原始值类型不需要向对象类型设置那么多的捕获器</code>**</p>
</li>
<li><p>对象类型</p>
<p>，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref</span><br></pre></td></tr></table></figure>

<p> 函数中除了为 </p>
<p>对象类型</p>
<p> 数据创建 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RefImpl</span><br></pre></td></tr></table></figure>

<p> 实例对象之外，还会通过 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reactive</span><br></pre></td></tr></table></figure>

<p> 函数将其转换为响应式数据，其实主要还是为了支持类似如下的操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">复制代码<span class="keyword">const</span> refProxy = <span class="title function_">ref</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>&#125;)</span><br><span class="line">refProxy.<span class="property">value</span>.<span class="property">name</span> = <span class="string">&#x27;ls&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>依赖容器 dep</strong>，在 <code>ref</code> 类型中依赖存储的位置就是每个 <code>ref</code> 实例对象上的 <code>dep</code> 属性，它本质就是一个 <code>Set</code> 实例，触发 <code>get</code> 时往 <code>dep</code> 中添加副作用函数（依赖），触发 <code>set</code> 时从 <code>dep</code> 中依次取出副作用函数执行</p>
</li>
</ul>
<p><strong>源码位置：<code>packages\reactivity\src\ref.ts</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">复制代码<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">ref</span>(<span class="params">value?: unknown</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createRef</span>(value, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createRef</span>(<span class="params">rawValue: unknown, shallow: boolean</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isRef</span>(rawValue)) &#123;</span><br><span class="line">    <span class="keyword">return</span> rawValue</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RefImpl</span>(rawValue, shallow)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefImpl</span>&lt;T&gt; &#123;</span><br><span class="line">  private <span class="attr">_value</span>: T</span><br><span class="line">  private <span class="attr">_rawValue</span>: T</span><br><span class="line"></span><br><span class="line">  public dep?: <span class="title class_">Dep</span> = <span class="literal">undefined</span></span><br><span class="line">  public readonly __v_isRef = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T, public readonly __v_isShallow: boolean</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_rawValue</span> = __v_isShallow ? value : <span class="title function_">toRaw</span>(value)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = __v_isShallow ? value : <span class="title function_">toReactive</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="comment">// 将依赖收集到 dep 中，实际上就是一个 Set 类型</span></span><br><span class="line">    <span class="title function_">trackRefValue</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取原始数据</span></span><br><span class="line">    newVal = <span class="variable language_">this</span>.<span class="property">__v_isShallow</span> ? newVal : <span class="title function_">toRaw</span>(newVal)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 Object.is(value, oldValue) 判断新旧值是否一致，若不一致才需要进行更新</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(newVal, <span class="variable language_">this</span>.<span class="property">_rawValue</span>)) &#123;</span><br><span class="line">      <span class="comment">// 保存原始值</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_rawValue</span> = newVal</span><br><span class="line">      <span class="comment">// 更新为新的 value 值</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="variable language_">this</span>.<span class="property">__v_isShallow</span> ? newVal : <span class="title function_">toReactive</span>(newVal)</span><br><span class="line">      <span class="comment">// 依赖更新，从 dep 中取出对应的 effect 函数依次遍历执行</span></span><br><span class="line">      <span class="title function_">triggerRefValue</span>(<span class="variable language_">this</span>, newVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若当前 value 是 对象类型，才会通过 reactive 转换为响应式数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toReactive = &lt;T <span class="keyword">extends</span> unknown&gt;(<span class="attr">value</span>: T): <span class="function"><span class="params">T</span> =&gt;</span></span><br><span class="line">  <span class="title function_">isObject</span>(value) ? <span class="title function_">reactive</span>(value) : value</span><br></pre></td></tr></table></figure>

<h1 id="Vue3-如何进行依赖收集？"><a href="#Vue3-如何进行依赖收集？" class="headerlink" title="Vue3 如何进行依赖收集？"></a>Vue3 如何进行依赖收集？</h1><p>在 <code>Vue2</code> 中依赖的收集方式是通过 <code>Dep</code> 和 <code>Watcher</code> 的 <strong>观察者模式</strong> 来实现的，是不是还能想起初次了解 <code>Dep</code> 和 <code>Watcher</code> 之间的这种 <strong><code>剪不断理还乱</code></strong> 的关系时的心情 ……</p>
<blockquote>
<p>关于 <strong>设计模式</strong> 部分感兴趣可查看 <a target="_blank" rel="noopener" href="https://juejin.cn/post/7120251910208094222"><strong>常见 JavaScript 设计模式 — 原来这么简单</strong></a> 一文，里面主要围绕着 <code>Vue</code> 中对应的设计模式来进行介绍，相信会有一定的帮助</p>
</blockquote>
<p><strong>依赖收集</strong> 其实说的就是 <code>track</code> 函数需要处理的内容：</p>
<ul>
<li><p>声明 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">targetMap</span><br></pre></td></tr></table></figure>

<p> 作为一个容器，用于保存和当前响应式对象相关的依赖内容，本身是一个 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakMap</span><br></pre></td></tr></table></figure>

<p> 类型</p>
<ul>
<li>选择 <code>WeakMap</code> 类型作为容器，是因为 <code>WeakMap</code> 对 <strong>键</strong>（对象类型）的引用是 <strong>弱类型</strong> 的，一旦外部没有对该 <strong>键</strong>（对象类型）保持引用时，<code>WeakMap</code> 就会自动将其删除，即 <strong>能够保证该对象能够正常被垃圾回收</strong></li>
<li>而 <code>Map</code> 类型对 <strong>键</strong> 的引用则是 <strong>强引用</strong> ，即便外部没有对该对象保持引用，但至少还存在 <code>Map</code> 本身对该对象的引用关系，因此会导致该对象不能及时的被垃圾回收</li>
</ul>
</li>
<li><p>将对应的 <strong>响应式数据对象</strong> 作为 <code>targetMap</code> 的 <strong>键</strong>，存储和当前响应式数据对象相关的依赖关系 <code>depsMap</code>（属于 <code>Map</code> 实例），即 <code>depsMap</code> 存储的就是和当前响应式对象的每一个 <code>key</code> 对应的具体依赖</p>
</li>
<li><p>将 <code>deps</code>（属于 <code>Set</code> 实例）作为 <code>depsMap</code> 每个 <code>key</code> 对应的依赖集合，因为每个响应式数据可能在多个副作用函数中被使用，并且 <code>Set</code> 类型用于自动去重的能力</p>
</li>
</ul>
<p><strong>可视化结构如下：</strong></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c324c4cd41344c64be9603e590f0db4e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p>
<p><strong>源码位置：<code>packages\reactivity\src\effect.ts</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">js</span><br><span class="line">复制代码<span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;any, <span class="title class_">KeyToDepMap</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target: object, type: TrackOpTypes, key: unknown</span>) &#123;</span><br><span class="line">  <span class="comment">// 当前应该进行依赖收集 且 有对应的副作用函数时，才会进行依赖收集</span></span><br><span class="line">  <span class="keyword">if</span> (shouldTrack &amp;&amp; activeEffect) &#123;</span><br><span class="line">    <span class="comment">// 从容器中取出【对应响应式数据对象】的依赖关系</span></span><br><span class="line">    <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">    <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">      <span class="comment">// 若不存在，则进行初始化</span></span><br><span class="line">      targetMap.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取和对【应响应式数据对象 key】相匹配的依赖</span></span><br><span class="line">    <span class="keyword">let</span> dep = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">    <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">      <span class="comment">// 若不存在，则进行初始化 dep 为 Set 实例</span></span><br><span class="line">      depsMap.<span class="title function_">set</span>(key, (dep = <span class="title function_">createDep</span>()))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> eventInfo = __DEV__</span><br><span class="line">      ? &#123; <span class="attr">effect</span>: activeEffect, target, type, key &#125;</span><br><span class="line">      : <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往 dep 集合中添加 effect 依赖</span></span><br><span class="line">    <span class="title function_">trackEffects</span>(dep, eventInfo)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createDep = (effects?: <span class="title class_">ReactiveEffect</span>[]): <span class="function"><span class="params">Dep</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Set</span>&lt;<span class="title class_">ReactiveEffect</span>&gt;(effects) <span class="keyword">as</span> <span class="title class_">Dep</span></span><br><span class="line">  dep.<span class="property">w</span> = <span class="number">0</span></span><br><span class="line">  dep.<span class="property">n</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> dep</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>以上就是针对 <code>Vue3</code> 中对不同数据类型的处理的内容，无论是 <code>Vue2</code> 还是 <code>Vue3</code> 响应式的核心都是 <strong>数据劫持&#x2F;代理、依赖收集、依赖更新</strong>，只不过由于实现数据劫持方式的差异从而导致具体实现的差异，在 <code>Vue3</code> 中值得注意的是：</p>
<ul>
<li><p><strong>普通对象类型</strong> 可以直接配合 <code>Proxy</code> 提供的捕获器实现响应式</p>
</li>
<li><p><strong>数组类型</strong> 也可以直接复用大部分和 <strong>普通对象类型</strong> 的捕获器，但其对应的查找方法和隐式修改 <code>length</code> 的方法仍然需要被 <strong>重写&#x2F;增强</strong></p>
</li>
<li><p>为了支持 <strong>集合类型</strong> 的响应式，也对其对应的方法进行了 <strong>重写&#x2F;增强</strong></p>
</li>
<li><p>原始值数据类型</p>
<p> 主要通过 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref</span><br></pre></td></tr></table></figure>

<p> 函数来进行响应式处理，不过内容不会对 </p>
<p>原始值类型</p>
<p> 使用 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reactive（或 Proxy）</span><br></pre></td></tr></table></figure>

<p> 函数来处理，而是在内部自定义 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get value()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p> 和 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set value()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p> 的方式实现响应式，毕竟原始值类型的操作无非就是 </p>
<p>读取</p>
<p> 或 </p>
<p>设置</p>
<p>，核心还是将 </p>
<p>原始值类型</p>
<p> 转变为了 </p>
<p>普通对象类型</p>
<ul>
<li><code>ref</code> 函数可实现原始值类型转换为 <strong>响应式数据</strong>，但 <code>ref</code> 接收的值类型并没只限定为原始值类型，若接收到的是引用类型，还是会将其通过 <code>reactive</code> 函数的方式转换为响应式数据</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://leejs.cn">李鹏辉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://leejs.cn/8114936a/">https://leejs.cn/8114936a/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://leejs.cn" target="_blank">Lee Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/js/">js</a><a class="post-meta__tags" href="/tags/vue/">vue</a><a class="post-meta__tags" href="/tags/vue2/">vue2</a><a class="post-meta__tags" href="/tags/vu3/">vu3</a></div><div class="post_share"><div class="social-share" data-image="https://images-origin.wallwiz.link/58860f026e9f6a00013b9428_1" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/57cd23c4/"><img class="prev-cover" src="https://images-origin.wallwiz.link/58860ebadc1d3f00010ad215_1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">vue 常见的坑</div></div></a></div><div class="next-post pull-right"><a href="/2377b695/"><img class="next-cover" src="https://images-origin.wallwiz.link/58860ebbbcf65400017a550f_1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">reduce 使用技巧</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/880232555/" title="JS dom元素位置相关的内容"><img class="cover" src="https://images-origin.wallwiz.link/590bc66690c79d0001e9cbad_1" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-27</div><div class="title">JS dom元素位置相关的内容</div></div></a></div><div><a href="/3315289936/" title="JS new 一个对象的过程"><img class="cover" src="https://images-origin.wallwiz.link/58860b456e9f6a00013b8f0f_1" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-29</div><div class="title">JS new 一个对象的过程</div></div></a></div><div><a href="/prototype/" title="JS prototype"><img class="cover" src="https://images-origin.wallwiz.link/59c1325eccb8f80001ef5d43_1" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-29</div><div class="title">JS prototype</div></div></a></div><div><a href="/proto/" title="JS __proto__和prototype的区别和关系"><img class="cover" src="https://images-origin.wallwiz.link/58860ead6e9f6a00013b93b1_1" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-15</div><div class="title">JS __proto__和prototype的区别和关系</div></div></a></div><div><a href="/1882318475/" title="JS 函数实参转换为数组"><img class="cover" src="https://images-origin.wallwiz.link/58860ea56e9f6a00013b93a3_1" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-29</div><div class="title">JS 函数实参转换为数组</div></div></a></div><div><a href="/3915840815/" title="JS this"><img class="cover" src="https://images-origin.wallwiz.link/59c13323c6a7580001cc9bfd_1" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-01</div><div class="title">JS this</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">李鹏辉</div><div class="author-info__description">学习 生活 成长</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">72</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E-Object-defineProperty-%E5%88%B0-Proxy"><span class="toc-number">1.</span> <span class="toc-text">从 Object.defineProperty 到 Proxy</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-defineProperty"><span class="toc-number">1.1.</span> <span class="toc-text">Object.defineProperty</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-Vue2-%E4%B8%AD%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">1.1.1.</span> <span class="toc-text">在 Vue2 中的缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E6%89%A9%E5%B1%95%E3%80%91Object-defineProperty-%E5%92%8C-Array-%EF%BC%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">【扩展】Object.defineProperty 和 Array ？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proxy-amp-Reflect"><span class="toc-number">1.2.</span> <span class="toc-text">Proxy &amp; Reflect</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Proxy"><span class="toc-number">1.2.1.</span> <span class="toc-text">Proxy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reflect"><span class="toc-number">1.2.2.</span> <span class="toc-text">Reflect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proxy-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Reflect-%E5%91%A2%EF%BC%9F"><span class="toc-number">1.2.3.</span> <span class="toc-text">Proxy 为什么需要 Reflect 呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3-Proxy-handler-%E4%B8%AD-receiver-%E6%8C%87%E5%90%91%E7%9A%84%E6%98%AF%E5%BD%93%E5%89%8D%E6%93%8D%E4%BD%9C%E6%AD%A3%E7%A1%AE%E4%B8%8A%E7%9A%84%E4%B8%8B%E6%96%87%E5%91%A2%EF%BC%9F"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">怎么理解 Proxy handler 中 receiver 指向的是当前操作正确上的下文呢？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue3-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Proxy-%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">Vue3 如何使用 Proxy 实现数据劫持？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#reactive-%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">reactive 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#createReactiveObject-%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">createReactiveObject() 函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%99%A8-Handlers"><span class="toc-number">2.2.</span> <span class="toc-text">捕获器 Handlers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8D%95%E8%8E%B7%E5%99%A8-%E2%80%94-mutableHandlers"><span class="toc-number">2.2.1.</span> <span class="toc-text">对象类型的捕获器 — mutableHandlers</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#get-%E6%8D%95%E8%8E%B7%E5%99%A8"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">get 捕获器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set-%E6%8D%95%E8%8E%B7%E5%99%A8"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">set 捕获器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deleteProperty-amp-has-amp-ownKeys-%E6%8D%95%E8%8E%B7%E5%99%A8"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">deleteProperty &amp; has &amp; ownKeys 捕获器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E6%8D%95%E8%8E%B7%E5%99%A8-%E2%80%94%E2%80%94-arrayInstrumentations"><span class="toc-number">2.2.2.</span> <span class="toc-text">数组类型捕获器 —— arrayInstrumentations</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95-index-%E5%92%8C-length"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">处理数组索引 index 和 length</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">处理数组的查找方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84%E5%BD%B1%E5%93%8D-length-%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">处理数组影响 length 的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8D%95%E8%8E%B7%E5%99%A8-%E2%80%94-mutableCollectionHandlers"><span class="toc-number">2.2.3.</span> <span class="toc-text">集合类型的捕获器 — mutableCollectionHandlers</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3-%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1-%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE-%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B-%E5%AF%B9%E5%BA%94%E7%9A%84-%E5%B1%9E%E6%80%A7-%E5%92%8C-%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">解决 代理对象 无法访问 集合类型 对应的 属性 和 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">处理集合类型的响应式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%B1%A1%E6%9F%93%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE"><span class="toc-number">2.2.3.3.</span> <span class="toc-text">避免污染原始数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86-forEach-%E5%9B%9E%E8%B0%83%E5%8F%82%E6%95%B0"><span class="toc-number">2.2.3.4.</span> <span class="toc-text">处理 forEach 回调参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.2.3.5.</span> <span class="toc-text">处理迭代器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ref-%E5%87%BD%E6%95%B0-%E2%80%94-%E5%8E%9F%E5%A7%8B%E5%80%BC%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">ref 函数 — 原始值的响应式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue3-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">Vue3 如何进行依赖收集？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%90%8E"><span class="toc-number">4.</span> <span class="toc-text">最后</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/34588bfd/" title="TS 基础中的基础"><img src="https://images-origin.wallwiz.link/5976161269f78700012df74f_1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TS 基础中的基础"/></a><div class="content"><a class="title" href="/34588bfd/" title="TS 基础中的基础">TS 基础中的基础</a><time datetime="2023-12-01T03:38:30.000Z" title="发表于 2023-12-01 11:38:30">2023-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2fe79698/" title="canvas VS WebGL"><img src="https://images-origin.wallwiz.link/58860ea5bcf65400017a54f0_1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="canvas VS WebGL"/></a><div class="content"><a class="title" href="/2fe79698/" title="canvas VS WebGL">canvas VS WebGL</a><time datetime="2023-11-01T11:13:19.000Z" title="发表于 2023-11-01 19:13:19">2023-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/sushu/" title="素书"><img src="https://images-origin.wallwiz.link/58860cbe6e9f6a00013b9112_1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="素书"/></a><div class="content"><a class="title" href="/sushu/" title="素书">素书</a><time datetime="2023-10-26T11:26:01.000Z" title="发表于 2023-10-26 19:26:01">2023-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/d396855b/" title="来处一个老程序员的忠告"><img src="https://images-origin.wallwiz.link/58860ea5bcf65400017a54f0_1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="来处一个老程序员的忠告"/></a><div class="content"><a class="title" href="/d396855b/" title="来处一个老程序员的忠告">来处一个老程序员的忠告</a><time datetime="2023-10-19T05:45:55.000Z" title="发表于 2023-10-19 13:45:55">2023-10-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/d55bdcba/" title="ts objecy[key] 报错"><img src="https://images-origin.wallwiz.link/58860ea5bcf65400017a54f0_1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ts objecy[key] 报错"/></a><div class="content"><a class="title" href="/d55bdcba/" title="ts objecy[key] 报错">ts objecy[key] 报错</a><time datetime="2023-09-21T02:48:25.000Z" title="发表于 2023-09-21 10:48:25">2023-09-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 李鹏辉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>