<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lee JS</title>
  <icon>https://www.gravatar.com/avatar/22c275b84c2b7b1a027d1778a6242d51</icon>
  <subtitle>Lee Blog</subtitle>
  <link href="https://leejs.cn/atom.xml" rel="self"/>
  
  <link href="https://leejs.cn/"/>
  <updated>2022-08-18T06:10:06.561Z</updated>
  <id>https://leejs.cn/</id>
  
  <author>
    <name>李鹏辉</name>
    <email>ahuinet@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ts入门</title>
    <link href="https://leejs.cn/undefined/"/>
    <id>https://leejs.cn/undefined/</id>
    <published>2022-08-18T06:06:10.000Z</published>
    <updated>2022-08-18T06:10:06.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-TypeScript"><a href="#什么是-TypeScript" class="headerlink" title="什么是 TypeScript"></a>什么是 TypeScript</h2><p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。</p><blockquote><p>简而言之，TypeScript是JavaScript的超集，具有可选的类型并可以编译为纯JavaScript。从技术上讲TypeScript就是具有静态类型的 JavaScript 。</p></blockquote><h2 id="TypeScript优缺点"><a href="#TypeScript优缺点" class="headerlink" title="TypeScript优缺点"></a>TypeScript优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>增强代码的可维护性，尤其在大型项目的时候效果显著</li><li>友好地在编辑器里提示错误，编译阶段就能检查类型发现大部分错误</li><li>支持最新的JavaScript新特特性</li><li>周边生态繁荣，vue3已全面支持 typescript</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>需要一定的学习成本</li><li>和一些插件库的兼容并不是特别完美，如以前在 vue2 项目里使用 typescript就并不是那么顺畅</li><li>增加前期开发的成本，毕竟你需要写更多的代码（但是便于后期的维护）</li></ul><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><h3 id="安装typescript"><a href="#安装typescript" class="headerlink" title="安装typescript"></a>安装typescript</h3><p>首先，我们可以新建一个空文件夹，用来学习 ts，例如我在文件夹下新建了个 <code>helloworld.ts</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g  typescript // 全局安装 ts</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不记得自己是否已经安装过 typescript 的，可以使用以下命令来验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc -v </span><br></pre></td></tr></table></figure><p>如果出现版本，则说明已经安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Version 4.6.3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生成 tsconfig.json 配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tsc --init</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行命令后我们就可以看到生成了一个 tsconfig.json 文件，里面有一些配置信息，我们暂时先按下不表</p><p>在我们<code>helloworld.ts</code>文件中,随便写点什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const s:string = &quot;彼时彼刻，恰如此时此刻&quot;;</span><br><span class="line">console.log(s);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>控制台执行 <code>tsc helloworld.ts</code> 命令，目录下生成了一个同名的 helloworld.js 文件，代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s = &quot;彼时彼刻，恰如此时此刻&quot;;</span><br><span class="line">console.log(s);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过tsc命令，发现我们的typescript代码被转换成了熟悉的js代码</p><p>我们接着执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node helloworld.js</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>即可看到输出结果</p><h2 id="安装-ts-node"><a href="#安装-ts-node" class="headerlink" title="安装 ts-node"></a>安装 ts-node</h2><p>那么通过我们上面的一通操作，我们知道了运行tsc命令就可以编译生成一个js文件，但是如果每次改动我们都要手动去执行编译，然后再通过 node命令才能查看运行结果岂不是太麻烦了。</p><p>而 ts-node 正是来解决这个问题的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i -g ts-node // 全局安装ts-node</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有了这个插件，我们就可以直接运行.ts文件了</p><p>我们试一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ts-node helloworld.ts</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到我们的打印结果已经输出</p><p>后续我们的示例都可以通过这个命令来进行验证</p><p>接下来我们就可以正式进入到 typescript 的学习之旅了</p><h2 id="TypeScript-基础类型"><a href="#TypeScript-基础类型" class="headerlink" title="TypeScript 基础类型"></a>TypeScript 基础类型</h2><h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const flag: boolean = true;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const count: number = 10;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let name: string = &quot;树哥&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Enum-类型"><a href="#Enum-类型" class="headerlink" title="Enum 类型"></a>Enum 类型</h3><p>枚举类型用于定义数值集合，使用枚举我们可以定义一些带名字的常量。使用枚举可以清晰地表达意图或创建一组有区别的用例。，如周一到周日，方位上下左右等</p><ul><li>普通枚举</li></ul><p>初始值默认为 0 其余的成员会会按顺序自动增长 可以理解为数组下标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">  RED,</span><br><span class="line">  PINK,</span><br><span class="line">  BLUE,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const red: Color = Color.RED;</span><br><span class="line">console.log(red); // 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>设置初始值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">  RED = 2,</span><br><span class="line">  PINK,</span><br><span class="line">  BLUE,</span><br><span class="line">&#125;</span><br><span class="line">const pink: Color = Color.PINK;</span><br><span class="line">console.log(pink); // 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>字符串枚举</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">  RED = &quot;红色&quot;,</span><br><span class="line">  PINK = &quot;粉色&quot;,</span><br><span class="line">  BLUE = &quot;蓝色&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const pink: Color = Color.PINK;</span><br><span class="line">console.log(pink); // 粉色</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>常量枚举</li></ul><p>使用 const 关键字修饰的枚举，常量枚举与普通枚举的区别是，整个枚举会在编译阶段被删除 我们可以看下编译之后的效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const enum Color &#123;</span><br><span class="line">  RED,</span><br><span class="line">  PINK,</span><br><span class="line">  BLUE,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const color: Color[] = [Color.RED, Color.PINK, Color.BLUE];</span><br><span class="line">console.log(color); //[0, 1, 2]</span><br><span class="line"></span><br><span class="line">//编译之后的js如下：</span><br><span class="line">var color = [0 /* RED */, 1 /* PINK */, 2 /* BLUE */];</span><br><span class="line">// 可以看到我们的枚举并没有被编译成js代码 只是把color这个数组变量编译出来了</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h3><p>对数组类型的定义有两种方式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr: number[] = [1,2,3];</span><br><span class="line">const arr2: Array&lt;number&gt; = [1,2,3];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="元组（tuple）类型"><a href="#元组（tuple）类型" class="headerlink" title="元组（tuple）类型"></a>元组（tuple）类型</h3><p>上面数组类型的方式，只能定义出内部全为同种类型的数组。对于内部不同类型的数组可以使用元组类型来定义</p><p>元组（ Tuple ）表示一个已知数量和类型的数组,可以理解为他是一种特殊的数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const tuple: [number, string] = [1, &quot;zhangmazi&quot;];</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，元组类型只能表示一个已知元素数量和类型的数组，长度已指定，越界访问会提示错误。例如，一个数组中可能有多种类型，数量和类型都不确定，那就直接any[]。</p></blockquote><h3 id="undefined和null"><a href="#undefined和null" class="headerlink" title="undefined和null"></a>undefined和null</h3><p>默认情况下 null 和 undefined 是所有类型的子类型。也就是说你可以把 null 和 undefined 赋值给其他类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let a: undefined = undefined;</span><br><span class="line">let b: null = null;</span><br><span class="line"></span><br><span class="line">let str: string = &#x27;zhangmazi&#x27;;</span><br><span class="line">str = null; // 编译正确</span><br><span class="line">str = undefined; // 编译正确</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你在tsconfig.json指定了”strictNullChecks”:true ，即开启严格模式后， null 和 undefined 只能赋值给 void 和它们各自的类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 启用 --strictNullChecks</span><br><span class="line">let x: number;</span><br><span class="line">x = 1; // 编译正确</span><br><span class="line">x = undefined;    // 编译错误</span><br><span class="line">x = null;    // 编译错误</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h3><p>any会跳过类型检查器对值的检查，任何值都可以赋值给any类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let value: any = 1;</span><br><span class="line">value = &quot;zhangmazi&quot;; // 编译正确</span><br><span class="line">value = []; // 编译正确</span><br><span class="line">value = &#123;&#125;;// 编译正确</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h3><p>void 意思就是无效的, 一般只用在函数上，告诉别人这个函数没有返回值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function sayHello(): void &#123;</span><br><span class="line">  console.log(&quot;hello 啊，树哥！&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a>never 类型</h3><p>never 类型表示的是那些永不存在的值的类型。例如never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型</p><p>值会永不存在的两种情况：</p><ul><li>1 如果一个函数执行时抛出了异常，那么这个函数永远不存在返回值（因为抛出异常会直接中断程序运行，这使得程序运行不到返回值那一步，即具有不可达的终点，也就永不存在返回了）</li><li>2 函数中执行无限循环的代码（死循环），使得程序永远无法运行到函数返回值那一步，永不存在返回。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 异常</span><br><span class="line">function error(msg: string): never &#123; // 编译正确</span><br><span class="line">  throw new Error(msg); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 死循环</span><br><span class="line">function loopForever(): never &#123; // 编译正确</span><br><span class="line">  while (true) &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Unknown-类型"><a href="#Unknown-类型" class="headerlink" title="Unknown 类型"></a>Unknown 类型</h3><p>unknown与any一样，所有类型都可以分配给unknown:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let value: unknown = 1;</span><br><span class="line">value = &quot;zhangmazi&quot;; // 编译正确</span><br><span class="line">value = false; // 编译正确</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>unknown与any的最大区别是：</p><blockquote><p>任何类型的值可以赋值给any，同时any类型的值也可以赋值给任何类型。unknown 任何类型的值都可以赋值给它，但它只能赋值给unknown和any</p></blockquote><h2 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h2><p>这里所说的对象类型，就是我们常说的<code>函数、&#123;&#125;、数组、类</code></p><h3 id="object-Object-和-类型"><a href="#object-Object-和-类型" class="headerlink" title="object, Object 和 {} 类型"></a>object, Object 和 {} 类型</h3><ul><li>object object 类型用于表示所有的非原始类型，即我们不能把 number、string、boolean、symbol等 原始类型赋值给 object。在严格模式下，null 和 undefined 类型也不能赋给 object。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let object: object;</span><br><span class="line">object = 1; // 报错</span><br><span class="line">object = &quot;a&quot;; // 报错</span><br><span class="line">object = true; // 报错</span><br><span class="line">object = null; // 报错</span><br><span class="line">object = undefined; // 报错</span><br><span class="line">object = &#123;&#125;; // 编译正确</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Object</li></ul><p>大 Object 代表所有拥有 toString、hasOwnProperty 方法的类型 所以所有原始类型、非原始类型都可以赋给 Object(严格模式下 null 和 undefined 不可以)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let bigObject: Object;</span><br><span class="line">object = 1; // 编译正确</span><br><span class="line">object = &quot;a&quot;; // 编译正确</span><br><span class="line">object = true; // 编译正确</span><br><span class="line">object = null; // 报错</span><br><span class="line">ObjectCase = undefined; // 报错</span><br><span class="line">ObjectCase = &#123;&#125;; // ok</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>{}</li></ul><p>{} 空对象类型和大 Object 一样 也是表示原始类型和非原始类型的集合</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>在 TypeScript 中，我们通过 Class 关键字来定义一个类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  constructor(name: string, age: number) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  sayHi(): void &#123;</span><br><span class="line">    console.log(`Hi, $&#123;this.name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const flag1: number[] = [1, 2, 3];</span><br><span class="line">const flag2: Array&lt;number&gt; = [1, 2, 3];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function add(x: number, y: number): number &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const add = function(x: number, y: number): number &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="接口定义函数"><a href="#接口定义函数" class="headerlink" title="接口定义函数"></a>接口定义函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Add &#123;</span><br><span class="line">  (x: number, y: number): number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function add(x: number, y?: number): number &#123;</span><br><span class="line">  return y ? x + y : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function add(x: number, y: number = 0): number &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function add(...numbers: number[]): number &#123;</span><br><span class="line">  let sum = 0;</span><br><span class="line">  for (let i = 0; i &lt; numbers.length; i++) &#123;</span><br><span class="line">    sum += numbers[i];</span><br><span class="line">  &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function add(x: number, y: number): number;</span><br><span class="line">function add(x: string, y: string): string;</span><br><span class="line">function add(x: any, y: any): any &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面示例中，我们给同一个函数提供多个函数类型定义，从而实现函数的重载</p><p>需要注意的是:</p><blockquote><p>函数重载真正执行的是同名函数最后定义的函数体 在最后一个函数体定义之前全都属于函数类型定义 不能写具体的函数实现方法 只能定义类型</p></blockquote><p><strong>具体示例原理可参考</strong>[1]</p><h2 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h2><p>如果没有明确的指定类型，那么 TypeScript 会依照类型推论的规则推断出一个类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let x = 1;</span><br><span class="line">x = true; // 报错</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的代码等价于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let x: number = 1;</span><br><span class="line">x = true; // 报错</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过上述示例我们可以看出，我们没有给 x 指定明确类型的时候，typescript 会推断出 x 的类型是 number。</p><p>而如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let x;</span><br><span class="line">x = 1; // 编译正确</span><br><span class="line">x = true; // 编译正确</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>某些情况下，我们可能比typescript更加清楚的知道某个变量的类型，所以我们可能希望手动指定一个值的类型</p><p>类型断言有两种方式</p><ul><li>尖括号写法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let str: any = &quot;to be or not to be&quot;;</span><br><span class="line">let strLength: number = (&lt;string&gt;str).length;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>as 写法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let str: any = &quot;to be or not to be&quot;;</span><br><span class="line">let strLength: number = (str as string).length;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言"></a>非空断言</h3><p>在上下文中当类型检查器无法断定类型时，可以使用缀表达式操作符 <code>!</code> 进行断言操作对象是非 null 和非 undefined 的类型，<strong>即x!的值不会为 null 或 undefined</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let user: string | null | undefined;</span><br><span class="line">console.log(user!.toUpperCase()); // 编译正确</span><br><span class="line">console.log(user.toUpperCase()); // 错误</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="确定赋值断言"><a href="#确定赋值断言" class="headerlink" title="确定赋值断言"></a>确定赋值断言</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let value:number</span><br><span class="line">console.log(value); // Variable &#x27;value&#x27; is used before being assigned.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们定义了变量, 没有赋值就使用，则会报错</p><p>通过 let x!: number; 确定赋值断言，TypeScript 编译器就会知道该属性会被明确地赋值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let value!:number</span><br><span class="line">console.log(value); // undefined 编译正确</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>联合类型用<code>|</code>分隔，表示取值可以为多种类型中的一种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let status:string|number</span><br><span class="line">status=&#x27;to be or not to be&#x27;</span><br><span class="line">status=1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名用来给一个类型起个新名字。它只是起了一个新名字，并没有创建新类型。类型别名常用于联合类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type count = number | number[];</span><br><span class="line">function hello(value: count) &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h2><p>交叉类型就是跟联合类型相反，用<code>&amp;</code>操作符表示，交叉类型就是两个类型必须存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface IpersonA&#123;</span><br><span class="line">  name: string,</span><br><span class="line">  age: number</span><br><span class="line">&#125;</span><br><span class="line">interface IpersonB &#123;</span><br><span class="line">  name: string,</span><br><span class="line">  gender: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person: IpersonA &amp; IpersonB = &#123; </span><br><span class="line">    name: &quot;师爷&quot;,</span><br><span class="line">    age: 18,</span><br><span class="line">    gender: &quot;男&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>person 即是 IpersonA 类型，又是 IpersonB 类型</p><blockquote><p>注意：交叉类型取的多个类型的并集，但是如果key相同但是类型不同，则该key为never类型</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface IpersonA &#123;</span><br><span class="line">    name: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IpersonB &#123;</span><br><span class="line">    name: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function testAndFn(params: IpersonA &amp; IpersonB) &#123;</span><br><span class="line">    console.log(params)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testAndFn(&#123;name: &quot;黄老爷&quot;&#125;) // error TS2322: Type &#x27;string&#x27; is not assignable to type &#x27;never&#x27;.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类型守卫"><a href="#类型守卫" class="headerlink" title="类型守卫"></a>类型守卫</h2><p><strong>类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内</strong>。换句话说，类型保护可以保证一个字符串是一个字符串，尽管它的值也可以是一个数值。类型保护与特性检测并不是完全不同，其主要思想是尝试检测属性、方法或原型，以确定如何处理值。</p><p>换句话说：<strong>类型守卫是运行时检查，确保一个值在所要类型的范围内</strong></p><p>目前主要有四种的方式来实现类型保护：</p><ul><li>1、in 关键字</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface InObj1 &#123;</span><br><span class="line">    a: number,</span><br><span class="line">    x: string</span><br><span class="line">&#125;</span><br><span class="line">interface InObj2 &#123;</span><br><span class="line">    a: number,</span><br><span class="line">    y: string</span><br><span class="line">&#125;</span><br><span class="line">function isIn(arg: InObj1 | InObj2) &#123;</span><br><span class="line">    // x 在 arg 打印 x</span><br><span class="line">    if (&#x27;x&#x27; in arg) console.log(&#x27;x&#x27;)</span><br><span class="line">    // y 在 arg 打印 y</span><br><span class="line">    if (&#x27;y&#x27; in arg) console.log(&#x27;y&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">isIn(&#123;a:1, x:&#x27;xxx&#x27;&#125;);</span><br><span class="line">isIn(&#123;a:1, y:&#x27;yyy&#x27;&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>2、typeof 关键字</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function isTypeof( val: string | number) &#123;</span><br><span class="line">  if (typeof val === &quot;number&quot;) return &#x27;number&#x27;</span><br><span class="line">  if (typeof val === &quot;string&quot;) return &#x27;string&#x27;</span><br><span class="line">  return &#x27;啥也不是&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>typeof 只支持：typeof ‘x’ &#x3D;&#x3D;&#x3D; ‘typeName’ 和 typeof ‘x’ !&#x3D;&#x3D; ‘typeName’，x 必须是 ‘number’, ‘string’, ‘boolean’, ‘symbol’。</p></blockquote><ul><li>3、instanceof</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function creatDate(date: Date | string)&#123;</span><br><span class="line">    console.log(date)</span><br><span class="line">    if(date instanceof Date)&#123;</span><br><span class="line">        date.getDate()</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return new Date(date)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>4、自定义类型保护的类型谓词</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function isNumber(num: any): num is number &#123;</span><br><span class="line">    return typeof num === &#x27;number&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">function isString(str: any): str is string&#123;</span><br><span class="line">    return typeof str=== &#x27;string&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>我们使用接口来定义对象的类型。接口是对象的状态(属性)和行为(方法)的抽象(描述)</p><p>简单理解就是：<strong>为我们的代码提供一种约定</strong></p><p>我们使用关键字interface来声明接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    age: 25</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们定义了一个接口 Person，接着定义了一个变量 tom，它的类型是 Person。这样，我们就约束了 tom 的形状必须和接口 Person 一致。</p><p>接口一般首字母大写。(当然挺多人也习惯 I 大写字母开头，用来表示这是一个接口)</p><h3 id="设置接口可选-只读"><a href="#设置接口可选-只读" class="headerlink" title="设置接口可选|只读"></a>设置接口可选|只读</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  readonly name: string;</span><br><span class="line">  age?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>可选属性，我们最常见的使用情况是，不确定这个参数是否会传，或者存在。</li><li>只读属性用于限制只能在对象刚刚创建的时候修改其值。此外 TypeScript 还提供了 ReadonlyArray 类型，它与 Array 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。</li></ul><h3 id="索引签名"><a href="#索引签名" class="headerlink" title="索引签名"></a>索引签名</h3><p>有时候我们希望一个接口中除了包含必选和可选属性之外，还允许有其他的任意属性，这时我们可以使用 <strong>索引签名</strong> 的形式来满足上述要求。</p><blockquote><p>需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age?: number;</span><br><span class="line">  [prop: string]: any; //  propName字段必须是 string类型 or number类型。 值是any类型，也就是任意的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const p1 = &#123; name: &quot;张麻子&quot; &#125;;</span><br><span class="line">const p2 = &#123; name: &quot;树哥&quot;, age: 28 &#125;;</span><br><span class="line">const p3 = &#123; name: &quot;汤师爷&quot;, sex: 1 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们规定 以 string 类型的值来索引，索引到的是一个 any 类型的值</p><h3 id="接口与类型别名的区别"><a href="#接口与类型别名的区别" class="headerlink" title="接口与类型别名的区别"></a>接口与类型别名的区别</h3><p>实际上，在大多数的情况下使用接口类型和类型别名的效果等价，但是在某些特定的场景下这两者还是存在很大区别。</p><blockquote><p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查。而接口的作用就是为这些类型命名和为你的代码或第三方代码定义数据模型。</p></blockquote><blockquote><p>type(类型别名)会给一个类型起个新名字。type 有时和 interface 很像，但是可以作用于原始值（基本类型），联合类型，元组以及其它任何你需要手写的类型。起别名不会新建一个类型 - 它创建了一个新名字来引用那个类型。给基本类型起别名通常没什么用，尽管可以做为文档的一种形式使用。</p></blockquote><p><strong>接口和类型别名都可以用来描述对象或函数的类型，只是语法不同</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type MyTYpe = &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  say(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface MyInterface &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  say(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>都允许扩展</strong></p><ul><li>interface 用 <code>extends</code> 来实现扩展</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface MyInterface &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  say(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface MyInterface2 extends MyInterface &#123;</span><br><span class="line">  sex: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person:MyInterface2 = &#123;</span><br><span class="line">  name:&#x27;树哥&#x27;,</span><br><span class="line">  sex:&#x27;男&#x27;,</span><br><span class="line">  say(): void &#123;</span><br><span class="line">    console.log(&quot;hello 啊，树哥！&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>type 使用 <code>&amp;</code> 实现扩展</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type MyType = &#123;</span><br><span class="line">  name:string;</span><br><span class="line">  say(): void;</span><br><span class="line">&#125;</span><br><span class="line">type MyType2 = MyType &amp; &#123;</span><br><span class="line">  sex:string;</span><br><span class="line">&#125;</span><br><span class="line">let value: MyType2 = &#123;</span><br><span class="line">  name:&#x27;树哥&#x27;,</span><br><span class="line">  sex:&#x27;男&#x27;,</span><br><span class="line">  say(): void &#123;</span><br><span class="line">    console.log(&quot;hello 啊，树哥！&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul><li>type可以声明基本数据类型别名&#x2F;联合类型&#x2F;元组等，而interface不行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 基本类型别名</span><br><span class="line">type UserName = string;</span><br><span class="line">type UserName = string | number;</span><br><span class="line">// 联合类型</span><br><span class="line">type Animal = Pig | Dog | Cat;</span><br><span class="line">type List = [string, boolean, number];</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>interface能够合并声明，而type不行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string</span><br><span class="line">&#125;</span><br><span class="line">interface Person &#123;</span><br><span class="line">  age: number</span><br><span class="line">&#125;</span><br><span class="line">// 此时Person同时具有name和age属性</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p><p>举个例子，比如我们现在有个这样的需求，我们要实现一个这样的函数，函数的参数可以是任何值，返回值就是将参数原样返回，并且参数的类型是 string，函数返回类型就为 string？</p><p>你很容易写下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function getValue(arg:string):string  &#123;</span><br><span class="line">  return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在需求有变，需要返回一个 number 类型的值，你会说，联合类型就完事了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function getValue(arg:string | number):string | number  &#123;</span><br><span class="line">  return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是这样又有一个问题，就是如果我们需要返回一个 boolean 类型，string 数组甚至任意类型呢，难道有多少个就写多少个联合类型？</p><p>是的，我们直接用 any 就行了！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function getValue(arg:any):any  &#123;</span><br><span class="line">  return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>尽管 any 大法好，很多时候 any 也确实能够解决不少问题，但是这样也不符合我们的需求了，传入和返回都是 any 类型，<strong>传入和返回并没有统一</strong></p><p>作为一个骚有最求的程序员，我们还能不能有其他解决办法呢？</p><p>这个时候就要祭出我们的泛型了</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性</p><p>上面的需求，我们如果用泛型来解决的话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function getValue&lt;T&gt;(arg:T):T  &#123;</span><br><span class="line">  return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>泛型的语法是尖括号 <code>&lt;&gt;</code> 里面写类型参数，一般用 <code>T</code> 来表示第一个类型变量名称，其实它可以用任何有效名称来代替,比如我们用<code>NIUBI</code>也是编译正常的</p><blockquote><p>泛型就像一个占位符一个变量，在使用的时候我们可以将定义好的类型像参数一样传入，原封不动的输出</p></blockquote><p><strong>使用</strong></p><p>我们有两种方式来使用：</p><p>- </p><ul><li><ol><li>定义要使用的类型，比如：</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getValue&lt;string&gt;(&#x27;树哥&#x27;); // 定义 T 为 string 类型</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>- </p><ul><li><ol><li>利用 typescript 的类型推断，比如：</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getValue(&#x27;树哥&#x27;) // 自动推导类型为 string</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="多个参数"><a href="#多个参数" class="headerlink" title="多个参数"></a>多个参数</h3><p>其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个新的类型变量 U</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getValue&lt;T, U&gt;(arg:[T,U]):[T,U] &#123;</span><br><span class="line">  return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">const str = getValue([&#x27;树哥&#x27;, 18]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQR7Ujrq3JOdFEjypcT9HbREJmk5dw0bORpdeYnmXqOC9X5vpEmoQ4ae9u8aXQDT7sczTTEibPbUeZA/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">typescript 给我们自动推断出输入、返回的类型</p><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function getLength&lt;T&gt;(arg:T):T  &#123;</span><br><span class="line">  console.log(arg.length); // 报错，不能调用 length 属性</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为泛型 T 不一定包含属性 length，那么我想 getLength 这个函数只允许传入包含 length 属性的变量，该怎么做呢</p><p>这时，我们可以使用<code>extends</code>关键字来对泛型进行约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Lengthwise &#123;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getLength&lt;T extends Lengthwise&gt;(arg:T):T  &#123;</span><br><span class="line">  console.log(arg.length); </span><br><span class="line">  return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const str = getLength(&#x27;树哥&#x27;)</span><br><span class="line">const arr = getLength([1,2,3])</span><br><span class="line">const obj = getLength(&#123; length: 5 &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这里可以看出，不管你是 str，arr 还是obj，只要具有 length 属性，都可以</p></blockquote><p>具体参考<strong>轻松拿下 TS 泛型</strong>[2]</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>在定义接口的时候指定泛型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface KeyValue&lt;T,U&gt; &#123;</span><br><span class="line">  key: T;</span><br><span class="line">  value: U;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person1:KeyValue&lt;string,number&gt; = &#123;</span><br><span class="line">  key: &#x27;树哥&#x27;,</span><br><span class="line">  value: 18</span><br><span class="line">&#125;</span><br><span class="line">const person2:KeyValue&lt;number,string&gt; = &#123;</span><br><span class="line">  key: 20,</span><br><span class="line">  value: &#x27;张麻子&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Test&lt;T&gt; &#123;</span><br><span class="line">  value: T;</span><br><span class="line">  add: (x: T, y: T) =&gt; T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myTest = new Test&lt;number&gt;();</span><br><span class="line">myTest.value = 0;</span><br><span class="line">myTest.add = function (x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="泛型类型别名"><a href="#泛型类型别名" class="headerlink" title="泛型类型别名"></a>泛型类型别名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Cart&lt;T&gt; = &#123; list: T[] &#125; | T[];</span><br><span class="line">let c1: Cart&lt;string&gt; = &#123; list: [&quot;1&quot;] &#125;;</span><br><span class="line">let c2: Cart&lt;number&gt; = [1];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="泛型参数的默认类型"><a href="#泛型参数的默认类型" class="headerlink" title="泛型参数的默认类型"></a>泛型参数的默认类型</h3><p>我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。有点 js 里函数默认参数的意思。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function createArray&lt;T = string&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">  let result: T[] = [];</span><br><span class="line">  for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">    result[i] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="泛型工具类型"><a href="#泛型工具类型" class="headerlink" title="泛型工具类型"></a>泛型工具类型</h3><ul><li>typeof</li></ul><p>关键词除了做类型保护，还可以从实现推出类型，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//先定义变量，再定义类型</span><br><span class="line">let p1 = &#123;</span><br><span class="line">  name: &quot;树哥&quot;,</span><br><span class="line">  age: 18,</span><br><span class="line">  gender: &quot;male&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">type People = typeof p1;</span><br><span class="line">function getName(p: People): string &#123;</span><br><span class="line">  return p.name;</span><br><span class="line">&#125;</span><br><span class="line">getName(p1);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>keyof</li></ul><p>可以用来获取一个对象接口中的所有 key 值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  gender: &quot;male&quot; | &quot;female&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type PersonKey = keyof Person; //type PersonKey = &#x27;name&#x27;|&#x27;age&#x27;|&#x27;gender&#x27;;</span><br><span class="line"></span><br><span class="line">function getValueByKey(p: Person, key: PersonKey) &#123;</span><br><span class="line">  return p[key];</span><br><span class="line">&#125;</span><br><span class="line">let val = getValueByKey(&#123; name: &quot;树哥&quot;, age: 18, gender: &quot;male&quot; &#125;, &quot;name&quot;);</span><br><span class="line">console.log(val); // 树哥</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>in</li></ul><p>用来遍历枚举类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Keys = &quot;a&quot; | &quot;b&quot; | &quot;c&quot;</span><br><span class="line"></span><br><span class="line">type Obj =  &#123;</span><br><span class="line">  [p in Keys]: any</span><br><span class="line">&#125; // -&gt; &#123; a: any, b: any, c: any &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>infer</li></ul><p>在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type ReturnType&lt;T&gt; = T extends (</span><br><span class="line">  ...args: any[]</span><br><span class="line">) =&gt; infer R ? R : any;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>infer R 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。</p><ul><li>extends</li></ul><p>有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Lengthwise &#123;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;</span><br><span class="line">  console.log(arg.length);</span><br><span class="line">  return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(3);  // Error, number doesn&#x27;t have a .length property</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当我们传入合法的类型的值，即包含 length 属性的值时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(&#123;length: 10, name: &#x27;张麻子&#x27;&#125;); // 编译正确</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>索引访问操作符</li></ul><p>使用 <code>[]</code> 操作符可以进行索引访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type x = Person[&quot;name&quot;]; // x is string</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="内置工具类型"><a href="#内置工具类型" class="headerlink" title="内置工具类型"></a>内置工具类型</h3><ol><li>Required</li></ol><p>将类型的属性变成必选</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name?: string,</span><br><span class="line">    age?: number,</span><br><span class="line">    hobby?: string[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const user: Required&lt;Person&gt; = &#123;</span><br><span class="line">    name: &quot;树哥&quot;,</span><br><span class="line">    age: 18,</span><br><span class="line">    hobby: [&quot;code&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>Partial</li></ol><p>与 Required 相反，将所有属性转换为可选属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string,</span><br><span class="line">    age: number,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const shuge:Person = &#123;</span><br><span class="line">  name:&#x27;树哥&#x27;</span><br><span class="line">&#125; // error  Property &#x27;age&#x27; is missing in type &#x27;&#123; name: string; &#125;&#x27; but required in type &#x27;Person&#x27;.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面知道，如果必传而我们少穿传了的话，就会报错</p><p>我们使用 Partial 将其变为可选</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type User = Partial&lt;Person&gt;</span><br><span class="line"></span><br><span class="line">const shuge: User=&#123;</span><br><span class="line">  name:&#x27;树哥&#x27;</span><br><span class="line">&#125; // 编译正确</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>Exclude</li></ol><p><code>Exclude&lt;T, U&gt;</code> 的作用是将某个类型中属于另一个的类型移除掉,剩余的属性构成新的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type T0 = Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot;&gt;; // &quot;b&quot; | &quot;c&quot;</span><br><span class="line">type T1 = Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;b&quot;&gt;; // &quot;c&quot;</span><br><span class="line">type T2 = Exclude&lt;string | number | (() =&gt; void), Function&gt;; // string | number</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>Extract</li></ol><p>和 Exclude 相反，<code>Extract&lt;T,U&gt;</code> 从 T 中提取出 U。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type T0 = Extract&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;f&quot;&gt;; // &quot;a&quot;</span><br><span class="line">type T1 = Extract&lt;string | number | (() =&gt; void), Function&gt;; // () =&gt;void</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>适用于：并集类型</p></blockquote><ol><li>Readonly</li></ol><p>把数组或对象的所有属性值转换为只读的，这就意味着这些属性不能被重新赋值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  gender?: &quot;male&quot; | &quot;female&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p: Readonly&lt;Person&gt; = &#123;</span><br><span class="line">  name: &quot;hello&quot;,</span><br><span class="line">  age: 10,</span><br><span class="line">  gender: &quot;male&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">p.age = 11; // error  Cannot assign to &#x27;age&#x27; because it is a read-only property.</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>Record</li></ol><p>Record&lt;K extends keyof any, T&gt; 的作用是将 K 中所有的属性的值转化为 T 类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Property = &#x27;key1&#x27;|&#x27;key2&#x27;</span><br><span class="line">type Person = Record&lt;Property, string&gt;;</span><br><span class="line"></span><br><span class="line">const p: Person = &#123;</span><br><span class="line">  key1: &quot;hello 啊&quot;,</span><br><span class="line">  key2: &quot;树哥&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>Pick</li></ol><p>从某个类型中挑出一些属性出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Person = &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age:number;</span><br><span class="line">  gender:string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type P1 = Pick&lt;Person, &quot;name&quot; | &quot;age&quot;&gt;; // &#123; name: string; age: number; &#125;</span><br><span class="line"></span><br><span class="line">const user:P1=&#123;</span><br><span class="line">  name:&#x27;树哥&#x27;,</span><br><span class="line">  age:18</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>Omit</li></ol><p>与Pick相反，<code>Omit&lt;T,K&gt;</code> 从T中取出除去K的其他所有属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string,</span><br><span class="line">  age: number,</span><br><span class="line">  gender: string</span><br><span class="line">&#125;</span><br><span class="line">type P1 = Omit&lt;Person, &quot;age&quot; | &quot;gender&quot;&gt;</span><br><span class="line">const user:P1  = &#123;</span><br><span class="line">  name: &#x27;树哥&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>NonNullable</li></ol><p>去除类型中的 <code>null</code> 和 <code>undefined</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type P1 = NonNullable&lt;string | number | undefined&gt;; // string | number</span><br><span class="line">type P2 = NonNullable&lt;string[] | null | undefined&gt;; // string[]</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>ReturnType</li></ol><p>用来得到一个函数的返回值类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Func = (value: string) =&gt; string;</span><br><span class="line">const test: ReturnType&lt;Func&gt; = &quot;1&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>Parameters</li></ol><p>用于获得函数的参数类型所组成的元组类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type P1 = Parameters&lt;(a: number, b: string) =&gt; void&gt;; // [number, string]</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>InstanceType</li></ol><p>返回构造函数类型T的实例类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">  x = 0;</span><br><span class="line">  y = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type D = InstanceType&lt;typeof C&gt;;  // C</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h2><p>在文章开头环境安装部分，记得我们有生成一个 tsconfig.json 文件，那么这个文件究竟有什么用呢</p><p>tsconfig.json 是 TypeScript 项目的配置文件。</p><p>tsconfig.json 包含 TypeScript 编译的相关配置，通过更改编译配置项，我们可以让 TypeScript 编译出 ES6、ES5、node 的代码。</p><h3 id="重要字段"><a href="#重要字段" class="headerlink" title="重要字段"></a>重要字段</h3><ul><li>files - 设置要编译的文件的名称；</li><li>include - 设置需要进行编译的文件，支持路径模式匹配；</li><li>exclude - 设置无需进行编译的文件，支持路径模式匹配；</li><li>compilerOptions - 设置与编译流程相关的选项。</li></ul><h3 id="compilerOptions-选项"><a href="#compilerOptions-选项" class="headerlink" title="compilerOptions 选项"></a>compilerOptions 选项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line"></span><br><span class="line">    /* 基本选项 */</span><br><span class="line">    &quot;target&quot;: &quot;es5&quot;,                       // 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES6&#x27;/&#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;</span><br><span class="line">    &quot;module&quot;: &quot;commonjs&quot;,                  // 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;</span><br><span class="line">    &quot;lib&quot;: [],                             // 指定要包含在编译中的库文件</span><br><span class="line">    &quot;allowJs&quot;: true,                       // 允许编译 javascript 文件</span><br><span class="line">    &quot;checkJs&quot;: true,                       // 报告 javascript 文件中的错误</span><br><span class="line">    &quot;jsx&quot;: &quot;preserve&quot;,                     // 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;</span><br><span class="line">    &quot;declaration&quot;: true,                   // 生成相应的 &#x27;.d.ts&#x27; 文件</span><br><span class="line">    &quot;sourceMap&quot;: true,                     // 生成相应的 &#x27;.map&#x27; 文件</span><br><span class="line">    &quot;outFile&quot;: &quot;./&quot;,                       // 将输出文件合并为一个文件</span><br><span class="line">    &quot;outDir&quot;: &quot;./&quot;,                        // 指定输出目录</span><br><span class="line">    &quot;rootDir&quot;: &quot;./&quot;,                       // 用来控制输出目录结构 --outDir.</span><br><span class="line">    &quot;removeComments&quot;: true,                // 删除编译后的所有的注释</span><br><span class="line">    &quot;noEmit&quot;: true,                        // 不生成输出文件</span><br><span class="line">    &quot;importHelpers&quot;: true,                 // 从 tslib 导入辅助工具函数</span><br><span class="line">    &quot;isolatedModules&quot;: true,               // 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.</span><br><span class="line"></span><br><span class="line">    /* 严格的类型检查选项 */</span><br><span class="line">    &quot;strict&quot;: true,                        // 启用所有严格类型检查选项</span><br><span class="line">    &quot;noImplicitAny&quot;: true,                 // 在表达式和声明上有隐含的 any类型时报错</span><br><span class="line">    &quot;strictNullChecks&quot;: true,              // 启用严格的 null 检查</span><br><span class="line">    &quot;noImplicitThis&quot;: true,                // 当 this 表达式值为 any 类型的时候，生成一个错误</span><br><span class="line">    &quot;alwaysStrict&quot;: true,                  // 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;</span><br><span class="line"></span><br><span class="line">    /* 额外的检查 */</span><br><span class="line">    &quot;noUnusedLocals&quot;: true,                // 有未使用的变量时，抛出错误</span><br><span class="line">    &quot;noUnusedParameters&quot;: true,            // 有未使用的参数时，抛出错误</span><br><span class="line">    &quot;noImplicitReturns&quot;: true,             // 并不是所有函数里的代码都有返回值时，抛出错误</span><br><span class="line">    &quot;noFallthroughCasesInSwitch&quot;: true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span><br><span class="line"></span><br><span class="line">    /* 模块解析选项 */</span><br><span class="line">    &quot;moduleResolution&quot;: &quot;node&quot;,            // 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)</span><br><span class="line">    &quot;baseUrl&quot;: &quot;./&quot;,                       // 用于解析非相对模块名称的基目录</span><br><span class="line">    &quot;paths&quot;: &#123;&#125;,                           // 模块名到基于 baseUrl 的路径映射的列表</span><br><span class="line">    &quot;rootDirs&quot;: [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容</span><br><span class="line">    &quot;typeRoots&quot;: [],                       // 包含类型声明的文件列表</span><br><span class="line">    &quot;types&quot;: [],                           // 需要包含的类型声明文件名列表</span><br><span class="line">    &quot;allowSyntheticDefaultImports&quot;: true,  // 允许从没有设置默认导出的模块中默认导入。</span><br><span class="line"></span><br><span class="line">    /* Source Map Options */</span><br><span class="line">    &quot;sourceRoot&quot;: &quot;./&quot;,                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span><br><span class="line">    &quot;mapRoot&quot;: &quot;./&quot;,                       // 指定调试器应该找到映射文件而不是生成文件的位置</span><br><span class="line">    &quot;inlineSourceMap&quot;: true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span><br><span class="line">    &quot;inlineSources&quot;: true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span><br><span class="line"></span><br><span class="line">    /* 其他选项 */</span><br><span class="line">    &quot;experimentalDecorators&quot;: true,        // 启用装饰器</span><br><span class="line">    &quot;emitDecoratorMetadata&quot;: true          // 为装饰器提供元数据的支持</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是-TypeScript&quot;&gt;&lt;a href=&quot;#什么是-TypeScript&quot; class=&quot;headerlink&quot; title=&quot;什么是 TypeScript&quot;&gt;&lt;/a&gt;什么是 TypeScript&lt;/h2&gt;&lt;p&gt;TypeScript 是一种由微软开发的自由</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>pnpm 使用</title>
    <link href="https://leejs.cn/undefined/"/>
    <id>https://leejs.cn/undefined/</id>
    <published>2022-08-16T09:06:15.000Z</published>
    <updated>2022-08-16T09:06:15.676Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>cli</title>
    <link href="https://leejs.cn/1224102205/"/>
    <id>https://leejs.cn/1224102205/</id>
    <published>2022-07-24T15:47:13.000Z</published>
    <updated>2022-08-02T02:40:50.228Z</updated>
    
    <content type="html"><![CDATA[<p>工具安装</p><ol><li><p>安装 docker</p><p>桌面版:  <a href="https://www.docker.com/">docker官网</a></p></li><li><p>安装 bsam cli</p><p>执行 <code>sudo pip3 install bce-sam-cli</code> 即可完成安装。</p><blockquote><p>遇到问题： <code>zsh: command not found: bsam</code> ;<br>原因是之前没有加 sudo</p></blockquote></li></ol><p>创建函数</p><ol><li><p>初始化项目： <code>bsam init --runtime nodejs12 --name lee-app</code></p></li><li><p>函数安装依赖：</p><ol><li><code>cd src</code> <code>npm install</code></li><li><code>bsam local install</code></li></ol></li><li><p>部署</p><ol><li><p>打包 <code>bsam package</code></p></li><li><p>发布 <code>bsam deploy</code></p><blockquote><p>发布之前要去配置 config， 把百度帐号的信息跟本地的cli绑定起来， <a href="https://console.bce.baidu.com/iam/?_=1658676423284#/iam/accesslist">创建&#x2F;获取 AK&#x2F;SK</a><br>执行 <code>bsam config</code><br>BCE Access Key ID:<br>BCE Secret Access Key:<br>BCE region (bj, gz, su):</p></blockquote></li><li><p>执行完deploy命令后， 可到页面函数列表里边去看函数是否发布成功， 如果成功了， 就会在函数列表里边有</p></li></ol></li><li><p>测试</p><ol><li>本地<ol><li>去src下边用 <a href="https://mochajs.org/">mocha</a> 进行测试， 执行 <code>npm run test</code></li></ol></li><li><a href="https://console.bce.baidu.com/cfc/#/cfc/functions">CFC 函数列表</a>可以进行测试<br>点击函数列表后面的测试操作就可以</li></ol></li><li><p>调用</p><ol><li>添加一个触发器</li><li>http的触发器可以直接在浏览器地址栏访问览器地址栏访问</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;工具安装&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装 docker&lt;/p&gt;
&lt;p&gt;桌面版:  &lt;a href=&quot;https://www.docker.com/&quot;&gt;docker官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装 bsam cli&lt;/p&gt;
&lt;p&gt;执行 &lt;code&gt;s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>fix</title>
    <link href="https://leejs.cn/1509574496/"/>
    <id>https://leejs.cn/1509574496/</id>
    <published>2022-07-15T15:13:23.000Z</published>
    <updated>2022-08-02T02:44:51.377Z</updated>
    
    <content type="html"><![CDATA[<p>如何在TypeScript中的<code>window</code>上显式设置新属性？</p><p>要保持动态，只需使用：</p><p>(<any>window).MyNamespace</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如何在TypeScript中的&lt;code&gt;window&lt;/code&gt;上显式设置新属性？&lt;/p&gt;
&lt;p&gt;要保持动态，只需使用：&lt;/p&gt;
&lt;p&gt;(&lt;any&gt;window).MyNamespace&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Rollup output</title>
    <link href="https://leejs.cn/3437106334/"/>
    <id>https://leejs.cn/3437106334/</id>
    <published>2022-07-15T02:39:12.000Z</published>
    <updated>2022-08-16T09:08:14.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Rollup-输出的不同格式js文件对比"><a href="#Rollup-输出的不同格式js文件对比" class="headerlink" title="Rollup 输出的不同格式js文件对比"></a>Rollup 输出的不同格式js文件对比</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">amd , cjs , esm , iife , umd , system</span><br></pre></td></tr></table></figure><h2 id="一、IIFE-自执行函数"><a href="#一、IIFE-自执行函数" class="headerlink" title="一、IIFE 自执行函数"></a>一、IIFE 自执行函数</h2><blockquote><p>IIFE 的全称是 “immediately invoked function expression”。</p></blockquote><h3 id="1-1-打包结果分析"><a href="#1-1-打包结果分析" class="headerlink" title="1.1 打包结果分析"></a>1.1 打包结果分析</h3><p>让我们先看看本 <code>demo</code> 的 <code>iife</code> 格式打出来的包长什么样。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7ff249b1c574c6f8fe3bf46c6ca7899~tplv-k3u1fbpfcp-zoom-1.image" alt="IIFE"></p><p>对上述代码做一些简化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Test</span> = (<span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, lodash</span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>; <span class="comment">// 自带严格模式，避免一些奇怪的兼容性问题</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 下面折行无用代码被 tree-shaking 掉了</span></span><br><span class="line"><span class="comment">   * const unusedVar = &#x27;May the 4th&#x27;</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> answer = <span class="number">42</span>; <span class="comment">// 业务中被单一引用的模块，被直接抹平了</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">printAnswer</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`the answer is <span class="subst">$&#123;answer&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(lodash.<span class="title function_">repeat</span>(<span class="string">&#x27;1&#x27;</span>, answer));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exports</span>.<span class="property">printAnswer</span> = printAnswer; <span class="comment">// 把要export的属性挂在到exports上</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">exports</span>;</span><br><span class="line"></span><br><span class="line">&#125;)(&#123;&#125;, $); <span class="comment">// exports是第一个入参，依赖的jquery是第二个入参</span></span><br></pre></td></tr></table></figure><p><code>IIFE</code> 是前端模块化早期的产物，它的核心思路是:</p><ol><li>构建一个匿名函数</li><li>立刻执行这个匿名函数，对外部的依赖通过入参的形式传入</li><li>返回该模块的输出</li></ol><h3 id="1-2-如何运行"><a href="#1-2-如何运行" class="headerlink" title="1.2 如何运行"></a>1.2 如何运行</h3><p><code>IIFE</code> 的运行其实很容易，如果它没有其他依赖，只需要去引入文件，然后在 <code>window</code> 上取相应的变量即可。<br>如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// jquery 就是典型的自执行函数模式，当你引入后，他就会挂在到 window.$ 上</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">$</span> <span class="comment">// 这样就能取到 jquery 了</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是如果你像本 <code>demo</code> 中那样依赖了其他的模块，那你就必须保证以下两点才能正常运行：</p><ol><li>此包所依赖的包，已在此包之前完成加载。</li><li>前置依赖的包，和 <code>IIFE</code> 只执行入参的变量命名是一致的。</li></ol><p>以本 <code>demo</code> 的 <code>IIFE</code> 构建结果为例：</p><ol><li>它前置依赖了 <code>lodash</code>，因此需要在它加载之前完成 <code>lodash</code> 的加载。</li><li>此 <code>IIFE</code> 的第二个入参是 <code>lodash</code>，作为前置条件，我们需要让 <code>window.lodash</code> 也指向 <code>lodash</code>。<br>因此，运行时，代码如下：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/lodash.js/4.17.21/lodash.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">window</span>.<span class="property">lodash</span> = <span class="variable language_">window</span>.<span class="property">_</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">Test</span>.<span class="title function_">printAnswer</span>();</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-优缺点"><a href="#1-3-优缺点" class="headerlink" title="1.3 优缺点"></a>1.3 优缺点</h3><ul><li>优点:<ol><li>通过闭包营造了一个“私有”命名空间，防止影响全局，并防止被从外部修改私有变量。</li><li>简单易懂</li><li>对代码体积的影响不大</li></ol></li><li>缺点：<ol><li>输出的变量可能影响全局变量；引入依赖包时依赖全局变量。</li><li>需要使用者自行维护 <code>script</code> 标签的加载顺序。</li></ol></li></ul><p>优点就不细说了，缺点详细解释一下。</p><p><strong>缺点一：输出的变量可能影响全局变量；引入依赖包时依赖全局变量</strong>。</p><p>前半句：<strong>输出的变量可能影响全局变量;</strong> 其实很好理解，以上面 <code>demo</code> 的输出为例： <code>window.Test</code> 就已经被影响了。<br>这种明显的副作用在程序中其实是有隐患的。</p><p>后半句：<strong>引入依赖包时依赖全局变量；</strong> 我们为了让 <code>demo</code> 正常运行，因此加了一行代码让 <code>window.lodash</code> 也指向 <code>lodash</code>，但它确实是太脆弱了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 没有这一行，demo就无法正常运行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">window</span>.<span class="property">lodash</span> = <span class="variable language_">window</span>.<span class="property">_</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你瞧，<code>IIFE</code> 的执行对环境的依赖是苛刻的，除非它完全不依赖外部包。（Jquery: 正是在下！）</p><p>虽然 <code>IIFE</code> 的缺点很多，但并不妨碍它在 <code>Jquery</code> 时代极大地推动了 <code>web</code> 开发的进程，因为它确实解决了 <code>js</code> 本身存在的很多问题。</p><p>那么？后续是否还有 <strong>更为优秀</strong> 的前端模块化方案问世呢？</p><p>当然有，往下看吧。</p><h2 id="二、CommonJS"><a href="#二、CommonJS" class="headerlink" title="二、CommonJS"></a>二、CommonJS</h2><h3 id="2-1-分析打包结果"><a href="#2-1-分析打包结果" class="headerlink" title="2.1 分析打包结果"></a>2.1 分析打包结果</h3><p>先看看 <code>CommonJs</code> 打包的结果:<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95627d69b68b4cc9a4387db25cdf954c~tplv-k3u1fbpfcp-zoom-1.image" alt="cjs"><br>简化一下，就长这样了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lodash = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> answer = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">printAnswer</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 打印</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`the answer is <span class="subst">$&#123;answer&#125;</span>`</span>);</span><br><span class="line">  <span class="comment">// 测试 lodash 的能力，打印42个1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(lodash.<span class="title function_">repeat</span>(<span class="string">&#x27;1&#x27;</span>, answer));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">printAnswer</span> = printAnswer;</span><br></pre></td></tr></table></figure><p>以上格式，就是 <code>CommonJS</code> 规范的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS 通过一个全局 require 方法进行模块的引入 </span></span><br><span class="line"><span class="keyword">var</span> lodash = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"><span class="comment">// CommonJS 进行模块内方法输出的方式</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">printAnswer</span> = printAnswer;</span><br><span class="line"><span class="comment">// 上面写法也等价于：</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">printAnswer</span> = printAnswer;</span><br><span class="line"><span class="comment">// 因为 exports 变量等价于 module.exports</span></span><br></pre></td></tr></table></figure><p>为了解决 <code>node.js</code> 在模块化上的缺失， <strong>2009年10月</strong> <code>CommonJS</code> 规范首次被提出。</p><p>注意这个关键词： <strong>node.js</strong>。</p><p>是的，<code>CommonJS</code> 并不是在浏览器环境运行的规范，而是在 <code>node.js</code> 环境下运行的。</p><h3 id="2-2-如何运行"><a href="#2-2-如何运行" class="headerlink" title="2.2 如何运行"></a>2.2 如何运行</h3><p>因此，我写了一个 <code>run.js</code> 脚本。<br>如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// run.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Test</span> = <span class="built_in">require</span>(<span class="string">&#x27;./bundle-by-lodash&#x27;</span>)</span><br><span class="line"><span class="title class_">Test</span>.<span class="title function_">printAnswer</span>()</span><br></pre></td></tr></table></figure><p>然后，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行脚本</span></span><br><span class="line">node ./out/cjs/run.js </span><br><span class="line"><span class="comment"># 输出1： </span></span><br><span class="line">&gt; the answer is 42</span><br><span class="line"><span class="comment"># 输出2： </span></span><br><span class="line">&gt; 111111111111111111111111111111111111111111</span><br></pre></td></tr></table></figure><p>可以看出，<code>node.js</code> 环境是天然支持 <code>CommonJS</code> 的。</p><h3 id="2-3-优缺点"><a href="#2-3-优缺点" class="headerlink" title="2.3 优缺点"></a>2.3 优缺点</h3><ul><li>优点</li></ul><ol><li>完善的模块化方案，完美解决了 <code>IIFE</code> 的各种缺点。</li></ol><ul><li>缺点</li></ul><ol><li>不支持浏览器环境，因为这种同步的引入方式可能导致浏览器假死。</li></ol><p>因此，前端界迫切地需要一种能在浏览器环境完美运行，完善的模块化方案。</p><h2 id="三、AMD-和-requirejs"><a href="#三、AMD-和-requirejs" class="headerlink" title="三、AMD 和 requirejs !"></a>三、AMD 和 requirejs !</h2><blockquote><p>AMD，YES!</p></blockquote><p>2011年， <code>amdjs-api</code> 在业内被正式提出。</p><h3 id="3-1-打包结果分析"><a href="#3-1-打包结果分析" class="headerlink" title="3.1 打包结果分析"></a>3.1 打包结果分析</h3><p>amd 格式的打包结果如下：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49b6e3794785493b97322cbbf74d8d19~tplv-k3u1fbpfcp-zoom-1.image" alt="amd,yes!"><br>可以看到，核心内容是一个全局方法 <code>define</code> 。</p><p><code>define</code> 方法有三个入参，分别是：</p><ul><li><code>&quot;Test&quot;</code>, 模块名称</li><li><code>[</code>exports<code>,</code>lodash<code>]</code> 分别表示模块的输出和外部依赖</li><li>一个以 <code>exports</code> 和 <code>lodash</code> 作为入参的方法，代表模块的实际内容。</li></ul><p>相比于 <code>IIFE</code> 和 <code>CommonJs</code> 而言，<code>AMD</code> 的写法无疑是复杂且别扭的。</p><p>但它却实实在在是解决了 <code>IIFE</code> 和 <code>CommonJS</code> 所面临的问题，对“浏览器里完善的JS模块方法” 提供了一套完善的方案。</p><p>尤其是 <code>amd</code> 标准的实现方案：<code>requirejs</code>。</p><p><code>requirejs</code> 所实现的 <code>AMD</code> 不仅解决了 <code>CommonJS</code> 在浏览器端的不适，通过异步的方式进行模块加载实现了不会导致假死的能力；更是完全弥补了 <code>IIFE</code> 存在的各类缺陷。</p><p><code>requirejs</code> 在使用时，一般情况下是以下四步法：</p><ol><li>在浏览器内引入 <code>require.js</code></li><li>通过 <code>requirejs.config</code> 方法定义全局的依赖</li><li>通过 <code>requirejs.define</code> 注册模块</li><li>通过 <code>requirejs()</code> 完成模块引入。</li></ol><h3 id="3-2-如何运行"><a href="#3-2-如何运行" class="headerlink" title="3.2 如何运行"></a>3.2 如何运行</h3><p>在 <code>out/amd</code> 打包目录下的 <code>index.html</code> 里，按如下方式编排代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 1. 引入 require.js --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./require.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 2. 定义全局依赖 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">requirejs</span>.<span class="title function_">config</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">paths</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&quot;lodash&quot;</span>: <span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/lodash.js/4.17.21/lodash.min&quot;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 3. 定义模块 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 4. 开销模块</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.requirejs(</span></span><br><span class="line"><span class="language-javascript">      [<span class="string">&#x27;Test&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span>   (<span class="params">test</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        test.<span class="title function_">printAnswer</span>()</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    );</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打开浏览器，我们可以正常地看到]控制台里被打印出来的 <code>42</code> 和 <code>42个1</code> 了。</p><h3 id="3-3-优缺点"><a href="#3-3-优缺点" class="headerlink" title="3.3 优缺点"></a>3.3 优缺点</h3><ul><li>优点</li></ul><ol><li>解决了 <code>CommonJS</code> 的缺点</li><li>解决了 <code>IIFE</code> 的缺点</li><li>一套完备的浏览器里 <code>js</code> 文件模块化方案</li></ol><ul><li>缺点</li></ul><ol><li>代码组织形式别扭，可读性差</li></ol><p>但好在我们拥有了各类打包工具，浏览器内的代码可读性再差也并不影响我们写出可读性ok的代码。</p><p>现在，我们拥有了<strong>面向 <code>node.js</code> 的 <code>CommonJs</code></strong> 和 <strong>面向浏览器的 <code>AMD</code></strong> 两套标准。</p><p>如果我希望我写出的代码能同时被<strong>浏览器</strong>和<strong>nodejs</strong>识别，我应该怎么做呢？</p><h2 id="四、UMD-伟大的整合"><a href="#四、UMD-伟大的整合" class="headerlink" title="四、UMD 伟大的整合"></a>四、UMD 伟大的整合</h2><blockquote><p>它没有做什么突破性的创造，但它是集大成者。</p></blockquote><h3 id="4-1-打包分析"><a href="#4-1-打包分析" class="headerlink" title="4.1 打包分析"></a>4.1 打包分析</h3><p><code>umd</code> 格式构建出来的代码的可读性进一步降低了。</p><p>我相信任何正常人看到下面这段代码都会感到一阵头大：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73f996a633424e23bffb9b592323bcb2~tplv-k3u1fbpfcp-zoom-1.image" alt="umd bundle"></p><p>是的，整整一大段代码，只是在处理兼容性问题，判断当前应该使用 <code>amd</code> 亦或是 <code>CommonJS</code>。</p><p>因此 <code>umd</code> 的代码和实现不在此进行过多分析，它所做的无非便是让同一段代码兼容了 <code>amd</code> 和 <code>CommonJS</code>。</p><h3 id="4-2-如何运行？"><a href="#4-2-如何运行？" class="headerlink" title="4.2 如何运行？"></a>4.2 如何运行？</h3><ul><li>在浏览器端，它的运行方式和 <code>amd</code> 完全一致，可以完全参考 <code>3.2</code> 节的 <code>demo</code>。</li><li>在node.js端，它则和 <code>CommonJS</code> 的运行方式完全一致，在此就不赘述了。</li></ul><h3 id="4-3-优缺点"><a href="#4-3-优缺点" class="headerlink" title="4.3 优缺点"></a>4.3 优缺点</h3><ul><li>优点<ol><li>抹平了一个包在 <code>AMD</code> 和 <code>CommonJS</code> 里的差异</li></ol></li><li>缺点<ol><li>会为了兼容产生大量不好理解的代码。（理解难度与包体积）</li></ol></li></ul><p>虽然在社区的不断努力下，<code>CommonJS</code> 、 <code>AMD</code> 、 <code>UMD</code> 都给业界交出了自己的答卷。</p><p>但很显然，它们都是不得已的选择。</p><p>浏览器应该有自己的加载标准。</p><p><code>ES6</code> 草案里，虽然描述了模块应该如何被加载，但它没有 “加载程序的规范”。</p><h2 id="五、SystemJs"><a href="#五、SystemJs" class="headerlink" title="五、SystemJs"></a>五、SystemJs</h2><p>因此 <code>WHATWG（Web Hypertext Application Technology Working Group）</code> 即网页超文本应用技术工作小组，提出了一套更有远见的规范：<a href="https://github.com/whatwg/loader">whatwg&#x2F;loader</a>。</p><p>也就是 <code>JavaScript Loader Standard</code> （JS 加载标准）。</p><blockquote><p>本规范描述了从 JavaScript 宿主环境中加载 JavaScript 模块的行为。它还提供了用于拦截模块加载过程和自定义加载行为的 api。</p></blockquote><p>基于此规范，<code>SystemJS</code> 诞生了。</p><p><code>SystemJS</code> 是目前 <code>whatwg/loader</code> 规范的最佳实践者。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19c610fcbb654337b5ff23f451e52ab5~tplv-k3u1fbpfcp-zoom-1.image" alt="systemjs bundle"></p><p>可以看出来，<code>system</code> 的打包结果其实和 <code>amd</code> 类似，提供了全局的对象 <code>System</code>，并提供了注册的方式和统一的写法。</p><p>就单纯的从打包结果上，其实看不出它相比对 <code>AMD + require.js</code> 有什么优势，<strong>难道只是写法上存在差异</strong>?</p><p>并不止于此！</p><p>相比于 <code>require.js</code>，<code>SystemJS</code> 的 <code>System.import(&#39;module/name&#39;)</code> 方式允许你更为“懒”地加载模块，这意味着你无需每次都加载一大堆的 <code>bundle</code>，用户只需要为他能看见的页面开销带宽。</p><p>另外，正因为 <code>SystemJS</code> 是面向 <code>whatwg/loader</code> 规范实践的，因此它是面向未来的模块依赖方式。</p><blockquote><p>抱歉，这个的 demo 我也没玩明白，就不误导大家了。希望有明白的大佬可以帮忙完善下demo。</p></blockquote><h2 id="六、ESM"><a href="#六、ESM" class="headerlink" title="六、ESM"></a>六、ESM</h2><blockquote><p>ECMAScript modules, 也叫 ESM, Javascript 模块化官方标准格式。</p></blockquote><h3 id="6-1-打包分析"><a href="#6-1-打包分析" class="headerlink" title="6.1 打包分析"></a>6.1 打包分析</h3><p>在 <code>ESM</code> 被提出来之前，JavaScript 一直没有真正意义上的模块（module）体系。</p><p>它的规范是通过 <code>export</code> 命令显式指定输出的代码，再通过 <code>import</code> 命令输入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="comment">// 导出命令</span></span><br><span class="line"><span class="keyword">export</span> &#123; zap &#125;;</span><br></pre></td></tr></table></figure><p>这也是我们日常开发中最为熟悉的写法。</p><p>因此，<code>esm</code> 格式打出来的包，可读性确实非常棒:<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71c81b32140d4853b83d8ab6ff3bb764~tplv-k3u1fbpfcp-zoom-1.image" alt="esm"></p><p>和阅读我们平时所写的业务代码完全没有区别。（<code>rollup</code> 依然没忘记做 <code>tree-shaking</code>）</p><h3 id="6-2-如何运行"><a href="#6-2-如何运行" class="headerlink" title="6.2 如何运行"></a>6.2 如何运行</h3><blockquote><p>祝贺你，是这个时代的前端开发。</p></blockquote><p>部分现代浏览器已经开始实装 <code>&lt;script type=&quot;module&gt;</code> 了，因此在浏览器上直接使用 <code>esm</code> 已成为现实。</p><p>但运行起来扔需要做一些前置步骤。</p><ol><li>在js-modules目录下起一个本地静态服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在js-modules目录下起一个本地静态服务</span></span><br><span class="line"><span class="built_in">cd</span> js-modules &amp;&amp; http-server</span><br></pre></td></tr></table></figure><ol><li>把 <code>esm/bundle.js</code> 文件的第一行修改为：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> repeat <span class="keyword">from</span> <span class="string">&#x27;../../node_modules/lodash-es/repeat.js&#x27;</span>;</span><br><span class="line"><span class="comment">// 因为默认的lodash并不是输出的 esm 格式，因此为了demo我们需要做一些特殊处理</span></span><br></pre></td></tr></table></figure><ol><li>在浏览器打开页面(假设端口是8080)，则打开：<a href="http://127.0.0.1:8080/out/esm/index.html">http://127.0.0.1:8080/out/esm/index.html</a></li></ol><p>这样一来，代码就能成功运行，控制台就可以成功打印 <code>42</code> 和 <code>42个1</code> 了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/598c41396bcf4fc0a31c3bb3df7398d3~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h2 id="总结：分别适合在什么场景使用？"><a href="#总结：分别适合在什么场景使用？" class="headerlink" title="总结：分别适合在什么场景使用？"></a>总结：分别适合在什么场景使用？</h2><ul><li><strong>IIFE:</strong> 适合部分场景作为SDK进行使用，尤其是需要把自己挂到 <code>window</code> 上的场景。</li><li><strong>CommonJS:</strong> 仅node.js使用的库。</li><li><strong>AMD:</strong> 只需要在浏览器端使用的场景。</li><li><strong>UMD:</strong> 既可能在浏览器端也可能在node.js里使用的场景。</li><li><strong>SystemJs:</strong> 和UMD类似。目前较出名的 <code>Angular</code> 用的就是它。</li><li><strong>ESM:</strong> 1. 还会被引用、二次编译的场景（如组件库等）；2.浏览器调试场景如 <code>vite.js</code>的开发时。3.对浏览器兼容性非常宽松的场景。</li></ul><p><a href="https://bbs.huaweicloud.com/blogs/324355">原文地址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Rollup-输出的不同格式js文件对比&quot;&gt;&lt;a href=&quot;#Rollup-输出的不同格式js文件对比&quot; class=&quot;headerlink&quot; title=&quot;Rollup 输出的不同格式js文件对比&quot;&gt;&lt;/a&gt;Rollup 输出的不同格式js文件对比&lt;/h2&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>life</title>
    <link href="https://leejs.cn/432881407/"/>
    <id>https://leejs.cn/432881407/</id>
    <published>2022-07-12T11:54:38.000Z</published>
    <updated>2022-08-02T02:40:28.708Z</updated>
    
    <content type="html"><![CDATA[<p>男人的成熟只需要一瞬间<br>—– 2022.7.10 看完《人生大事》</p><p>《人生大事》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;男人的成熟只需要一瞬间&lt;br&gt;—– 2022.7.10 看完《人生大事》&lt;/p&gt;
&lt;p&gt;《人生大事》&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>watch</title>
    <link href="https://leejs.cn/1342917158/"/>
    <id>https://leejs.cn/1342917158/</id>
    <published>2022-07-12T08:41:19.000Z</published>
    <updated>2022-08-02T02:44:56.848Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue3中-watch、watchEffect区别"><a href="#vue3中-watch、watchEffect区别" class="headerlink" title="vue3中 watch、watchEffect区别"></a><a href="https://segmentfault.com/a/1190000039916178">vue3中 watch、watchEffect区别</a></h3><p>1、watch是惰性执行，也就是只有监听的值发生变化的时候才会执行，但是watchEffect不同，每次代码加载watchEffect都会执行（忽略watch第三个参数的配置，如果修改配置项也可以实现立即执行）</p><p>2、watch需要传递监听的对象，watchEffect不需要</p><p>3、watch只能监听响应式数据：ref定义的属性和reactive定义的对象，如果直接监听reactive定义对象中的属性是不允许的，除非使用函数转换一下</p><p>4、watchEffect如果监听reactive定义的对象是不起作用的，只能监听对象中的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> countObj = <span class="title function_">reactive</span>(&#123;<span class="attr">count</span>: <span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 惰性，首次加载不执行</span></span><br><span class="line"><span class="title function_">watch</span>(count, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(newVal, oldVal)&#125; )</span><br><span class="line"><span class="comment">// watch 不能直接监听reactive里面的属性，只能监听ref、reactiveObject， function， array, 如果想监听reactive的某个属性，那么需要转换成函数</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> countObj.<span class="property">count</span>, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(oldVal, newVal)&#125;, &#123;&#125;)</span><br><span class="line">watch (countObj, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal, oldVal)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 监听多个值，前面是监听数据的数组，后面的参数是两个数组，前面数组是变化后监听对象值的数组，后面是变化前监听对象值的数组</span></span><br><span class="line">watch ([countObj, count], <span class="function">(<span class="params">[oneNewName, twoNewName], [oneOldName, twoOldName]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(oneNewName, oneOldName, twoNewName, twoOldName)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// watchEffect，和watch不一样，1、会立即执行，只要定义了就会执行。2、他只能监听某个值，监听对象不管用。3、不需要传递参数，会自动管制代码中的变量。4、没法获取newVal和oldVal</span></span><br><span class="line"><span class="keyword">const</span> watchEf = <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(countObj.<span class="property">count</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>参考</p><p><a href="https://segmentfault.com/a/1190000039916178">原文地址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;vue3中-watch、watchEffect区别&quot;&gt;&lt;a href=&quot;#vue3中-watch、watchEffect区别&quot; class=&quot;headerlink&quot; title=&quot;vue3中 watch、watchEffect区别&quot;&gt;&lt;/a&gt;&lt;a href=&quot;ht</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>d2</title>
    <link href="https://leejs.cn/2292182493/"/>
    <id>https://leejs.cn/2292182493/</id>
    <published>2022-07-11T06:16:56.000Z</published>
    <updated>2022-08-02T02:40:21.711Z</updated>
    
    <content type="html"><![CDATA[<p>业务系统和一般的应用有非常大的不同，一般的应用以提供给公司&#x2F;企业外的用户（消费者、普通玩家）提供服务，以完成2C的销售目的，而业务系统一般是2B或者自身消费的模式，完成的是自身业务的管理目标。所以，应用侧重服务，业务系统侧重管理。两者的不同，导致我们对项目开发中，代码的组织方式会有差别。2C应用要满足大量用户在使用时的舒适性，因此要提高项目中有关性能、用户体验、效果等方面的要求，以吸引用户付费。但业务系统则稍有差别，虽然系统的使用体验也很重要，但是不是占最重要的部分，业务系统最重要的部分，是必须保证用户看到的数据、流程等，必须与真实的业务、业务流程一致，否则会带来自身利益的损失，因此，在稳健性、安全性等方面要求更高。</p><h3 id="什么是业务模块？"><a href="#什么是业务模块？" class="headerlink" title="什么是业务模块？"></a>什么是业务模块？</h3><p>首先，什么是业务系统？在这之前，又必须回答什么是业务？业务（Business）专指商业活动，是实现企业生产到利益回收的一个环节，它的总和，构成了该企业盈利活动的整个流程。一般而言，我们所指的业务是企业商业活动中的一个部分，有的甚至小到一个环节，例如“结算”这个环节。业务系统则是辅助这些商业活动的计算机在线系统，以信息化的形式管理和决策企业的商业活动（理论上没有业务系统企业也能运转，但信息化社会没有业务系统会让企业寸步难行）。</p><p>大部分情况下，业务系统会尽可能多的囊括企业的业务环节，其目标是将企业的所有商业管理在线化，完成除必须在线下完成的实体业务之外的所有管理活动。而且，通过业务系统的数据积累，可以让企业基于已有数据进行深入决策，比只有线下管理的竞争对手高出多个维度。企业的管理者和员工使用业务系统，参与到企业的各个业务环节，参与形式各有不同，根据员工的角色来决定，比如有的员工不接触系统界面，只通过工卡完成各项流程的录入，有的员工则需要完成在线申请或审批，有的员工需要使用复杂的第三方工具完成系统录入等等。</p><p>业务模块，是以业务系统的建设者（领域专家、系统工程师等）的角度看待业务系统时，将庞大的业务系统，按照某个业务活动的边界，进行划分的某个单元。但是技术上，一般一个模块还是粒度比较大的单元。一般而言，业务模块囊括了系统关于该业务的所有内容，且和其他业务有明显的界限，理论上，可以在脱离了其他业务模块的情况下独立运行。</p><p>有了以上的认知，我们就知道，我们需要掌握企业在某个业务中，不同的参与者都是如何工作的。在该业务模块没有上线到业务系统中时，没人能明确的告诉你这个业务模块应该长什么样子，你需要走访业务的参与成员，了解他们实际是怎么工作的，然后再思考，如果要将这些工作迁移到线上，应该关注哪些方面，是用户的操作形式？是界面的友好风格？是信息的准确？但是应该注意一点，如果业务系统致使工作效率降低，那么说明设计该系统的人没有真正掌握企业商业活动的核心要点。动的核心要点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;业务系统和一般的应用有非常大的不同，一般的应用以提供给公司&amp;#x2F;企业外的用户（消费者、普通玩家）提供服务，以完成2C的销售目的，而业务系统一般是2B或者自身消费的模式，完成的是自身业务的管理目标。所以，应用侧重服务，业务系统侧重管理。两者的不同，导致我们对项目开发中，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>d1</title>
    <link href="https://leejs.cn/295091303/"/>
    <id>https://leejs.cn/295091303/</id>
    <published>2022-07-11T06:16:56.000Z</published>
    <updated>2022-08-02T02:40:21.713Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Domain-driven_design">Domain Driven Design</a>（DDD）是Eric Evans于2004在其同名著作里提出的概念，它指明了让软件设计满足理想需求模型的方向。但是建模、设计这种事本来就很抽象，读懂这样的大作也是需要消耗不少脑细胞。本文希望能尽量以简单加实例的方式介绍DDD里的一些常见概念。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是领域"><a href="#什么是领域" class="headerlink" title="什么是领域"></a>什么是领域</h3><p>《领域驱动设计》书里写的是：用户会把软件程序应用于某个主体区域，这个区域就是软件的领域。简单来说，就认为是公司的某块业务好了。如果领域比较大，可以将其拆分为多个子域（Subdomain），子域包含核心域（Core Domain）和支撑子域（Supporting Subdomain），核心域顾名思义，是最重要的子域，我们应该把关注点集中在它上面；其余的子域都是支撑子域。支撑子域里有一类特殊的用于解决通用问题的子域，称为通用子域（Generic Subdomain），例如用户和权限等。不过这些都是相对而言的，对于消费方来说，他的支撑子域有可能就是你的核心域。个别子域可能会有交集，称为共享内核（Shared Kernel），目的是减少重复，但是仍保持两个独立的上下文。由于不同子域的开发团队可能会同时修改共享内核，所以需要小心并注意沟通。</p><h3 id="要DDD做什么"><a href="#要DDD做什么" class="headerlink" title="要DDD做什么"></a>要DDD做什么</h3><p>DDD试图解决的是软件的复杂性问题，如果软件比较复杂，或者是预期会很复杂，或者是你不知道，那么都可以开始考虑DDD。否则，由于维系领域模型需要实现大量的封装和隔离，DDD会带来较大的成本。但是，DDD并不是一个笨重的开发过程，它能够和敏捷开发很好地结合起来，另外，DDD也倾向于“测试先行，逐步改进”。</p><h2 id="战略建模（Strategic-Modeling）"><a href="#战略建模（Strategic-Modeling）" class="headerlink" title="战略建模（Strategic Modeling）"></a>战略建模（Strategic Modeling）</h2><h3 id="通用语言（Ubiquitous-Language）"><a href="#通用语言（Ubiquitous-Language）" class="headerlink" title="通用语言（Ubiquitous Language）"></a>通用语言（Ubiquitous Language）</h3><p>其实写软件就像是翻译，把领域上的业务需求翻译成软件的各个功能。业务需求来自领域专家（Domain Expert），程序员们需要把领域专家的语言翻译成程序。如果程序员们翻译的时候使用的是自己的语言，而领域专家使用自己的行话，导致术语不一致，就会使得沟通不顺畅，难于消化知识。所以团队需要一种通用语言来进行沟通。这样的通用语言尽量以业务语言为主，而非技术语言。一开始的通用语言可能不尽完美，但它就像是代码一样，经常需要重构。例如：“创建一个订单”就比“插入一条订单数据”更容易让领域专家明白谈话的背景。</p><h3 id="限界上下文（Bounded-Context）"><a href="#限界上下文（Bounded-Context）" class="headerlink" title="限界上下文（Bounded Context）"></a>限界上下文（Bounded Context）</h3><p>通用语言里，同一个名词在不同的场景里不一定有相同的意思。比如用户，在推荐好友（可能关注年龄、性别、地域）或是浏览商品（可能关注喜好、历史购买记录）的时候有着不同的含义。所谓的不同的场景，其实就是不同的限界上下文。子域在限界上下文中完成开发。限界上下文主要用来封装通用语言和领域模型，显式地定义了领域模型的边界。不同的限界上下文，都会有一套自己的通用语言。通过这样的划分方式，来让每个限界上下文都尽量保持简单，也算是<a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">SRP</a>原则在不同粒度上的一个体现。如果不去做这样的划分，可能最终这个软件就会演变成一个<a href="https://en.wikipedia.org/wiki/Big_ball_of_mud">大泥球</a>，或者说是<a href="https://en.wikipedia.org/wiki/Monolithic_application">单块系统</a>。尽管如此，对于比较小的业务或项目来说，可能只会有一个限界上下文。现在流行的<a href="https://en.wikipedia.org/wiki/Microservices">微服务</a>，很大程度上就是按照限界上下文来划分服务。例如：商品上下文，订单上下文，物流上下文等。当然，如果子域很小，不见得非得微服务化。</p><p>不同的限界上下文之间，通过上下文映射图（Context Map）来进行交互。上下文映射图其实就是一个简单的框图，表示限界上下文之间的的映射关系。下面这张图就是一个简单的例子：<br><a href="http://qinghua.github.io/img/ddd-context-map.jpg"><img src="http://qinghua.github.io/img/ddd-context-map.jpg" alt="img"></a></p><p>U表示上游（Upstream）的被依赖方，D表示下游（Downstream）的依赖方。由于上下游的限界上下文模型不同，实现时，可以用RPC、Restful、消息机制等集成方式。另外，下游需要防腐层（Anticorruption Layer）来将上游的返回内容翻译为下游的领域模型。如果防腐层过多地使用了各种赋值，从而导致上下游的模型非常类似，那就需要看看是否下游过多地使用了上游的数据，从而导致自己的模型不清晰。</p><h2 id="战术建模（Tactical-Modeling）"><a href="#战术建模（Tactical-Modeling）" class="headerlink" title="战术建模（Tactical Modeling）"></a>战术建模（Tactical Modeling）</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><h4 id="实体（Entity）"><a href="#实体（Entity）" class="headerlink" title="实体（Entity）"></a>实体（Entity）</h4><p>所谓领域，反映到代码里就是模型。模型分为实体和值对象两种。实体是有标识（Identity）的，两个拥有相同属性的实体不是相等的，除非它们的标识相等；而不同实体的标识不能相等。例如：某人下了两个相同的订单，里面都购买了相同的商品。这两个订单就是有标识（订单号）的两个实体，虽然内容相同，但它们是两个不同的实体。常用的标识有自增数字、Guid、自然标识（如邮箱、身份证号）等。实体具有生命周期，它们的内容可能在这期间会发生改变，但是标识是永远不会变化的。实体作为领域模型的主体，需要拥有自己的方法，方法名来自于通用语言。通过这些方法来保证自己始终是一致的状态，而非被调用者set来set去。例如：<code>people.runTo(x, y)</code>，而非<code>people.setX(x);people.setY(y);</code></p><h4 id="值对象（Value-Object）"><a href="#值对象（Value-Object）" class="headerlink" title="值对象（Value Object）"></a>值对象（Value Object）</h4><p>实体用来表示领域中的一个东西，而值对象只用于描述或度量一个东西。值对象没有任何标识，只要两个值对象的属性相等，那么它们就是相等的。值对象是不可变的，如果要改变值对象的内容，那就重新创建一个值对象。值对象没有生命周期，因为它只是值而已。例如：金额（含数值和货币单位），颜色（含rgb值）等。因为不需要标识，所以它们其实比实体要简单许多。Java里的String类，就具有一个值对象的行为；C#的Struct其实就是一个值对象，不过一般还是会用Class来表示值对象。</p><p>不同的领域需求可能会催生不同的建模。例如：考虑一下演出的售票系统。如果需求是对号入座，那么座位就是实体，一旦某张演出票关联了某个座位，那么这个座位就再也不能被其它的演出票所关联了。如果需求是先到先坐，那么座位就是值对象，我们只关心卖了多少张演出票，不要超过座位上限即可，而并不用关心哪个座位被哪张票所关联了。</p><p>DDD的一个反模式就是拥有一堆<code>get</code>和<code>set</code>方法的贫血领域对象（Anemic Domain Object）。这样的对象只是一个数据持有器（data holder），而非我们想要的领域模型。值对象和实体一样，都需要有自己的方法。例如：金额值对象，有一个<code>Add</code>的方法，接受一个金额参数，返回一个新的值对象。</p><p>实体里可以包含值对象，值对象里也可以包含实体。</p><h4 id="领域服务（Domain-Service）"><a href="#领域服务（Domain-Service）" class="headerlink" title="领域服务（Domain Service）"></a>领域服务（Domain Service）</h4><p>有些操作不属于实体或者值对象，那就不用强塞给它们，创建领域服务来提供这些操作吧。留意通用语言，如果里面出现了名词，那一般就是实体或值对象；如果里面出现了动词，那通常就意味着领域服务。例如：支付，这是一个比较明显的业务操作。另外，如果有什么操作会让实体变得臃肿，也可以使用领域服务来解决。但是，不能把所有的东西都堆到领域服务里，过度使用领域服务会导致贫血对象的产生。</p><p>据Eric Evans所言，设计良好的领域服务具有以下三个特征：</p><ul><li>操作不是实体&#x2F;值对象的一个自然的部分</li><li>接口根据领域模型的其它元素定义</li><li>操作无状态</li></ul><p>还需要注意的是，不要把领域服务和应用服务混起来了。我们在领域服务里处理业务逻辑，而并不在应用服务里处理。应用服务是领域模型的直接客户，负责处理事务、安全等操作。</p><h4 id="领域事件（Domain-Event）"><a href="#领域事件（Domain-Event）" class="headerlink" title="领域事件（Domain Event）"></a>领域事件（Domain Event）</h4><p>《领域驱动设计》一书出版之后，DDD社区并没有停止前进的步伐。领域事件就是在那之后提出来的。领域事件是一个定义了领域专家所关心的事件的对象。当关心的状态由于模型行为而发生改变时，系统将发布领域事件。如果通用语言里出现了：“当……的时候，需要……”通常就意味着一个领域事件。例如：当订单完成支付时，商品需要出库。这里的订单完成支付就预示着一个OrderPaidEvent，里面持有着这个订单的标识。领域事件代表的是已经发生的事，所以命名上通常都使用过去时（如Paid）。对领域事件的处理就像是一个观察者模式，由领域事件的订阅方来决定。订阅方既可以是本地的限界上下文，也可以是外部的限界上下文。</p><h4 id="模块（Module）"><a href="#模块（Module）" class="headerlink" title="模块（Module）"></a>模块（Module）</h4><p>如果领域模型发展得比较快，很难整体来讨论它，因为太大了。我们可以将模块视为Java中的包或是C#中的命名空间。将模型组织到不同的模块中，可以有效地降低领域的复杂性。模块之间应该是低耦合的，而模块内部应该是高内聚的。模块的名称应该是通用语言的组成部分，反映出领域的深层知识。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="聚合（Aggregate）"><a href="#聚合（Aggregate）" class="headerlink" title="聚合（Aggregate）"></a>聚合（Aggregate）</h4><p>聚合就是一组应该呆在一起的对象，聚合根（Aggregate Root）就是聚合在一起的基础，并提供对这个聚合的操作。聚合除了聚合根以外，还有自己的边界（boundary），即聚合里有什么。例如：一个订单可以有多个订单明细，订单明细不可能脱离订单而存在，而订单也不可能没有订单明细。这种情况下，订单和订单明细就是一个聚合，而订单就是这个聚合的聚合根，订单和订单明细就处于这个聚合的边界之内。如果要变更订单明细，我们需要通过操作聚合根订单来实现，如<code>order.changeItemCount()</code>，而非订单明细自身。另外一个例子：一名客户可以有多个订单，订单不可能脱离客户而存在，而客户却可以没有订单。这种情况下，客户和订单就是不同的两个聚合，一个聚合以客户为聚合根，另一个聚合以订单为聚合根，引用客户的标识。客户里并不引用订单的标识，这样将关联减至最少有助于简化对象的关系网。但是带来的一个麻烦就是如果要查找某位客户的所有订单，就不得不从所有的订单里查，而不能从客户这个聚合里直接获得。最后再举一个多对多的例子：一个班级可以有多名学生，学生可以脱离这个班级而存在，而班级不能没有学生，学生也不能不在班级里。这种情况下，班级和学生也是不同的两个聚合，一个聚合以班级为聚合根，引用学生的标识；另一个聚合以学生为聚合根，引用班级的标识，将多对多转换成两个一对多。</p><p>聚合是持久化的一个单位，我们需要保证以聚合为单位的数据一致性。如果聚合太大，那就会导致并发修改困难，多人并发修改同一个聚合里的不同项目，结果就是只有第一个提交的人成功修改，其它人不得不重新刷新聚合才能再次修改。大聚合还会导致性能问题，因为操作实体时会将整个大聚合同时加载进内存。珍爱生命，拒绝大聚合。</p><p>聚合根必须是实体而非值对象，因为它需要整体持久化，所以一定会有标识。而聚合根里的各个元素，既可能是实体，也可能是值对象。例如：一个订单（聚合根）一般会有订单明细（实体）和送货地址（值对象）。这些元素里可以有对聚合根的引用，但是不能相互引用。任何对其它元素的操作都必须通过聚合根来进行。聚合根里的标识是全局的，聚合根里的实体标识是聚合里唯一的本地标识，因为对它的访问都是通过聚合根来操作的。聚合根拥有自己独立的生命周期，其实体的生命周期从属于其所属的聚合，值对象因为只是值而已，并没有生命周期。</p><h4 id="工厂（Factory）"><a href="#工厂（Factory）" class="headerlink" title="工厂（Factory）"></a>工厂（Factory）</h4><p>工厂是生命周期的开始阶段，它可以用来创建复杂的对象或是一整个聚合。复杂对象的创建是领域层的职责，但它并不属于被创建的对象自身的职责。实体和值对象的工厂不太一样，因为值对象是不可变的，所以需要工厂一次性创建一个完整的值对象出来。而实体工厂则可以选择创建之后再补充一些细节。</p><h4 id="资源库（Repository）"><a href="#资源库（Repository）" class="headerlink" title="资源库（Repository）"></a>资源库（Repository）</h4><p>资源库是生命周期的结束，它封装了基础设施以提供查询和持久化聚合的操作。这样能够让我们始终聚焦于模型，而把对象的存储和访问都委托给资源库来完成。以订单和订单明细的聚合为例，因为一定是通过订单这个聚合根来获取订单明细，所以可以有订单的资源库，但是不能有订单明细的资源库。也就是说，只有聚合才拥有资源库。需要注意的是，资源库并不是数据库的封装，而是领域层与基础设施之间的桥梁。DDD关心的是领域内的模型，而并非是数据库的操作。理想的资源库对客户（而非开发者）隐藏了内部的工作细节，委托基础设施层来干那些脏活，到关系型数据库、NOSQL、甚至内存里读取和存储数据。��和存储数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Domain-driven_design&quot;&gt;Domain Driven Design&lt;/a&gt;（DDD）是Eric Evans于2004在其同名著作里提出的概念，它指明了让软件设计满足理想需求模型的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>单一功能原则</title>
    <link href="https://leejs.cn/385579136/"/>
    <id>https://leejs.cn/385579136/</id>
    <published>2022-07-11T06:16:56.000Z</published>
    <updated>2022-08-15T10:52:50.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单一功能原则"><a href="#单一功能原则" class="headerlink" title="单一功能原则"></a>单一功能原则</h2><p>在<a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B">面向对象编程</a>领域中，<strong>单一功能原则</strong>（Single responsibility principle）规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。</p><p>这个术语由<a href="https://zh.wikipedia.org/w/index.php?title=%E7%BD%97%E4%BC%AF%E7%89%B9%C2%B7C%C2%B7%E9%A9%AC%E4%B8%81&action=edit&redlink=1">罗伯特·C·马丁</a>（Robert Cecil Martin）在他的《敏捷软件开发，原则，模式和实践》一书中的一篇名为〈面向对象设计原则〉的文章中给出。 [<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99#cite_note-1">1]</a> 马丁表述该原则是基于的《结构化分析和系统规格》[<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99#cite_note-2">2]</a>一书中的<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E8%81%9A%E5%8E%9F%E5%88%99">内聚原则</a>（Cohesion）上。</p><p>马丁把功能（职责）定义为：“改变的原因”，并且总结出一个类或者模块应该有且只有一个改变的原因。一个具体的例子就是，想象有一个用于编辑和打印报表的模块。这样的一个模块存在两个改变的原因。第一，报表的内容可以改变（编辑）。第二，报表的格式可以改变（打印）。这两方面的改变会因为完全不同的起因而发生：一个是本质的修改，一个是表面的修改。单一功能原则认为这两方面的问题事实上是两个分离的功能，因此他们应该分离在不同的类或者模块里。把有不同的改变原因的事物耦合在一起的设计是糟糕的。</p><p>保持一个类专注于单一功能点上的一个重要的原因是，它会使得类更加的健壮。继续上面的例子，如果有一个对于报表编辑流程的修改，那么将存在极大的危险性，因为假设这两个功能存在于同一个类中，修改报表的编辑流程会导致公共状态或者依赖关系的改变，打印功能的代码会因此不工作。</p><p>因此不工作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;单一功能原则&quot;&gt;&lt;a href=&quot;#单一功能原则&quot; class=&quot;headerlink&quot; title=&quot;单一功能原则&quot;&gt;&lt;/a&gt;单一功能原则&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%9</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>d4</title>
    <link href="https://leejs.cn/1643923690/"/>
    <id>https://leejs.cn/1643923690/</id>
    <published>2022-07-11T06:16:56.000Z</published>
    <updated>2022-08-02T02:40:21.713Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>领域驱动设计（domain-driven-design）是软件代码的结构及语言需要符合<strong>业务领域</strong>中的习惯用法</p><p>领域驱动设计可以将实现对应到持续进化的模型</p><p>领域驱动设计的前提是：</p><ul><li>把项目的主要重点放在核心领域（core domain）和领域逻辑</li><li>以领域中的模型为基础，进行复杂的设计</li><li>让技术人员以及领域专家合作，以迭代方式来完善特定领域问题的概念模型</li></ul><h5 id="上下文（Context）"><a href="#上下文（Context）" class="headerlink" title="上下文（Context）"></a><strong>上下文（Context）</strong></h5><p>情境，脉络，上下文。比如：电子商务系统。</p><h5 id="领域（Domain）"><a href="#领域（Domain）" class="headerlink" title="领域（Domain）"></a><strong>领域（Domain）</strong></h5><p>知识、影响、活动。客户使用软件要处理的问题种类即为软件的领域。</p><h5 id="模型（Model）"><a href="#模型（Model）" class="headerlink" title="模型（Model）"></a><strong>模型（Model）</strong></h5><p>一类描述域的不同方面并可用于解决相关问题的系统化的抽象</p><h5 id="通用语言（Ubiquitous-Language）"><a href="#通用语言（Ubiquitous-Language）" class="headerlink" title="通用语言（Ubiquitous Language）"></a><strong>通用语言（Ubiquitous Language）</strong></h5><p>一种领域专家使用，为了描述<a href="https://zh.wikipedia.org/wiki/%E9%A0%98%E5%9F%9F%E6%A8%A1%E5%9E%8B">域模型</a>而构造的语言，以减少沟通成本。</p><blockquote><p>理想情况下，只有一个统一的模型。 但是通常情况下都无法实现，因此在实践中通常分成多个模型。</p></blockquote><h5 id="限界上下文"><a href="#限界上下文" class="headerlink" title="限界上下文"></a><strong>限界上下文</strong></h5><p>任何大型项目都有多个模型。 然而，当基于不同模型的代码相结合，软件变得越来越多，不可靠，并且难以理解。 团队成员之间的交流变得越来越难。 模型的使用情境变得越来越不清晰。</p><p>因此：需要明确定义模型适用的上下文，并且根据团队组织，应用程序特定部分的使用情况以及代码库和数据库模式等物理表现明确设置边界。 保持模型在这些范围内严格一致，并且不被外部的问题影响。</p><h5 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a><strong>持续集成</strong></h5><p>当愈多人在相同的有限背景下工作时，模型就愈应该分裂。 团队越大，问题就越大，即使只有三四个人也会遇到严重的问题。 然而，将系统分解为更小的环境最终会失去一个有价值的集成和一致性。</p><p>因此：创建一个经常合并所有代码和其他实现工件的过程，用自动化测试快速标记碎片。通过持续地运用统一术语去夯实随着概念在不同人的头脑中的演变而逐渐形成对模型的共同观点。</p><h5 id="上下文关系"><a href="#上下文关系" class="headerlink" title="上下文关系"></a><strong>上下文关系</strong></h5><p>在缺乏全局认识的情况下，个别有界上下文会留下一些问题。 其他模型的背景可能仍然是模糊不清的。 其他团队的人不会意识到上下文的界限，并且会不知不觉地做出模糊边缘或使连接复杂化的变化。 当连接必须在不同的上下文之间进行时，它们往往会相互渗透。</p><p>因此：确定项目中正在使用的每个模型并定义其限界上下文。 这包括非面向对象子系统的隐式模型。 命名每个限界上下文，并将其命名为通用语言的一部分。 描述模型之间的关联点，确保任何用于共享交流的词语都有清晰明确的含义。 映射现有的情形。</p><h3 id="DDD领域驱动设计"><a href="#DDD领域驱动设计" class="headerlink" title="DDD领域驱动设计"></a>DDD领域驱动设计</h3><p>DDD（Domain-Driven Design）是帮助工程师，应对复杂业务系统设计和开发的思想武器和方法论。它指导了我们如何去和领域专家（熟悉业务的负责人）进行沟通，如何和他们找到一门共通语言，并基于该语言构建一套关于领域知识的图谱，并且是按照我们做系统设计的思路构建这套图谱。</p><p>建模是DDD的核心方法论，你需要去区分一个业务中的各个概念，为不同的概念建立不同类型的模型，并且找到它们之间的关系，通过建模，建立起我们编程的基础工程，后续所有的开发，都是在这些模型的基础上完成的。</p><blockquote><p>DDD是什么呢，DDD就是一个抽象的概念，DDD只在软件的架构设计阶段出现，它就是软件模块职责的划分</p></blockquote><h3 id="前端建模"><a href="#前端建模" class="headerlink" title="前端建模"></a>前端建模</h3><p>如果你使用vue组件，你会有一种为视图撰写模型的感觉，即ViewModel，它一定指向视图层（界面与用户交互）。但如我在多个场合提到的一样，vue组件是纯视图层的要件，如果你把有关业务的代码，写在vue组件中，你的代码将会是业务逻辑和视图逻辑混杂在一起的代码，你将无法在后来的维护中区分和把握到底要改业务逻辑还是改交互逻辑。实际上，这种操作是很多初级前端的惯用手法，因为大部分初级前端的编程习惯，都是随着意识流，按线性的思维写代码。而真正有经验的工程师，<em><strong>一定会在开始写代码之前先思考将要写作的代码，哪些是用于定义业务对象的，哪些是用于控制数据流的，哪些是为了完成界面渲染的，哪些是为了完成用户交互的等等。而这些思考，用一种思想来概括就是“分层思想”或者叫“Layered Architecture”。</strong></em>有了分层思想之后，开发者才不会认为抽象出业务模型是一件麻烦的事。<strong>分层开发，势在必行。</strong></p><p><strong>前端业务模型分为两类：一类是用于展示的模型，一类是用于数据提交（表单）的模型</strong>。后者在复杂度上会比前者高出一个等级。</p><blockquote><p>你可能会有疑问，不都是业务模型么，怎么还区分用于展示的和提交的？这可能是前端的特殊之处。后端应用，提交数据到数据库时，具有特定的约束，但是在输出到前端时却没有约束，因此，后端把大部分工作都投入在对数据库有写入动作的业务逻辑上，而丢给前端的数据，基本上不需要按照视图层的逻辑建模，只要一股脑把数据丢给前端即可。但是前端则不同，视图层具有复杂的交互逻辑，而这些交互逻辑依赖业务对象的特征，比如当这个业务对象处于什么样的一个状态时，才能点击某个按钮触发一个流转业务。因此，在展示&#x2F;交互这个层面，前端也需要建模。而提交数据就更不用说了，前端业务表单本身就是极为复杂的一种场景，不建立模型，根本无法对一个表单所要表达的业务对象完成清晰的创建或更新处理。</p></blockquote><h3 id="如何建模？"><a href="#如何建模？" class="headerlink" title="如何建模？"></a>如何建模？</h3><p>讲了那么多，那么到底应该如何实施前端建模呢？作为工程师，我们必须掌握一定的方法论，在理论上对我们的设计有一定的自信，才能确保我们的建模方式是对的。DDD为我们提供了建模的方法论，它提供了多个方案（Scheme），比如Entity, Value Object, Service, Modules, Aggregate, Factory, Repository等等，这些都是用来构造模型的方案。</p><p>这么多方案，实际上本质要解决两个问题：</p><ul><li>核心</li><li>边界</li></ul><p>我们要对业务进行建模，首先要抓住该业务的核心是什么。例如银行转账这个业务，它的核心是什么？是转账的金额，还是账号？它的边界又是什么？例如在转账这个业务中，我是否需要去把两边账号的消费记录拉出来看看？这些，都是我们要在建模的时候解决的问题。DDD告诉我们的方法论，是不要自己闭门造车，不要从开发人员的角度去设计一个系统，而是要找领域专家（对该业务的实操了如指掌的人）进行了解，建立自己对该业务的知识体系，并且和领域专家一起敲定有关这个业务各个细节的模型体系。</p><p>回到我们前端。我们实际上要找到这个业务中，存在那些对象，收集到所有对象之后，去一个一个的观察它们，如果它是业务逻辑中的关键对象，就要使用Entity的方案，对它进行细致的深入的描述，如果它是一个次要的或者说固定不变的或者一次性用完的对象，那么就可以使用Value Object的方案（也就是一个普通的对象）。有了这些对象之后，还需要有一个东西把它们聚合在一起，这时我们可以使用Aggreate的方案。在这些对象之间，还可能出现一些动作（动词，非静态的），此时我们可以使用Service和Factory的方案。我们还需要和服务端交互，拉取数据，填充到模型中，形成更丰富的细节，此时我们可以采用Repository的方案。</p><p>不要被这么多的名词吓到，本质上，放到前端的语境下，你就是需要去创建一些类，并处理好这些类在真实被使用时，它们之间的约束逻辑等等。</p><h3 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h3><p>通过分层架构（Layered Architecture），我们的代码被以不同层的不同理念进行组织。有关模型的东西，全都且只在模型层处理，我们不需要考虑外部将会如何使用它，理论上可以表述为“内存实体不需要考虑外层环境”的Clean Architecture，因此，我们只需要考虑，我们的建模是否符合真实业务的需要。这样的代码组织，将颠覆我们传统前端开发的一些经验，然而，这种颠覆显得没有什么惊喜，它看上去复杂度增加了，我们反问一句自己，我们是为了分层而分层，还是为了这样分层写出的代码，将有助于我们区分代码块功能，以利于我们的项目在两年三年的持续迭代维护中，有比较清晰的代码组织，从而让我们的维护更加有效？</p><h3 id="提炼关系表"><a href="#提炼关系表" class="headerlink" title="提炼关系表"></a>提炼关系表</h3><p>关系表是指在某个业务逻辑中，涉及多个业务对象，它们之间的存在不同情况下的不同联系，所最终组成的一个Object对象。</p><p>参考&#x2F;出处：</p><ol><li><a href="https://zh.wikipedia.org/wiki/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88">维基百科</a></li><li><a href="https://cloud.tencent.com/developer/article/1833272">如何打造更稳健的前端业务模块代码组织形式</a></li><li><a href="http://qinghua.github.io/ddd/">DDD</a></li></ol><p>hua.github.io&#x2F;ddd&#x2F;)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;相关概念&quot;&gt;&lt;a href=&quot;#相关概念&quot; class=&quot;headerlink&quot; title=&quot;相关概念&quot;&gt;&lt;/a&gt;相关概念&lt;/h3&gt;&lt;p&gt;领域驱动设计（domain-driven-design）是软件代码的结构及语言需要符合&lt;strong&gt;业务领域&lt;/stron</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>d0</title>
    <link href="https://leejs.cn/1720814833/"/>
    <id>https://leejs.cn/1720814833/</id>
    <published>2022-07-11T06:16:56.000Z</published>
    <updated>2022-08-02T02:40:21.713Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ol><li>前端项目日益复杂，功能多</li><li>业务逻辑，数据流，渲染，交互等等功能都是放在一块， 没有经过成熟的设计，杂乱无章，功能多了之后， 改一个小东西要把逻辑从头到尾都动一遍</li></ol><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ol><li>是一个抽象概念一种思想，只在项目设计阶段存在，就是去划分项目每个模块的职责</li></ol><h3 id="核心点"><a href="#核心点" class="headerlink" title="核心点"></a>核心点</h3><ol><li><p>建模，建模是整个ddd最重要的部分</p><blockquote><p>需要去区分一个业务中的各个概念，为不同的概念建立不同类型的模型，并且找到它们之间的关系，通过建模，建立起我们编程的基础工程，后续所有的开发，都是在这些模型的基础上完成的</p></blockquote></li></ol><h3 id="前端建模"><a href="#前端建模" class="headerlink" title="前端建模"></a>前端建模</h3><h4 id="核心思想：分层思想（Layered-Architecture）"><a href="#核心思想：分层思想（Layered-Architecture）" class="headerlink" title="核心思想：分层思想（Layered Architecture）"></a>核心思想：分层思想（Layered Architecture）</h4><p>​比如一些常见的想法：</p><ol><li>定义业务对象</li><li>控制数据流</li><li>界面渲染</li><li>用户交互��染</li><li>用户交互</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;前端项目日益复杂，功能多&lt;/li&gt;
&lt;li&gt;业务逻辑，数据流，渲染，交互等等功能都是放在一块， 没有经过成熟的设计，杂乱无章，功</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>d3</title>
    <link href="https://leejs.cn/4288208203/"/>
    <id>https://leejs.cn/4288208203/</id>
    <published>2022-07-11T06:16:56.000Z</published>
    <updated>2022-08-02T02:40:21.712Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何打造更稳健的前端业务模块代码组织形式"><a href="#如何打造更稳健的前端业务模块代码组织形式" class="headerlink" title="如何打造更稳健的前端业务模块代码组织形式"></a>如何打造更稳健的前端业务模块代码组织形式</h3><h3 id="文章出处：如何打造更稳健的前端业务模块代码组织形式"><a href="#文章出处：如何打造更稳健的前端业务模块代码组织形式" class="headerlink" title="文章出处：如何打造更稳健的前端业务模块代码组织形式"></a>文章出处：<a href="https://cloud.tencent.com/developer/article/1833272">如何打造更稳健的前端业务模块代码组织形式</a></h3><p>业务系统和一般的应用有非常大的不同，一般的应用以提供给公司&#x2F;企业外的用户（消费者、普通玩家）提供服务，以完成2C的销售目的，而业务系统一般是2B或者自身消费的模式，完成的是自身业务的管理目标。所以，应用侧重服务，业务系统侧重管理。两者的不同，导致我们对项目开发中，代码的组织方式会有差别。2C应用要满足大量用户在使用时的舒适性，因此要提高项目中有关性能、用户体验、效果等方面的要求，以吸引用户付费。但业务系统则稍有差别，虽然系统的使用体验也很重要，但是不是占最重要的部分，业务系统最重要的部分，是必须保证用户看到的数据、流程等，必须与真实的业务、业务流程一致，否则会带来自身利益的损失，因此，在稳健性、安全性等方面要求更高。</p><p>本文主要站在稳健性这个角度，试图阐述，在业务系统中，如何去安排或组织我们的（前端）代码，才能保证符合业务系统特征要求，且有利于长期可持续维护下去。由于谈系统过大，那么，本文只立足于一个业务模块来进行阐述。</p><h2 id="什么是业务模块？"><a href="#什么是业务模块？" class="headerlink" title="什么是业务模块？"></a>什么是业务模块？</h2><p>首先，什么是业务系统？在这之前，又必须回答什么是业务？业务（Business）专指商业活动，是实现企业生产到利益回收的一个环节，它的总和，构成了该企业盈利活动的整个流程。一般而言，我们所指的业务是企业商业活动中的一个部分，有的甚至小到一个环节，例如“结算”这个环节。业务系统则是辅助这些商业活动的计算机在线系统，以信息化的形式管理和决策企业的商业活动（理论上没有业务系统企业也能运转，但信息化社会没有业务系统会让企业寸步难行）。</p><p>大部分情况下，业务系统会尽可能多的囊括企业的业务环节，其目标是将企业的所有商业管理在线化，完成除必须在线下完成的实体业务之外的所有管理活动。而且，通过业务系统的数据积累，可以让企业基于已有数据进行深入决策，比只有线下管理的竞争对手高出多个维度。企业的管理者和员工使用业务系统，参与到企业的各个业务环节，参与形式各有不同，根据员工的角色来决定，比如有的员工不接触系统界面，只通过工卡完成各项流程的录入，有的员工则需要完成在线申请或审批，有的员工需要使用复杂的第三方工具完成系统录入等等。</p><p>业务模块，是以业务系统的建设者（领域专家、系统工程师等）的角度看待业务系统时，将庞大的业务系统，按照某个业务活动的边界，进行划分的某个单元。但是技术上，一般一个模块还是粒度比较大的单元。一般而言，业务模块囊括了系统关于该业务的所有内容，且和其他业务有明显的界限，理论上，可以在脱离了其他业务模块的情况下独立运行。</p><p>有了以上的认知，我们就知道，我们需要掌握企业在某个业务中，不同的参与者都是如何工作的。在该业务模块没有上线到业务系统中时，没人能明确的告诉你这个业务模块应该长什么样子，你需要走访业务的参与成员，了解他们实际是怎么工作的，然后再思考，如果要将这些工作迁移到线上，应该关注哪些方面，是用户的操作形式？是界面的友好风格？是信息的准确？但是应该注意一点，如果业务系统致使工作效率降低，那么说明设计该系统的人没有真正掌握企业商业活动的核心要点。</p><h2 id="DDD领域驱动设计"><a href="#DDD领域驱动设计" class="headerlink" title="DDD领域驱动设计"></a>DDD领域驱动设计</h2><p>DDD（Domain-Driven Design）是帮助工程师，应对复杂业务系统设计和开发的思想武器和方法论。它指导了我们如何去和领域专家（熟悉业务的负责人）进行沟通，如何和他们找到一门共通语言，并基于该语言构建一套关于领域知识的图谱，并且是按照我们做系统设计的思路构建这套图谱。</p><p>建模是DDD的核心方法论，你需要去区分一个业务中的各个概念，为不同的概念建立不同类型的模型，并且找到它们之间的关系，通过建模，建立起我们编程的基础工程，后续所有的开发，都是在这些模型的基础上完成的。</p><h2 id="前后端有别"><a href="#前后端有别" class="headerlink" title="前后端有别"></a>前后端有别</h2><p>自从前后端分离流行之后，DDD从某些技术层面上已经过时了。在传统系统开发中，系统大部分技术分布在后端即底层的基础建设上，用于<a href="https://cloud.tencent.com/product/xiaowei?from=10680">人机交互</a>的表现层所占份额很小，甚至只是后端系统中输出的那么末梢节点，是花费时间最少的部分。而现代系统开发前后端分离之后，一套系统需要依赖前后端两个团队完成，这导致原本可以在排除其他业务模块之后可以独立运行的业务模块，现在不可能存在，因为现在的架构模式，导致前端代码一次性囊括所有模块，而后端代码模块间也具有较高的耦合，已经不可能回到以前一个模块的代码可以完全自治的模式下了。</p><p>基于新的架构，前端和后端对待一个业务模块的态度有了很大的不同。对于后端而言，模块相对来说还比较清晰，沿用旧的设计思路，模块的各个功能也能保持一定的高内聚。甚至，由于将视图层丢出去，后端甚至不需要考虑视图层的问题，只需要保证业务的数据准确和业务的流转准确即可。对于视图层，后端只需要一股脑将每一个功能所需要的数据（VO）以JSON的形式提供Restful接口即可。</p><p>对于前端而言，其实经历了多个阶段。起初，前端作为页面的处理方，主要是提供js脚本，完成一些特定的后端无法完成的交互效果，例如一些建议的滑动下拉效果，一些悬浮效果等，由于这些效果需要js编写，而后端开发人员不熟悉，就不得不由前端人员完成。之后，随着ajax技术兴起，前端路由技术的出现，页面交互效果开始变得丰富，无刷新的效果成为web应用的主流形式，使得后端人员参与前端工作的可能性越来越低，前端逐渐从作为后端末梢环节的地位独立出来，通过ajax或其他http交互方式，完成与后端的分离。</p><p>现在，我们的核心问题是：前端怎么对待业务模块？</p><p>一种成熟的方式是将业务模块组件化，这里的组件是具有高内聚设计的业务组件。2017年我在Morningstar工作的时候，就已经在采用这种方案。和现在的react、vue组件不同，当时我们基于backbone作为框架开发组件，一个组件基于一些数据点完成一个具体的业务（基金数据分析）。这个组件在交付时，需要同时交付前端和后端代码到不同的平台中，作为对应产品的一部分。组件的形式是一种不错的形式，包括我后面要推荐的方案，本质上也是交付组件。</p><p>但是，组件不是唯一的业务模块交付形式。我在业务中还使用angularjs作为框架开发应用，一般情况下，我们会根据路由来划分模块，一个模块拥有相同的路由根地址，模块内的各个功能或处理节点都是该路由的子路由。但是，它的模板、controller、service、样式文件被放在不同的目录下管理，虽然在前端的运行效率变高了，但是对于业务模块而言却变得高耦合低内聚。可能angular的开发团队意识到这个问题，angular2之后，也就是新的基于typescript的angular框架不在以这种模式对待业务模块，新的框架下，一个module的相关代码被聚合在一起，并且形式上以组件的形式导出，可以说实现了业务的高内聚，业务间的低耦合。</p><h2 id="稳健的前端业务模块形式"><a href="#稳健的前端业务模块形式" class="headerlink" title="稳健的前端业务模块形式"></a>稳健的前端业务模块形式</h2><p>Angular的module组织形式，我认为是比较优秀的组织形式。除了代码本身的组织形式之外，我们还要去看业务模块在设计上的特征，是否有利于为我们提供一定的灵活性，可为将来实现长期可持续迭代更新创造条件。</p><p>那么，怎么样设计业务模块呢？我提倡一种分层的理念。将业务模块分为数据层、表现层和逻辑层。这也是angular尝试践行的，它首先提供了可在编译时实现抽象的模板；其次提供了依赖注入的服务层为模块提供视图之外的其他能力，我们可以在服务层做很多事情，比如建立模型，但是它没有提供这方面的指导（，所以在其他文章中，我们不认为angular是完整的MVC框架，因为它在M层无所作为）；最后，它内置了基于rxjs的流式数据（状态）管理，基于管道的处理方式，可以让交互和状态的流动可以自由组合，使用起来非常灵活。但是，正如我提到的，它没有提供有关分层理念的更深入的指导，它提供了各种工具，让你自己选择是否使用，以及如何使用这些工具来编写出可长期维护的代码，完全由你的设计或架构能力决定。</p><p>而我则希望提供用于编写出明确分层概念的范式，就像多年前我们写后端服务时，需要进行分层管理一样，我希望在前端践行DDD的理念。但同时又有别于后端的DDD，前端不需要永久存储数据，每一次刷新浏览器，我们都可以通过api接口拿到需要的数据，而且从api请求数据和从<a href="https://cloud.tencent.com/solution/database?from=10680">数据库</a>查询数据也有一定的差别。我们要构建具有DDD通行理念的，带有前端特色的建模体系。</p><h2 id="前端建模"><a href="#前端建模" class="headerlink" title="前端建模"></a>前端建模</h2><p>如果你使用vue组件，你会有一种为视图撰写模型的感觉，即ViewModel，它一定指向视图层（界面与用户交互）。但如我在多个场合提到的一样，vue组件是纯视图层的要件，如果你把有关业务的代码，写在vue组件中，你的代码将会是业务逻辑和视图逻辑混杂在一起的代码，你将无法在后来的维护中区分和把握到底要改业务逻辑还是改交互逻辑。实际上，这种操作是很多初级前端的惯用手法，因为大部分初级前端的编程习惯，都是随着意识流，按线性的思维写代码。而真正有经验的工程师，一定会在开始写代码之前先思考将要写作的代码，哪些是用于定义业务对象的，哪些是用于控制数据流的，哪些是为了完成界面渲染的，哪些是为了完成用户交互的等等。而这些思考，用一种思想来概括就是“分层思想”或者叫“Layered Architecture”。</p><p>有了分层思想之后，开发者才不会认为抽象出业务模型是一件麻烦的事。是的，很多初级前端觉得自己写的代码非常舒服，并且认为前端建模或把一些不属于视图层的东西提炼出去，是一件增加复杂度，使代码难读难维护的事。而实际上，由于他们只关注当下快速实现，而不用考虑可持续维护的问题，所以认为自己的实现是最优解。但往往有些系统，根本不应该让一个经验并不丰富且自以为是的初级前端来写，而应该由经验丰富的工程师来完成。两者之间的差距，会使得系统后续的发展呈现截然不同的效果。但讽刺的是，经验不足的开发者进入这样的项目组之后，反而认为自己写的粗糙的代码应该推广开替代已经成熟的体系，因为他觉得自己的代码可以一口气读完，是好代码。然而，现实是，当他们2个月之后回头看自己的代码，发现根本无法改动，或者要实现新功能非常困难，因为之前写的代码是线性的过程式代码，稍有调整，就需要把这条线重新切断再想办法连起来。所有的一切，都会在实践中被检验出来。分层开发，势在必行。</p><p>前端业务模型分为两类：一类是用于展示的模型，一类是用于数据提交（表单）的模型。后者在复杂度上会比前者高出一个等级。</p><p>你可能会有疑问，不都是业务模型么，怎么还区分用于展示的和提交的？这可能是前端的特殊之处。后端应用，提交数据到数据库时，具有特定的约束，但是在输出到前端时却没有约束，因此，后端把大部分工作都投入在对数据库有写入动作的业务逻辑上，而丢给前端的数据，基本上不需要按照视图层的逻辑建模，只要一股脑把数据丢给前端即可。但是前端则不同，视图层具有复杂的交互逻辑，而这些交互逻辑依赖业务对象的特征，比如当这个业务对象处于什么样的一个状态时，才能点击某个按钮触发一个流转业务。因此，在展示&#x2F;交互这个层面，前端也需要建模。而提交数据就更不用说了，前端业务表单本身就是极为复杂的一种场景，不建立模型，根本无法对一个表单所要表达的业务对象完成清晰的创建或更新处理。</p><h2 id="如何建模？"><a href="#如何建模？" class="headerlink" title="如何建模？"></a>如何建模？</h2><p>讲了那么多，那么到底应该如何实施前端建模呢？作为工程师，我们必须掌握一定的方法论，在理论上对我们的设计有一定的自信，才能确保我们的建模方式是对的。DDD为我们提供了建模的方法论，它提供了多个方案（Scheme），比如Entity, Value Object, Service, Modules, Aggregate, Factory, Repository等等，这些都是用来构造模型的方案。</p><p>这么多方案，实际上本质要解决两个问题：</p><ul><li>核心</li><li>边界</li></ul><p>我们要对业务进行建模，首先要抓住该业务的核心是什么。例如银行转账这个业务，它的核心是什么？是转账的金额，还是账号？它的边界又是什么？例如在转账这个业务中，我是否需要去把两边账号的消费记录拉出来看看？这些，都是我们要在建模的时候解决的问题。DDD告诉我们的方法论，是不要自己闭门造车，不要从开发人员的角度去设计一个系统，而是要找领域专家（对该业务的实操了如指掌的人）进行了解，建立自己对该业务的知识体系，并且和领域专家一起敲定有关这个业务各个细节的模型体系。</p><p>回到我们前端。我们实际上要找到这个业务中，存在那些对象，收集到所有对象之后，去一个一个的观察它们，如果它是业务逻辑中的关键对象，就要使用Entity的方案，对它进行细致的深入的描述，如果它是一个次要的或者说固定不变的或者一次性用完的对象，那么就可以使用Value Object的方案（也就是一个普通的对象）。有了这些对象之后，还需要有一个东西把它们聚合在一起，这时我们可以使用Aggreate的方案。在这些对象之间，还可能出现一些动作（动词，非静态的），此时我们可以使用Service和Factory的方案。我们还需要和服务端交互，拉取数据，填充到模型中，形成更丰富的细节，此时我们可以采用Repository的方案。</p><p>不要被这么多的名词吓到，本质上，放到前端的语境下，你就是需要去创建一些类，并处理好这些类在真实被使用时，它们之间的约束逻辑等等。</p><h2 id="建模实践"><a href="#建模实践" class="headerlink" title="建模实践"></a>建模实践</h2><p>既然本质上 是去建立类，那么接下来我们就来看一看如何利用前端的工具js来完成模型的建立。在这之前，我们不得不承认，js不是一门能像java一样写出健壮的系统的语言。它有自己的语法特征，而这些语法特征导致我们在完成建模时，需要采取一些非常手段。比如我，就是利用class的static属性来完成模型上元数据的定义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">default</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">static</span> type = <span class="string">&#x27;numeric&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Amount</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">default</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">static</span> type = <span class="string">&#x27;number&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransferModel</span> &#123;</span><br><span class="line">  id = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">from</span> = <span class="title class_">Account</span></span><br><span class="line">  <span class="keyword">static</span> to = <span class="title class_">Account</span></span><br><span class="line">  <span class="keyword">static</span> amount = <span class="title class_">Amount</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码仅仅是我用来说明建模的一个思路，我没有在生产环境用过这样的代码。首先，我们定义了两个类：Account账户, Amount金额。这两个类具有类似的结构，因为它们是用来描述这个对象应该具备的一些特征，比如Account这个对象应该是一个数字字符串，而Amount应该是一个数字。其次，Transfer是一个包含了三个字段的对象，每个字段都对应一个建好模的对象。我们在使用时，主要是去使用Transfer实例化出来的对象，这个对象应该具备3个字段，且每个字段应该具备哪些规则（约束）都是提前规定好的。</p><p>上面是我们对转账这个业务中的对象进行建模。实际上，我们并没有完成转账这个业务，我们需要把数据发送给api，以真正完成转账。所以，我们要在对象之外，建立一个服务，用于完成这个业务。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TransferService</span> &#123;</span><br><span class="line">  <span class="title function_">submitTransfer</span>(<span class="params">id, data</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getTransfer</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也非常容易理解，我们通过两个方法来完成和API接口的交互，从而使得这个业务完成前后端对接，使它在整个系统层面生效。同时，我们还提供了一个接口getTransfer，它将用于在用户查看自己的转账记录的时候，还原数据。</p><p>但上面这些还不够，我们需要有一个东西，把它们串联起来，它们才能真正工作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TransferController</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> model = <span class="title class_">TransferModel</span></span><br><span class="line">  <span class="keyword">static</span> service = <span class="title class_">TransferService</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">init</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">service</span>.<span class="title function_">getTransfer</span>(id)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">model</span>.<span class="title function_">setData</span>(id, data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">submit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="variable language_">this</span>.<span class="property">model</span>.<span class="title function_">getData</span>()</span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">service</span>.<span class="title function_">submitTransfer</span>(<span class="variable language_">this</span>.<span class="property">model</span>.<span class="property">id</span>, data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就模型和服务串起来了。我们可以从这三块代码中，大致看出关于转账这个业务的实际逻辑。但是，我们忽略了另外一个东西，就是我们现在还没有界面，我们还没有提供给用户怎么进行操作后完成这个转账。因此，我们还需要补全这个部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TransferView</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  controller = <span class="keyword">new</span> <span class="title class_">TransferController</span>()</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; id &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">controller</span>.<span class="title function_">init</span>(id)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.controller.submit()&#125;&gt;transfer<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就将视图和模型最终串了起来。也实现了我们最初关于分层的想法。通过分层架构（Layered Architecture），我们的代码被以不同层的不同理念进行组织。有关模型的东西，全都且只在模型层处理，我们不需要考虑外部将会如何使用它，理论上可以表述为“内存实体不需要考虑外层环境”的Clean Architecture，因此，我们只需要考虑，我们的建模是否符合真实业务的需要。这样的代码组织，将颠覆我们传统前端开发的一些经验，然而，这种颠覆显得没有什么惊喜，它看上去复杂度增加了，我们反问一句自己，我们是为了分层而分层，还是为了这样分层写出的代码，将有助于我们区分代码块功能，以利于我们的项目在两年三年的持续迭代维护中，有比较清晰的代码组织，从而让我们的维护更加有效？</p><h2 id="提炼关系表"><a href="#提炼关系表" class="headerlink" title="提炼关系表"></a>提炼关系表</h2><p>关系表是指在某个业务逻辑中，涉及多个业务对象，它们之间的存在不同情况下的不同联系，所最终组成的一个Object对象。这样说过于抽象，我们用实际的案例来说明问题。</p><p>在上述转账系统中，存在着这样的内在逻辑，当用户X信用等级为1时，他不能向客户类型为A类的用户转账，因为可能存在信用风险。此时，实际上，我们要构建一张用于表达信用、客户类型和转账权限之间的关系表，在我的设计里，转账权限是结果，因此，它是值，而信用、客户类型是条件，因此，产生的表可以按如下写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="number">1</span>: &#123;</span><br><span class="line">    <span class="attr">A</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">B</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">2</span>: &#123;</span><br><span class="line">    <span class="attr">A</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">B</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的关系表表示了如下关系：信用为1级的用户，不能向A类用户转账，但可以向B类用户转账；信用为2级的用户，可以向A和B类用户转账。</p><p>一般来讲，关系表会非常繁琐，因为它要枚举大部分可能性（一个技巧是，不需要列出false的情况，只需要列出true的情况的关系即可），所以感觉节点会很多。但是，它的用处却非常大，你可以使用它避免一大堆的if…else。比如上面这个场景。我们有两种选择，一种是将这个关系写在模型中，另外一种是写在控制器中。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Credit</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">default</span> = <span class="number">1</span></span><br><span class="line">  <span class="keyword">static</span> type = <span class="title function_">enumerate</span>([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stratum</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">default</span> = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">  <span class="keyword">static</span> type = <span class="title function_">enumerate</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccountModel</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> credit = <span class="title class_">Credit</span></span><br><span class="line">  <span class="keyword">static</span> stratum = <span class="title class_">Stratum</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">canTransfer</span>(<span class="params">toAccount</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">credit</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&#x27;B&#x27;</span>].<span class="title function_">includes</span>(toAccount.<span class="property">stratum</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransferModel</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">from</span> = <span class="title class_">AccountModel</span></span><br><span class="line">  <span class="keyword">static</span> to = <span class="title class_">AccountModel</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">transfer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">from</span>.<span class="title function_">canTrasfer</span>(<span class="variable language_">this</span>.<span class="property">to</span>)) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看，我们在canTransfer方法中通过if…else来进行判断，看上去也是可以的，但是，这里有一个问题是，这段代码无法让我们洞悉业务的详细细节，它像是一段无法被看透的程序，而不是一段业务的描述。接下来我们用关系表来改造它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">canTransfer</span>(<span class="params">toAccount</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> relationship[<span class="variable language_">this</span>.<span class="property">credit</span>]?.[toAccount.<span class="property">stratum</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多么简单的一句话，而这里的relationship就是我们上面我们列举的关系表。关系表是静态的，不仅程序的运行性能会更好，同时，我们阅读关系表（需要增加对键的含义注释）来掌握业务中都有哪些情况，我们熟知了业务，才能在将来的调整时，将关系表中的true改为false即可。</p><h3 id="基于React的DDD框架"><a href="#基于React的DDD框架" class="headerlink" title="基于React的DDD框架"></a>基于React的DDD框架</h3><p>但以上仅仅是一个思路，要让它工作起来，还有非常多的工作要做。幸运的是，我已经帮你做了这项工作，我发布了开源的 tyshemo（<a href="https://github.com/tangshuang/tyshemo%EF%BC%89%E6%A8%A1%E5%BC%8F%E5%BA%93%E5%92%8C">https://github.com/tangshuang/tyshemo）模式库和</a> nautil（<a href="https://nautil.js.org/%EF%BC%89%E6%A1%86%E6%9E%B6%EF%BC%8Ctyshemo">https://nautil.js.org/）框架，tyshemo</a> 帮助你完成核心的模型层，nautil 则是基于 tyshemo 提供了完整的 service 和 controller 建模，以及提炼了业务交互的相关编程范式，你可以使用它完成DDD思路的整个链路的实践，同时，又不失去基于react进行开发的乐趣。你可以在这里（<a href="https://github.com/tangshuang/nautil-cli/tree/master/lib/templates/src/app/modules/home%EF%BC%89%E7%9C%8B%E5%88%B0%E4%B8%80%E4%BB%BD%E5%AE%8C%E6%95%B4%E7%9A%84%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E3%80%82">https://github.com/tangshuang/nautil-cli/tree/master/lib/templates/src/app/modules/home）看到一份完整的代码示例。</a></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-2226939/rjlywuaz7f.png?imageView2/2/w/1620" alt="img"></p><p>面对一个业务模块，我们会把和它相关的所有代码文件放在一个目录下进行管理（除一些需要公用的资源除外）。我们首先要对业务进行建模，如果是简单的一两个模型，我们只需要建立一个.model.js来完成，而如果是一个比较复杂的体系，我们可以创建一个.model文件夹，放置所有相关模型文件，比如上图示例中，我们可以创建home.model文件夹来管理。建模的同时，我们就会在必要的时候，为模块创建service，规则也是一样。完成建模之后，我们需要撰写控制器controller，在一个controller内部，你需要引入model和service，nautil的Controller会自动帮你实例化它们，并且做好观察。</p><p>除了把model和service串联起来，controller还有什么用呢？你还可以在controller内建立基于模型的交互，我称之为“无视图的交互模型”。因为对于前端应用来讲，业务除了数据逻辑之外，往往还有交互逻辑，比如“点击这个按钮之后，弹出一个对话框询问用户是否确认转账，如果用户点确认，那么执行转账”，这段交互描述里面，没有确切的告诉你弹出框应该长什么样子，用什么颜色，字体多大等等，它只描述了有关业务的交互部分，这个部分与布局和样式无关，是纯粹的描述和业务相关的交互效果。得益于react的抽象能力，我们可以直接在controller中，使用jsx完成纯交互的部分，并以组件的形式作为controller的接口提供给外部使用。这样，有关业务的一切逻辑，我们就通过controller串联model和service，在一个模块内，脱离布局，完成了。完成controller之后，我们才开始布局开发，布局开发也就是react组件的日常开发，由于我们在controller中导出了交互组件，而这些交互组件已经涵盖了大部分业务逻辑，所以，我们可以做到布局组件和业务无关，是纯粹的布局和样式。</p><p>基于这样的设计，我们在后续的开发中，还可以加入一些特殊的逻辑，例如，我们一个业务模块，可能在PC端也可能在手机端使用，那么，此时，我们只需要重写布局组件，而无需再写业务逻辑相关的代码。更多的思想，需要你更深入的了解nautil，以及尝试使用它作为主力开发工具之后，慢慢体会。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文虽然标题是谈如何打造前端的模块代码，但本质上，详细的阐述了我关于DDD的思想的理解，以及自己在DDD的思想基础上构建的一套代码管理范式，并且以前端框架的形式组织起来。我相信，如果你也是在编写复杂的业务系统，并且遇到一些瓶颈的话，一定能从本文中有所收获。当然，由于前端的特殊性，我们不能照搬DDD，需要有所变通。我写框架，也只是一种探索，并不代表它是唯一的一种形态。随着产业互联网时代的到来，前端逐渐从大众型交互应用，转向企业型业务系统应用，这是大势所趋，也是所谓“互联网下半场”前端立足之本。本文抛砖引玉，相信站在前端的角度去看待复杂业务（专有领域）的研究会越来越多。究会越来越多。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;如何打造更稳健的前端业务模块代码组织形式&quot;&gt;&lt;a href=&quot;#如何打造更稳健的前端业务模块代码组织形式&quot; class=&quot;headerlink&quot; title=&quot;如何打造更稳健的前端业务模块代码组织形式&quot;&gt;&lt;/a&gt;如何打造更稳健的前端业务模块代码组织形式&lt;/h3&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>学习计划</title>
    <link href="https://leejs.cn/1579271507/"/>
    <id>https://leejs.cn/1579271507/</id>
    <published>2021-08-22T11:46:41.000Z</published>
    <updated>2022-08-02T02:39:10.647Z</updated>
    
    <content type="html"><![CDATA[<p>xie</p><span id="more"></span><ul><li><p><input disabled="" type="checkbox"> 8.22</p><ul><li><input disabled="" type="checkbox"> JS第七章</li><li><input disabled="" type="checkbox"> Vue（一期）：第十五章项目实战-页面骨架开发（60min）</li></ul></li><li><p><input disabled="" type="checkbox"> 8.23</p><ul><li><input disabled="" type="checkbox"> 第十六章 -head组件开发 </li><li><input disabled="" type="checkbox"> 1-2（20min） 3-8（70min） 9-16（90min）</li></ul></li><li><p><input disabled="" type="checkbox"> 8.24</p><ul><li><input disabled="" type="checkbox"> 第十七章 -goods商品列表开发 1-5（50min） 6-8（40min） 9-14（70min）15-17（35min）</li></ul></li><li><p><input disabled="" type="checkbox"> 8.25</p><ul><li><input disabled="" type="checkbox"> 第十七章 -goods商品列表开发 18-20（30min） 21-24（50min）</li><li><input disabled="" type="checkbox"> 第十八章 -food商品详情页实现 1-5（60min） 6-11（70min）</li></ul></li><li><p><input disabled="" type="checkbox"> 8.26</p><ul><li><input disabled="" type="checkbox"> 第十八章 -food商品详情页实现 12-17（50min） 12-17（50min）</li><li><input disabled="" type="checkbox"> 第十九章 -ratings评价列表页实现 1-3（35min） 4-6（40min）</li></ul></li><li><p><input disabled="" type="checkbox"> 8.27</p><ul><li><input disabled="" type="checkbox"> 第二十章 -seller商家详情页实现 1-4（35min） 5-7（30min） 8-11（45min）</li><li><input disabled="" type="checkbox"> 第二十一章 项目编译打包（15min）</li><li><input disabled="" type="checkbox"> 第二十二章 课程总结（5min）</li><li><input disabled="" type="checkbox"> 第二十三章 Vue.js1.0向2.0升级（30min）</li><li><input disabled="" type="checkbox"> 第一章 课程导学（10min）</li><li><input disabled="" type="checkbox"> 第二章 项目准备工作（25min）</li></ul></li><li><p><input disabled="" type="checkbox"> 8.28</p><ul><li><input disabled="" type="checkbox"> 第三章 头部组件开发（30min）</li><li><input disabled="" type="checkbox"> 第四章 Tab组件开发（30min）</li><li><input disabled="" type="checkbox"> 第五章 项目准备工作 1-3（25min） 4-5（35min） 6-7（40min）</li></ul></li><li><p><input disabled="" type="checkbox"> 8.29</p><ul><li><input disabled="" type="checkbox"> 第五章 项目准备工作 8-9（30min）</li><li><input disabled="" type="checkbox"> 第六章 商品详情页开发（50min）</li><li><input disabled="" type="checkbox"> 第七章 评价和商家页面开发（45min）</li><li><input disabled="" type="checkbox"> 第八章 create-api原理分析（40min）</li></ul></li><li><p><input disabled="" type="checkbox"> 8.30</p><ul><li><input disabled="" type="checkbox"> 第九章 打包构建和项目部署（55min）</li><li><input disabled="" type="checkbox"> 第十章 课程总结（10min）</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;xie&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>798</title>
    <link href="https://leejs.cn/4175634211/"/>
    <id>https://leejs.cn/4175634211/</id>
    <published>2021-08-17T07:30:51.000Z</published>
    <updated>2022-08-02T02:39:10.647Z</updated>
    
    <content type="html"><![CDATA[<p>798</p><span id="more"></span><p><img src="/images/D850/play_798_2021/play_79801.jpg" alt="play_79801"><br><img src="/images/D850/play_798_2021/play_79802.jpg" alt="play_79802"><br><img src="/images/D850/play_798_2021/play_79803.jpg" alt="play_79803"><br><img src="/images/D850/play_798_2021/play_79804.jpg" alt="play_79804"><br><img src="/images/D850/play_798_2021/play_79805.jpg" alt="play_79805"><br><img src="/images/D850/play_798_2021/play_79806.jpg" alt="play_79806"><br><img src="/images/D850/play_798_2021/play_79807.jpg" alt="play_79807"><br><img src="/images/D850/play_798_2021/play_79808.jpg" alt="play_79808"><br><img src="/images/D850/play_798_2021/play_79809.jpg" alt="play_79809"><br><img src="/images/D850/play_798_2021/play_79810.jpg" alt="play_79810"><br><img src="/images/D850/play_798_2021/play_79811.jpg" alt="play_79811"><br><img src="/images/D850/play_798_2021/play_79812.jpg" alt="play_79812"><br><img src="/images/D850/play_798_2021/play_79813.jpg" alt="play_79813"><br><img src="/images/D850/play_798_2021/play_79814.jpg" alt="play_79814"><br><img src="/images/D850/play_798_2021/play_79815.jpg" alt="play_79815"><br><img src="/images/D850/play_798_2021/play_79816.jpg" alt="play_79816"><br><img src="/images/D850/play_798_2021/play_79817.jpg" alt="play_79817"><br><img src="/images/D850/play_798_2021/play_79818.jpg" alt="play_79818"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;798&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>iig</title>
    <link href="https://leejs.cn/3752725928/"/>
    <id>https://leejs.cn/3752725928/</id>
    <published>2021-08-17T02:43:50.000Z</published>
    <updated>2022-08-02T02:39:10.648Z</updated>
    
    <content type="html"><![CDATA[<p>IIG</p><span id="more"></span><p>2021年8月16年中总结<br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig01.jpg" alt="iqiyi_iig01"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig02.jpg" alt="iqiyi_iig02"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig03.jpg" alt="iqiyi_iig03"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig04.jpg" alt="iqiyi_iig04"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig05.jpg" alt="iqiyi_iig05"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig06.jpg" alt="iqiyi_iig06"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig07.jpg" alt="iqiyi_iig07"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig08.jpg" alt="iqiyi_iig08"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig09.jpg" alt="iqiyi_iig09"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig10.jpg" alt="iqiyi_iig10"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig11.jpg" alt="iqiyi_iig11"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig12.jpg" alt="iqiyi_iig12"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig13.jpg" alt="iqiyi_iig13"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig14.jpg" alt="iqiyi_iig14"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig15.jpg" alt="iqiyi_iig15"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig16.jpg" alt="iqiyi_iig16"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig17.jpg" alt="iqiyi_iig17"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig18.jpg" alt="iqiyi_iig18"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig19.jpg" alt="iqiyi_iig19"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig20.jpg" alt="iqiyi_iig20"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig21.jpg" alt="iqiyi_iig21"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig22.jpg" alt="iqiyi_iig22"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig23.jpg" alt="iqiyi_iig23"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig24.jpg" alt="iqiyi_iig24"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig25.jpg" alt="iqiyi_iig25"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig26.jpg" alt="iqiyi_iig26"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig27.jpg" alt="iqiyi_iig27"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig28.jpg" alt="iqiyi_iig28"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig29.jpg" alt="iqiyi_iig29"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig30.jpg" alt="iqiyi_iig30"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig31.jpg" alt="iqiyi_iig31"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig32.jpg" alt="iqiyi_iig32"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig33.jpg" alt="iqiyi_iig33"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig34.jpg" alt="iqiyi_iig34"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig35.jpg" alt="iqiyi_iig35"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig36.jpg" alt="iqiyi_iig36"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig37.jpg" alt="iqiyi_iig37"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig38.jpg" alt="iqiyi_iig38"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig39.jpg" alt="iqiyi_iig39"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig40.jpg" alt="iqiyi_iig40"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig41.jpg" alt="iqiyi_iig41"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig42.jpg" alt="iqiyi_iig42"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig43.jpg" alt="iqiyi_iig43"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig44.jpg" alt="iqiyi_iig44"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig45.jpg" alt="iqiyi_iig45"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig46.jpg" alt="iqiyi_iig46"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig47.jpg" alt="iqiyi_iig47"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig48.jpg" alt="iqiyi_iig48"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig49.jpg" alt="iqiyi_iig49"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig50.jpg" alt="iqiyi_iig50"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig51.jpg" alt="iqiyi_iig51"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig52.jpg" alt="iqiyi_iig52"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig53.jpg" alt="iqiyi_iig53"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig54.jpg" alt="iqiyi_iig54"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig55.jpg" alt="iqiyi_iig55"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig56.jpg" alt="iqiyi_iig56"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig57.jpg" alt="iqiyi_iig57"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig58.jpg" alt="iqiyi_iig58"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig59.jpg" alt="iqiyi_iig59"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig60.jpg" alt="iqiyi_iig60"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig61.jpg" alt="iqiyi_iig61"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig62.jpg" alt="iqiyi_iig62"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig63.jpg" alt="iqiyi_iig63"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig64.jpg" alt="iqiyi_iig64"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig65.jpg" alt="iqiyi_iig65"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig66.jpg" alt="iqiyi_iig66"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig67.jpg" alt="iqiyi_iig67"><br><img src="/images/D850/iqiyi_iig_2021/iqiyi_iig68.jpg" alt="iqiyi_iig68"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;IIG&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>vue常见API原理分析</title>
    <link href="https://leejs.cn/3258801602/"/>
    <id>https://leejs.cn/3258801602/</id>
    <published>2020-07-04T02:14:41.000Z</published>
    <updated>2022-08-02T02:39:10.647Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><span id="more"></span><h4 id="oberserver"><a href="#oberserver" class="headerlink" title="oberserver"></a>oberserver</h4><p><code>Object.defineProperty()</code></p><h4 id="dep"><a href="#dep" class="headerlink" title="dep"></a>dep</h4><p><code>dep.notify()</code></p><h4 id="watcher"><a href="#watcher" class="headerlink" title="watcher"></a>watcher</h4><p><code>user-watcher</code>  <code>render-watcher</code>  <code>computed-watcher</code></p><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><blockquote><p><code>nextTick</code> 会在<code>DOM</code>更新完毕之后执行一个回调，确保我们操作的是更新之后的<code>DOM</code></p></blockquote><p><code>vue</code>用异步队列的方式来控制<code>DOM</code>更新和<code>nextTick</code>回调先后执行<br><code>microtask</code>因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕<br>因为兼容性问题，<code>vue</code>不得不做了<code>microtask</code>向<code>macrotask</code>的降级方案 (<code>Promise</code>，<code>MutationObserver</code>，<code>setTimeout</code>)</p><ol><li>MutationObserver</li></ol><p>用于监听<code>DOM</code>修改事件，能够监听到节点的属性，文本内容，子节点等的改动</p><ol start="2"><li>Event Loop</li></ol><p>MutationObserver 每次监听到变更的时候会往 microtask 添加一个事件</p><ol start="3"><li>降级方案</li></ol><p>Promise &#x3D;&gt; MutationObserver &#x3D;&gt; setTimeout</p><p><a href="https://www.cnblogs.com/liuhao-web/p/8919623.html">参考文档&gt;&gt;&gt;</a></p><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">initData()</span><br><span class="line">initCompunted()</span><br><span class="line">defineComputed()</span><br><span class="line">Object.defineProperty()</span><br><span class="line">get: createCompuntedGetter()</span><br><span class="line">watcher()</span><br><span class="line">watcher.evaluate()</span><br><span class="line">watcher.depend()</span><br></pre></td></tr></table></figure><blockquote><p>这里的变量<code>watcher</code>就是之前<code>computed</code>对应的<code>computed-watcher</code>实例，接下来会执行<code>Watcher</code>类专门为计算属性定义的两个方法，在执行<code>evaluate</code>方法进行求值的过程中又会触发<code>computed</code>内可以访问到的响应式数据的<code>get</code>，它们会将当前的<code>computed-watcher</code>作为依赖收集到自己的<code>dep</code>里，计算完毕之后将<code>dirty</code>置为<code>false</code>，表示已经计算过了。</p></blockquote><blockquote><p>然后执行<code>depend</code>让计算属性内的响应式数据订阅当前的<code>render-watcher</code>，所以<code>computed</code>内的响应式数据会收集<code>computed-watcher</code>和<code>render-watcher</code>两个<code>watcher</code>，当<code>computed</code>内的状态发生变更触发<code>se</code>t后，首先通知<code>computed</code>需要进行重新计算，然后通知到视图执行渲染，再渲染中会访问到<code>computed</code>计算后的值，最后渲染到页面。</p></blockquote><p>为什么计算属性有缓存功能？</p><p>因为当计算属性经过计算后，内部的标志位会表明已经计算过了，再次访问时会直接读取计算后的值</p><p>为什么计算属性内的响应式数据发生变更后，计算属性会重新计算？</p><p>因为内部的响应式数据会收集<code>computed-watcher</code>，变更后通知计算属性要进行计算，也会通知页面重新渲，渲染染时会读取到重新计算后的值。</p><h3 id="watcher-1"><a href="#watcher-1" class="headerlink" title="watcher"></a>watcher</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">watch监听属性收集依赖过程</span><br><span class="line"></span><br><span class="line">root =&gt; _init()    根组件初始化</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">root =&gt; vm._update(vm._render())   根组件渲染，没状态不用收集依赖</span><br><span class="line">  app =&gt; initData()                 初始化App组件的data</span><br><span class="line">  app =&gt; oberserver(name)           将name转为响应式</span><br><span class="line">  app =&gt; initWatch(watch)           初始化watch</span><br><span class="line">  app =&gt; this.$watch(&#x27;name&#x27;)        主要就是这里： 触发name的get， 让dep收集user-watcher </span><br><span class="line">  app =&gt; Sub.$mont()                子组件挂载</span><br><span class="line">  app =&gt; new Watcher(vm, geeter)    实例化 render-watcher</span><br><span class="line">  app =&gt; vm._render()               触发name的get， 让dep收集render-watcher</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  watch监听属性派发更新</span><br><span class="line"></span><br><span class="line">  app =&gt; name = &#x27;www&#x27;               响应式数据被贱赋值，触发set</span><br><span class="line">  app =&gt; dep.nofity()               dep通知收集到的watcher</span><br><span class="line">  app =&gt; user-watcher               user-watcher派发新值跟旧值给回调函数</span><br><span class="line">  app =&gt; render-watcher             redner-wachter改变视图</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>watch</code>和<code>this.$watch</code>的实现是一致的，以及简单解释它的原理就是为需要观察的数据创建并收集·，当数据改变时通知到·将新值和旧值传递给用户自己定义的回调函数。</p><p>定义watch时会被使用到的三个参数：<code>sync</code>、<code>immediate</code>、<code>deep</code></p><p>简单说明它们的实现原理就是：<code>sync</code>是不将watcher加入到nextTick队列而同步的更新、<code>immediate</code>是立即以得到的值执行一次回调函数、<code>deep</code>是递归的对它的子值进行依赖收集。</p><h3 id="虚拟DOM生成真实DOM的过程"><a href="#虚拟DOM生成真实DOM的过程" class="headerlink" title="虚拟DOM生成真实DOM的过程"></a>虚拟DOM生成真实DOM的过程</h3><ol><li>元素节点生成<code>Dom</code></li></ol><p>里向外的挨个创建出真实的<code>Dom</code>，然后插入到它的父节点内，最后将创建好的<code>Dom</code>插入到<code>body</code>内，完成创建的过程</p><ol start="2"><li>组件VNode生成<code>Dom</code></li></ol><blockquote><p>无论是嵌套多么深的组件，遇到组件的后就执行<code>init</code>，在<code>init</code>的<code>__patch__</code>过程中又遇到嵌套组件，那就再执行嵌套组件的<code>init</code>，嵌套组件完成<code>__patch__</code>后将真实的<code>Dom</code>插入到它的父节点内，接着执行完外层组件的<code>__patch__</code>又插入到它的父节点内，最后插入到<code>body</code>内，完成嵌套组件的创建过程，总之还是一个由里及外的过程</p></blockquote><h3 id="extend和-mount"><a href="#extend和-mount" class="headerlink" title="extend和$mount"></a>extend和$mount</h3><p>这两个都是<code>vue</code>提供的API，不过在平时的业务开发中使用并不多。在<code>vue</code>的内部也有使用过这一对API。遇到嵌套组件时，首先将子组件转为组件形式的VNode时，会将引入的组件对象使用extend转为子组件的构造函数，作为VNode的一个属性Ctor；然后在将VNode转为真实的<code>Dom</code>的时候实例化这个构造函数；最后实例化完成后手动调用$mount进行挂载，将真实<code>Dom</code>插入到父节点内完成渲染。</p><h4 id="extend"><a href="#extend" class="headerlink" title="extend"></a>extend</h4><blockquote><p>接受的是一个组件对象，再执行extend时将继承基类构造器上的一些属性、原型方法、静态方法等，最后返回Sub这么一个构造好的子组件构造函数。拥有和<code>vue</code>基类一样的能力，并在实例化时会执行继承来的_init方法完成子组件的初始化。</p></blockquote><h4 id="实例化Sub"><a href="#实例化Sub" class="headerlink" title="实例化Sub"></a>实例化Sub</h4><blockquote><p>执行_init组件初始化的一系列操作，初始化事件、生命周期、状态等等。将data或props内定义的变量挂载到当前this实例下，最后返回一个实例化后的对象。</p></blockquote><h4 id="mount"><a href="#mount" class="headerlink" title="$mount"></a>$mount</h4><blockquote><p>在得到初始化后的对象后，开始组件的挂载。首先将当前render函数转为VNode，然后将VNode转为真实Dom插入到页面完成渲染。再完成挂载之后，会在当前组件实例this下挂载$el属性，它就是完成挂载后对应的真实Dom，我们就需要使用这个属性。</p></blockquote><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol><li>请问<code>runtime-compiler</code>和<code>runtime-only</code>这两个版本的区别？</li></ol><blockquote><p><code>runtime-compiler</code> 经历的是一个 <code>template -&gt; ast -&gt; render -&gt; vdom -&gt; UI</code> 的过程，<br><code>runtime-only</code>直接使用了<code>render</code>函数，所以经历的是一个 <code>render -&gt; vdom -&gt; UI</code> 的过程。 <code>runtime-only</code> 会省去一个 <code>template -&gt; ast -&gt; render</code> 的过程，也不再需要相关的<code>loader</code>插件，从而这种方法搭建的项目性能更高，代码也更少，项目大小也更小。<br>最明显的就是大小的区别，带编译器会比不带的版本大6kb。</p></blockquote><ol start="2"><li>请问可以在<code>beforeCreate</code>钩子内通过<code>this</code>访问到<code>data</code>中定义的变量么，为什么以及请问这个钩子可以做什么？</li></ol><blockquote><p>是不可以访问的，因为在<code>vue</code>初始化阶段，这个时候<code>data</code>中的变量还没有被挂载到<code>this</code>上，这个时候访问值会是<code>undefined</code>。<br><code>beforeCreate</code>这个钩子在平时业务开发中用的比较少，而像插件内部的<code>instanll</code>方法通过<code>Vue.use</code>方法安装时一般会选在<code>beforeCreate</code>这个钩子内执行，<code>vue-router</code>和<code>vuex</code>就是这么干的。</p></blockquote><ol start="3"><li>请问<code>methods</code>内的方法可以使用箭头函数么，会造成什么样的结果？</li></ol><blockquote><p>是不可以使用箭头函数的，因为箭头函数的<code>this</code>是定义时就绑定的。<br>在vue的内部，<code>methods</code>内每个方法的上下文是当前的vm组件实例，<code>methods[key].bind(vm)</code>，而如果使用使用箭头函数，函数的上下文就变成了父级的上下文，也就是<code>undefined</code>了，结果就是通过<code>undefined</code>访问任何变量都会报错。</p></blockquote><ol start="4"><li>请问vue@2为什么要引入虚拟Dom，谈谈对虚拟Dom的理解？</li></ol><blockquote><p>随着现代应用对页面的功能要求越复杂，管理的状态越多，如果还是使用之前的JavaScript线程去频繁操作GUI线程的硕大Dom，对性能会有很大的损耗，而且也会造成状态难以管理，逻辑混乱等情况。引入虚拟Dom后，在框架的内部就将虚拟Dom树形结构与真实Dom做了映射，让我们不用在命令式的去操作Dom，可以将重心转为去维护这棵树形结构内的状态即可，状态的变化就会驱动Dom发生改变，具体的Dom操作vue帮我们完成，而且这些大部分可以在JavaScript线程完成，性能更高<br>虚拟Dom只是一种数据结构，可以让它不仅仅使用在浏览器环境，还可以用与SSR以及Weex等场景。</p></blockquote><ol start="5"><li>父子两个组件同时定义了<code>beforeCreate</code>、<code>created</code>、<code>beforeMounte</code>、<code>mounted</code>四个钩子，它们的执行顺序是怎么样的？</li></ol><blockquote><p>首先会执行父组件的初始化过程，所以会依次执行<code>beforeCreate</code>、<code>created</code>、在执行挂载前又会执行<code>beforeMounte</code>钩子，不过在生成真实dom的<code>__patch__</code>过程中遇到嵌套子组件后又会转为去执行子组件的初始化钩子<code>beforeCreate</code>、<code>created</code>，子组件在挂载前会执行<code>beforeMounte</code>，再完成子组件的Dom创建后执<code>行mounted</code>。这个父组件的<code>__patch__</code>过程才算完成，最后执行父组件的<code>mounted</code>钩子，这就是它们的执行顺序。执行顺序如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">parent beforeCreate</span><br><span class="line">parent created</span><br><span class="line">parent beforeMounte</span><br><span class="line">    child beforeCreate</span><br><span class="line">    child created</span><br><span class="line">    child beforeMounte</span><br><span class="line">    child mounted</span><br><span class="line">parent mounted</span><br></pre></td></tr></table></figure><ol start="6"><li>当前组件模板中用到的变量一定要定义在data里么？</li></ol><blockquote><p>data中的变量都会被代理到当前this下，所以我们也可以在this下挂载属性，只要不重名即可。而且定义在data中的变量在vue的内部会将它包装成响应式的数据，让它拥有变更即可驱动视图变化的能力。但是如果这个数据不需要驱动视图，定义在created或mounted钩子内也是可以的，因为不会执行响应式的包装方法，对性能也是一种提升。</p></blockquote><ol start="7"><li>请简单描述下vue响应式系统？</li></ol><blockquote><p>简单来说就是使用Object.defineProperty这个API为数据设置get和set。  当读取到某个属性时，触发get将读取它的组件对应的render watcher收集起来；当重置赋值时，触发set通知组件重新渲染页面。<br>如果数据的类型是数组的话，还做了单独的处理，对可以改变数组自身的方法进行重写，因为这些方法不是通过重新赋值改变的数组，不会触发set，所以要单独处理。<br>响应系统也有自身的不足，所以官方给出了$set和$delete来弥补。</p></blockquote><ol start="8"><li>为什么v-for里建议为每一项绑定key，而且最好具有唯一性，而不建议使用index？</li></ol><blockquote><p>diff比对内部做更新子节点时，会根据oldVnode内没有处理的节点得到一个key值和下标对应的对象集合，为的就是当处理vnode每一个节点时，能快速查找该节点是否是已有的节点，从而提高整个diff比对的性能。<br>如果是一个动态列表，key值最好能保持唯一性，但像轮播图那种不会变更的列表，使用index也是没问题的。</p></blockquote><ol start="9"><li>说下自定义事件的机制。</li></ol><blockquote><p>子组件使用this.$emit触发事件时，会在当前实例的事件中心去查找对应的事件，然后执行它。不过这个事件回调是在父组件的作用域里定义的，所以$emit里的参数会传递给父组件的回调函数，从而完成父子组件通信。</p></blockquote><ol start="10"><li>请说明下组件库中命令式弹窗组件的原理？</li></ol><blockquote><p>使用<code>extend</code>将组件转为构造函数，在实例化这个这个构造函数后，就会得到<code>$el</code>属性，也就是组件的真实<code>Dom</code>，这个时候我们就可以操作得到的真实的<code>Dom</code>去任意挂载，使用命令式也可以调用。</p></blockquote><ol start="11"><li>请说明下<code>transition</code>组件的实现原理？</li></ol><blockquote><p><code>transition</code>组件是一个抽象组件，不会渲染出任何的<code>Dom</code>，它主要是帮助我们更加方便的写出动画。<br>以插槽的形式对内部单一的子节点进行动画的管理，在渲染阶段就会往子节点的虚拟<code>Dom</code>上挂载一个<code>transition</code>属性，表示它的一个被<code>transition</code>组件包裹的节点，在<code>path</code>阶段就会执行<code>transition</code>组件内部钩子，钩子里分为<code>enter</code>和<code>leave</code>状态，在这个被包裹的子节点上使用<code>v-if</code>或<code>v-show</code>进行状态的切换。<br>你可以使用<code>Css</code>也可以使用<code>JavaScript</code>钩子，使用<code>Css</code>方式时会在<code>enter/leave</code>状态内进行<code>class</code>类名的添加和删除，用户只需要写出对应类名的动画即可。<br>如果使用<code>JavaScript</code>钩子，则也是按照顺序的执行指定的函数，而这些函数也是需要用户自己定义，组件只是控制这个的流程而已。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;数据绑定&quot;&gt;&lt;a href=&quot;#数据绑定&quot; class=&quot;headerlink&quot; title=&quot;数据绑定&quot;&gt;&lt;/a&gt;数据绑定&lt;/h3&gt;</summary>
    
    
    
    
    <category term="vue" scheme="https://leejs.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>面试记录</title>
    <link href="https://leejs.cn/148981014/"/>
    <id>https://leejs.cn/148981014/</id>
    <published>2020-07-04T01:49:04.000Z</published>
    <updated>2022-08-02T02:39:10.647Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器多进程+多线程<br>DNS寻址方式，DNS 缓存， dns-prefetch<br>建立 tcp&#x2F;ip 链接，三次握手，四次挥手，滑动窗口，接收窗口，收发帧的策略，为什么关闭要等待 2MSL，get post 区别，并发限制<br>传输数据，展开计算机网络 5 层&#x2F;7 层模型，五层：http -&gt; tcp&#x2F;ip -&gt; ip -&gt; data frames -&gt; 物理介质<br>服务器收到请求，负载均衡，tomcat 容器，后端统一拦截过滤<br>展开 http 报文，实体，http 1.0, 1,1 2之间的区别，gzip，长连接&#x2F;短连接，展开 cookie 及优化，多子域名拆分等<br>展开 https 中 SSL&#x2F;TLS 链接步骤<br>展开 http 缓存，强缓存，协商缓存，from memory&#x2F;disk cache等<br>DOM 树的构建过程，bytes -&gt; characters -&gt; tokens -&gt; nodes -&gt; DOM<br>css rule tree: bytes -&gt; characters -&gt; tokens -&gt; nodes -&gt; CSSOM<br>renderTree 的构建，不可见元素，特殊元素等。<br>渲染：compute css -&gt; construct frames -&gt; layout -&gt; paint<br>展开 reflow , repaint 已经对应优化方法<br>绘制中的简单图层与复合图层，开启硬件加速就是把对应节点丢到复合图层<br>css 盒模型，BFC，IFC<br>静态资源外链 css，js(defer, async)，img<br>展开 loaded 和 domContentLoaded<br>JS 解释阶段: token -&gt; AST -&gt; bytecode -&gt; machine code 然后扯到 JIT<br>JS 预处理阶段，变量提升，分号补全等。<br>JS 执行阶段，EC stack，EC，VO，AO，作用域链， this，原型，继承（组合寄生式继承，es6 继承），JS 事件循环，micortask，marcortask等<br>JS GC -&gt; v8 GC</p><p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question">https://github.com/Advanced-Frontend/Daily-Interview-Question</a><br><a href="https://muyiy.cn/question/">https://muyiy.cn/question/</a><br><a href="https://blog.csdn.net/liudianjia/article/details/104805503">https://blog.csdn.net/liudianjia/article/details/104805503</a><br><a href="https://blog.colafornia.me/post/2020/2020-interviews/">https://blog.colafornia.me/post/2020/2020-interviews/</a></p><h3 id="猿辅导"><a href="#猿辅导" class="headerlink" title="猿辅导"></a>猿辅导</h3><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable constant_">JS</span>：<span class="title class_">Promise</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="title function_">fetch</span>(<span class="comment">/*…*/</span>);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(f1).<span class="title function_">catch</span>(f2).<span class="title function_">then</span>(f3); <span class="comment">// p failed</span></span><br><span class="line"></span><br><span class="line"><span class="function">() =&gt;</span> &#123;&#125; vs <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;‏‎ ‎</span><br><span class="line"></span><br><span class="line">  <span class="attr">f1</span>:‏‎ ‎() =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>),</span><br><span class="line"></span><br><span class="line">  f2‏‎ ‎() &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) &#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">f1</span>() <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">f2</span>() <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> obj.<span class="title function_">f1</span>() <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">new</span> obj.<span class="title function_">f2</span>() <span class="comment">// f1</span></span><br><span class="line"></span><br><span class="line">&lt;A&gt;</span><br><span class="line"></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">B</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;/A&gt;</span><br><span class="line"></span><br><span class="line">a.<span class="property">created</span></span><br><span class="line">b.<span class="property">created</span></span><br><span class="line">a.<span class="property">mounted</span></span><br><span class="line">b.<span class="property">mounted</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Node</span> &#123; <span class="attr">value</span>: number; <span class="attr">children</span>: <span class="title class_">Node</span>[] &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> =&gt; <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>,     <span class="number">3</span>,     <span class="number">5</span> =&gt; <span class="number">6</span>+<span class="number">3</span>+<span class="number">5</span>=<span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>;   <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>;   <span class="number">7</span>, <span class="number">8</span> =&gt; <span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>+<span class="number">4</span>+<span class="number">7</span>+<span class="number">8</span>=<span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 告诉我多叉树每一层的和 [2, 14, 25]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">layerSum</span>(<span class="params">root：Node</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h4><ol><li>vue双向绑定原理 -&gt; angular与vue双向绑定的区别 -&gt; 性能对比</li><li>讲讲虚拟Dom -&gt; patch </li><li>v-for key </li><li>数组或者对象变化检测问题与原因，一般要聊vue对数组做了劫持</li><li>组件生命周期，父子组件生命周期</li><li>路由实现原理，以及路由钩子相关内容</li><li>计算属性和方法，计算属性和watch区别</li><li>nextTick原理</li><li>mixin的钩子顺序</li><li>3.0有哪些变化</li></ol><h4 id="Js"><a href="#Js" class="headerlink" title="Js"></a>Js</h4><ol><li>es6用过哪些？ -&gt; let&#x2F;const  promise  await class module 很常问</li><li>继承的实现方法 -&gt; es5继承和class区别</li><li>判断一个变量是不是数组有几种方法？isArray， toString，还有通过原型的构造函数等方法</li><li>什么是闭包，闭包的应用</li><li>event loop</li><li>for &gt; forEach &gt; map  区别，性能，注意参数</li><li>this的考察，一般是给一段代码看输出然后让你详细讲讲this</li></ol><h4 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h4><ol><li>webpack原理</li><li>loader，plugin作用，原理，区别，你有没有写过？</li><li>多页应用怎么配</li><li>你知道哪些loader&#x2F;plugin，然后会问你他的作用是什么？例如css-loader，url-loader，我遇到一个变态问我postcss-loader，css-loader，style-loader，url-loader分别具体做了什么……</li><li>publicPath 和 path的区别</li><li>热更新原理</li><li>webpack优化&#x2F;懒加载&#x2F;分包设计</li></ol><h4 id="浏览器与网络"><a href="#浏览器与网络" class="headerlink" title="浏览器与网络"></a>浏览器与网络</h4><ol><li>跨域问题</li><li>浏览器缓存，Cache-Control与expires区别，Cache-Control有哪些属性， 如何利用浏览器缓存？</li><li>输入一个url发生了什么，准备的详细一点，这里还会引出js的三种加载方式，还可能问每个阶段的优化</li><li>http状态码</li><li>https与http区别，https的混合加密，非对称加密与对称加密的过程， 非对称加密与对称加密算法性能</li><li>cookie，session的区别，cookie有哪些属性，这里可以聊聊sameSite，httpOnly防xss攻击</li><li>http请求有哪些头部信息？响应有哪些头部信息？Content-Type有哪些类型？</li><li>xss,csrf是什么？怎么预防？</li><li>http2.0 与 1.x的区别？</li><li>CDN的特点， 分布式节点，回源， 缓存，cdn静态资源定期推送</li></ol><h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><ol><li>flex布局</li><li>水平垂直居中的几种方法</li><li>三栏&#x2F;两栏布局</li><li>层叠上下文</li><li>em, rem, vw 和vh， 移动端响应式布局方案</li><li>盒子模型</li><li>css权重</li><li>实现三角形，梯形</li><li>动画</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ol><li>二分查找</li><li>乱序算法</li><li>实现new， instanceOf，promise ，promise all啥的</li><li>两个有序数组合并</li><li>两数之和等于n</li><li>数组最大和</li><li>最大子串长度</li><li>reduce用法， 用reduce实现map</li><li>排序 不太直接让你写排序算法，而是会做个结合题，给表格排序之类的，会和dom，css结合</li><li>实现深拷贝</li><li>实现new， instanceOf</li><li>实现并发限制，异步最多4个并发</li><li>实现延迟n秒重试，最大重试次数t， attempt(fn, times, delay)</li><li>实现LazyMan</li></ol><p>&#x2F;&#x2F; LazyMan(“Hank”);<br>&#x2F;&#x2F; &#x3D;&gt; Hi! This is Hank!</p><p>&#x2F;&#x2F; LazyMan(“Hank”).sleep(2).eat(‘dinner’);<br>&#x2F;&#x2F; &#x3D;&gt; Hi! This is Hank!<br>&#x2F;&#x2F; 等待10秒<br>&#x2F;&#x2F; &#x3D;&gt; Wake up after 10<br>&#x2F;&#x2F; &#x3D;&gt; Eat dinner.</p><p>&#x2F;&#x2F; LazyMan(“Hank”).eat(‘dinner’).eat(‘supper’);<br>&#x2F;&#x2F; &#x3D;&gt; Hi! This is Hank!<br>&#x2F;&#x2F; &#x3D;&gt; Eat dinner.<br>&#x2F;&#x2F; &#x3D;&gt; Eat supper.</p><p>&#x2F;&#x2F; LazyMan(“Hank”).sleepFirst(2).eat(‘supper’);<br>&#x2F;&#x2F; 等待5秒<br>&#x2F;&#x2F; &#x3D;&gt; Hi! This is Hank!<br>&#x2F;&#x2F; &#x3D;&gt; Eat supper.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;浏览器多进程+多线程&lt;br&gt;DNS寻址方式，DNS 缓存， dns-prefetch&lt;br&gt;建立 tcp&amp;#x2F;ip 链接，三次握手，四次挥手，滑动窗口，接收窗口，收发帧的策略，为什么关闭要等待 2MSL，get post 区别，并发限制&lt;br&gt;传输数据，展开计算机网络 5 层&amp;#x2F;7 层模型，五层：http -&amp;gt; tcp&amp;#x2F;ip -&amp;gt; ip -&amp;gt; data frames -&amp;gt; 物理介质&lt;br&gt;服务器收到请求，负载均衡，tomcat 容器，后端统一拦截过滤&lt;br&gt;展开 http 报文，实体，http 1.0, 1,1 2之间的区别，gzip，长连接&amp;#x2F;短连接，展开 cookie 及优化，多子域名拆分等&lt;br&gt;展开 https 中 SSL&amp;#x2F;TLS 链接步骤&lt;br&gt;展开 http 缓存，强缓存，协商缓存，from memory&amp;#x2F;disk cache等&lt;br&gt;DOM 树的构建过程，bytes -&amp;gt; characters -&amp;gt; tokens -&amp;gt; nodes -&amp;gt; DOM&lt;br&gt;css rule tree: bytes -&amp;gt; characters -&amp;gt; tokens -&amp;gt; nodes -&amp;gt; CSSOM&lt;br&gt;renderTree 的构建，不可见元素，特殊元素等。&lt;br&gt;渲染：compute css -&amp;gt; construct frames -&amp;gt; layout -&amp;gt; paint&lt;br&gt;展开 reflow , repaint 已经对应优化方法&lt;br&gt;绘制中的简单图层与复合图层，开启硬件加速就是把对应节点丢到复合图层&lt;br&gt;css 盒模型，BFC，IFC&lt;br&gt;静态资源外链 css，js(defer, async)，img&lt;br&gt;展开 loaded 和 domContentLoaded&lt;br&gt;JS 解释阶段: token -&amp;gt; AST -&amp;gt; bytecode -&amp;gt; machine code 然后扯到 JIT&lt;br&gt;JS 预处理阶段，变量提升，分号补全等。&lt;br&gt;JS 执行阶段，EC stack，EC，VO，AO，作用域链， this，原型，继承（组合寄生式继承，es6 继承），JS 事件循环，micortask，marcortask等&lt;br&gt;JS GC -&amp;gt; v8 GC&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Advanced-Frontend/Daily-Interview-Question&quot;&gt;https://github.com/Advanced-Frontend/Daily-Interview-Question&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://muyiy.cn/question/&quot;&gt;https://muyiy.cn/question/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/liudianjia/article/details/104805503&quot;&gt;https://blog.csdn.net/liudianjia/article/details/104805503&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://blog.colafornia.me/post/2020/2020-interviews/&quot;&gt;https://blog.colafornia.me/post/2020/2020-interviews/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;猿辅导&quot;&gt;&lt;a href=&quot;#猿辅导&quot; class=&quot;headerlink&quot; title=&quot;猿辅导&quot;&gt;&lt;/a&gt;猿辅导&lt;/h3&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>vue 父子组件的生命周期顺序</title>
    <link href="https://leejs.cn/677899705/"/>
    <id>https://leejs.cn/677899705/</id>
    <published>2020-07-03T16:18:42.000Z</published>
    <updated>2022-08-02T02:39:10.647Z</updated>
    
    <content type="html"><![CDATA[<h3 id="加载渲染过程"><a href="#加载渲染过程" class="headerlink" title="加载渲染过程"></a>加载渲染过程</h3><span id="more"></span><h4 id="同步加载"><a href="#同步加载" class="headerlink" title="同步加载"></a>同步加载</h4><p>父组件 beforeCreate,  created, beforMount<br>子组件 beforeCreate, created, beforMount<br>孙子组件 beforeCreate, created, beforMount<br>孙子组件 mounted<br>子组件 mounted<br>父组件 mounted</p><h4 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h4><p>父组件 beforeCreate, created, beforMount, mounted<br>子组件 beforeCreate, created, beforMount, mounted</p><h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><p>父组件 beforeUpdate<br>子组件 beforeUpdate<br>子组件 updated<br>父组件 updated</p><h3 id="销毁过程"><a href="#销毁过程" class="headerlink" title="销毁过程"></a>销毁过程</h3><p>父组件 beforeDestroy<br>子组件 beforeDestroy<br>子组件 destroyed<br>父组件 destroyed</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;加载渲染过程&quot;&gt;&lt;a href=&quot;#加载渲染过程&quot; class=&quot;headerlink&quot; title=&quot;加载渲染过程&quot;&gt;&lt;/a&gt;加载渲染过程&lt;/h3&gt;</summary>
    
    
    
    
    <category term="vue" scheme="https://leejs.cn/tags/vue/"/>
    
    <category term="vue 原理" scheme="https://leejs.cn/tags/vue-%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JS 普通函数跟箭头函数的区别</title>
    <link href="https://leejs.cn/3671102502/"/>
    <id>https://leejs.cn/3671102502/</id>
    <published>2020-07-03T15:31:38.000Z</published>
    <updated>2022-08-02T02:39:10.648Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>箭头函数不会产生this, 会捕捉当前的执行上下文中的this当做自己的this</p></li><li><p>箭头函数不能做为构造函数</p></li><li><p>箭头函数不能绑定 arguments </p></li><li><p>call&#x2F;apply&#x2F;bind 对箭头函数不起作用</p></li><li><p>箭头函数没有原型属性</p></li><li><p>箭头函数不能当作 Generator 函数，不能使用 yield 关键字</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;箭头函数不会产生this, 会捕捉当前的执行上下文中的this当做自己的this&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;箭头函数不能做为构造函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;箭头函数不能绑定 arguments &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;cal</summary>
      
    
    
    
    
    <category term="js" scheme="https://leejs.cn/tags/js/"/>
    
    <category term="js 基础" scheme="https://leejs.cn/tags/js-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
