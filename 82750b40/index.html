<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>vue3 双向绑定 | Lee Blog</title><meta name="keywords" content="vue3,数据双向绑定"><meta name="author" content="李鹏辉,ahuinet@163.com"><meta name="copyright" content="李鹏辉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] 写在前面本文的目标是实现一个基本的vue3的响应式，包含最基础的情况的处理，本文是系列文章，如果你对vue3还不了解，那么请移步： 超详细整理vue3基础知识💥 手写mini-vue3第三弹！万字实现渲染器首次渲染流程 🎉 🎉  更新！更新！实现vue3虚拟DOM更新&amp;diff算法优化🎉 🎉 本文你将学到  一个基础的响应式实现 ✅ Proxy ✅ Reflect ✅">
<meta property="og:type" content="article">
<meta property="og:title" content="vue3 双向绑定">
<meta property="og:url" content="https://leejs.cn/82750b40/index.html">
<meta property="og:site_name" content="Lee Blog">
<meta property="og:description" content="[TOC] 写在前面本文的目标是实现一个基本的vue3的响应式，包含最基础的情况的处理，本文是系列文章，如果你对vue3还不了解，那么请移步： 超详细整理vue3基础知识💥 手写mini-vue3第三弹！万字实现渲染器首次渲染流程 🎉 🎉  更新！更新！实现vue3虚拟DOM更新&amp;diff算法优化🎉 🎉 本文你将学到  一个基础的响应式实现 ✅ Proxy ✅ Reflect ✅">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images-origin.wallwiz.link/58860b456e9f6a00013b8f0f_1">
<meta property="article:published_time" content="2022-09-27T03:46:29.000Z">
<meta property="article:modified_time" content="2022-09-27T03:50:04.773Z">
<meta property="article:author" content="李鹏辉">
<meta property="article:tag" content="vue3">
<meta property="article:tag" content="数据双向绑定">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images-origin.wallwiz.link/58860b456e9f6a00013b8f0f_1"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://leejs.cn/82750b40/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'vue3 双向绑定',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-27 11:50:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> Media</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-image"></i><span> Gallery</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://images-origin.wallwiz.link/58860b456e9f6a00013b8f0f_1')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lee Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> Media</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-image"></i><span> Gallery</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">vue3 双向绑定</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-27T03:46:29.000Z" title="发表于 2022-09-27 11:46:29">2022-09-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-27T03:50:04.773Z" title="更新于 2022-09-27 11:50:04">2022-09-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/vue3/">vue3</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/vue3/%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/">双向绑定</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="vue3 双向绑定"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文的目标是实现一个基本的<code>vue3</code>的响应式，包含最基础的情况的处理，本文是系列文章，如果你对<code>vue3</code>还不了解，那么请移步：</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7102217959669497887">超详细整理vue3基础知识💥</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7142694451448643591">手写mini-vue3第三弹！万字实现渲染器首次渲染流程 🎉 🎉 </a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7147318515056410638/">更新！更新！实现vue3虚拟DOM更新&amp;diff算法优化🎉 🎉</a></p>
<p><strong>本文你将学到</strong></p>
<ul>
<li>一个基础的响应式实现 ✅</li>
<li>Proxy ✅</li>
<li>Reflect ✅</li>
<li>嵌套effect的实现 ✅</li>
<li>computed ✅</li>
<li>watch ✅</li>
<li>浅响应与深响应 ✅</li>
<li>浅只读与深只读 ✅</li>
<li>处理数组长度 ✅</li>
<li>ref ✅</li>
<li>toRefs ✅</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5569070d900a49f69ce692137b20b35d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="响应式.png"></p>
<h2 id="一-实现一个完善的响应式"><a href="#一-实现一个完善的响应式" class="headerlink" title="一. 实现一个完善的响应式"></a>一. 实现一个完善的响应式</h2><p>所谓的响应式数据的概念，其实最主要的目的就是<strong>为数据绑定执行函数，当数据发生变动的时候，再次触发函数的执行。</strong></p>
<p>例如我们有一个对象<code>data</code>，我们想让它变成一个响应式数据，当<code>data</code>的数据发生变化时，自动执行<code>effect</code>函数，使<code>nextVal</code>变量的值也进行变化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个对象</span></span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;pino&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nextVal</span><br><span class="line"><span class="comment">// 待绑定函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params"></span>) &#123;</span><br><span class="line">  nextVal = data.<span class="property">age</span> + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data.<span class="property">age</span>++</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的例子中我们将<code>data</code>中的<code>age</code>的值进行变化，但是<code>effect</code>函数并没有执行，因为现在<code>effect</code>函数与<code>data</code>这个对象不能说是没啥联系，简直就是半毛钱的关系都没有。</p>
<p>那么怎么才能使这两个毫不相关的函数与对象之间产生关联呢？</p>
<p>因为一个对象最好可以绑定多个函数，所以有没有可能我们为<code>data</code>这个对象定义一个空间，每当<code>data</code>的值进行变化的时候就会执行这个空间里的函数？</p>
<p>答案是有的。</p>
<h3 id="1-Object-defineProperty"><a href="#1-Object-defineProperty" class="headerlink" title="1. Object.defineProperty()"></a>1. Object.defineProperty()</h3><p>js在原生提供了一个用于操作对象的比较底层的api：<code>Object.defineProperty()</code>，它赋予了我们对一个对象的读取和拦截的操作。</p>
<p><code>Object.defineProperty()</code>方法直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, prop, descriptor)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<p><code>obj</code> 需要定义属性的对象。 <code>prop</code> 需被定义或修改的属性名。 <code>descriptor</code> (描述符) 需被定义或修改的属性的描述符。</p>
<p>其中<code>descriptor</code>接受一个对象，对象中可以定义以下的属性描述符，使用属性描述符对一个对象进行拦截和控制：</p>
<ul>
<li><code>value</code>——当试图获取属性时所返回的值。</li>
<li><code>writable</code>——该属性是否可写。</li>
<li><code>enumerable</code>——该属性在for in循环中是否会被枚举。</li>
<li><code>configurable</code>——该属性是否可被删除。</li>
<li><code>set()</code>——该属性的更新操作所调用的函数。</li>
<li><code>get()</code>——获取属性值时所调用的函数。</li>
</ul>
<p>另外，数据描述符（其中属性为： <code>enumerable</code> ， <code>configurable</code> ， <code>value</code> ， <code>writable</code> ）与存取描述符（其中属性为 <code>enumerable</code> ， <code>configurable</code> ， <code>set()</code> ， <code>get()</code> ）之间是有互斥关系的。在定义了 <code>set()</code> 和 <code>get()</code> 之后，描述符会认为存取操作已被 定义了，其中再定义 <code>value</code> 和 <code>writable</code> 会引起错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;小花&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 属性读取时进行拦截</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;小明&#x27;</span>; &#125;,</span><br><span class="line">  <span class="comment">// 属性设置时拦截</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">newValue</span>) &#123; obj.<span class="property">name</span> = newValue; &#125;,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的例子中就已经完成对一个对象的最基本的拦截，这也是<code>vue2.x</code>中对对象监听的方式，但是由于<code>Object.defineProperty()</code>中存在一些问题，例如：</p>
<ol>
<li>一次只能对一个属性进行监听，需要遍历来对所有属性监听</li>
<li>对于对象的新增属性，需要手动监听</li>
<li>对于数组通过<code>push</code>、<code>unshift</code>方法增加的元素，也无法监听</li>
</ol>
<p>那么<code>vue3</code>版本中是如何对一个对象进行拦截的呢？答案是<code>es6</code>中的<code>Proxy</code>。</p>
<p>由于本文主要是<code>vue3</code>版本的响应式的实现，如果想要深入了解<code>Object.defineProperty()</code>，请移步：</p>
<p><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">MDN Object.defineProperty</a></p>
<h3 id="2-Proxy"><a href="#2-Proxy" class="headerlink" title="2. Proxy"></a>2. Proxy</h3><p><code>proxy</code>是<code>es6</code>版本出现的一种对对象的操作方式，<code>Proxy</code> 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。<code>Proxy</code> 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<p>通过<code>proxy</code>我们可以实现对一个对象的读取，设置等等操作进行拦截，而且直接对对象进行整体拦截，内部提供了多达13种拦截方式。</p>
<ul>
<li><strong>get(target, propKey, receiver)</strong> ：拦截对象属性的读取，比如 <code>proxy.foo</code> 和 <code>proxy[&#39;foo&#39;]</code> 。</li>
<li><strong>set(target, propKey, value, receiver)</strong> ：拦截对象属性的设置，比如 <code>proxy.foo = v</code> 或 <code>proxy[&#39;foo&#39;] = v</code> ，返回一个布尔值。</li>
<li><strong>has(target, propKey)</strong> ：拦截 <code>propKey in proxy</code> 的操作，返回一个布尔值。</li>
<li><strong>deleteProperty(target, propKey)</strong> ：拦截 <code>delete proxy[propKey]</code> 的操作，返回一个布尔值。</li>
<li><strong>ownKeys(target)</strong> ：拦截 <code>Object.getOwnPropertyNames(proxy)</code> 、 <code>Object.getOwnPropertySymbols(proxy)</code> 、 <code>Object.keys(proxy)</code> 、 <code>for...in</code> 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 <code>Object.keys()</code> 的返回结果仅包括目标对象自身的可遍历属性。</li>
<li><strong>getOwnPropertyDescriptor(target, propKey)</strong> ：拦截 <code>Object.getOwnPropertyDescriptor(proxy, propKey)</code> ，返回属性的描述对象。</li>
<li><strong>defineProperty(target, propKey, propDesc)</strong> ：拦截 <code>Object.defineProperty(proxy, propKey, propDesc）</code> 、 <code>Object.defineProperties(proxy, propDescs)</code> ，返回一个布尔值。</li>
<li><strong>preventExtensions(target)</strong> ：拦截 <code>Object.preventExtensions(proxy)</code> ，返回一个布尔值。</li>
<li><strong>getPrototypeOf(target)</strong> ：拦截 <code>Object.getPrototypeOf(proxy)</code> ，返回一个对象。</li>
<li><strong>isExtensible(target)</strong> ：拦截 <code>Object.isExtensible(proxy)</code> ，返回一个布尔值。</li>
<li><strong>setPrototypeOf(target, proto)</strong> ：拦截 <code>Object.setPrototypeOf(proxy, proto)</code> ，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>
<li><strong>apply(target, object, args)</strong> ：拦截 Proxy (代理) 实例作为函数调用的操作，比如 <code>proxy(...args)</code> 、 <code>proxy.call(object, ...args)</code> 、 <code>proxy.apply(...)</code> 。</li>
<li><strong>construct(target, args)</strong> ：拦截 Proxy (代理) 实例作为构造函数调用的操作，比如 <code>new proxy(...args)</code> 。</li>
</ul>
<p>如果想要详细了解<code>proxy</code>，请移步：</p>
<p><a href="https://link.juejin.cn/?target=https://es6.ruanyifeng.com/%23docs/proxy%23%E6%A6%82%E8%BF%B0">es6.ruanyifeng.com&#x2F;#docs&#x2F;proxy…</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;小花&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只使用get和set进行演示</span></span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="comment">// 读取拦截</span></span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> target[propKey]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 设置拦截</span></span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">target, propKey, value</span>) &#123;</span><br><span class="line">    <span class="comment">// 此处的value为用户设置的新值</span></span><br><span class="line">    target[propKey] = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-一个最简单的响应式"><a href="#3-一个最简单的响应式" class="headerlink" title="3. 一个最简单的响应式"></a>3. 一个最简单的响应式</h3><p>有了<code>proxy</code>，我们就可以根据之前的思路实现一个基本的响应式功能了，我们的思路是这样的：<strong>在对象被读取时把函数收集到一个“仓库”，在对象的值被设置时触发仓库中的函数。</strong></p>
<p>由此我们可以写出一个最基本的响应式功能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个“仓库”，用于存储触发函数</span></span><br><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"><span class="comment">// 使用proxy进行代理</span></span><br><span class="line"><span class="keyword">let</span> data_proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="comment">// 拦截读取操作</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="comment">// 收集依赖函数</span></span><br><span class="line">    store.<span class="title function_">add</span>(effect)</span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 拦截设置操作</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, newVal</span>) &#123;</span><br><span class="line">    target[key] = newVal</span><br><span class="line">    <span class="comment">// 取出所有的依赖函数，执行</span></span><br><span class="line">    store.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们创建了一个用于保存依赖函数的“仓库”，它是<code>Set</code>类型，然后使用<code>proxy</code>对对象<code>data</code>进行代理，设置了<code>set</code>和<code>get</code>拦截函数，用于拦截读取和设置操作，当读取属性时，将依赖函数<code>effect</code>存储到“仓库”中，当设置属性值时，将依赖函数从“仓库”中取出并重新执行。</p>
<p>还有一个小问题，怎么触发对象的读取操作呢？我们可以直接调用一次<code>effect</code>函数，如果在<code>effect</code>函数中存在需要收集的属性，那么执行一次<code>effect</code>函数也是比较符合常理的。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个对象</span></span><br><span class="line">let data = &#123;</span><br><span class="line">  name: <span class="string">&#x27;pino&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let nextVal</span><br><span class="line"><span class="comment">// 待绑定函数</span></span><br><span class="line">function <span class="built_in">effect</span>() &#123;</span><br><span class="line">  <span class="comment">// 依赖函数在这里被收集</span></span><br><span class="line">  <span class="comment">// 当调用data.age时，effect函数被收集到“仓库”中</span></span><br><span class="line">  nextVal = data<span class="selector-class">.age</span> + <span class="number">1</span></span><br><span class="line">  console<span class="selector-class">.log</span>(nextVal)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行依赖函数</span></span><br><span class="line"><span class="built_in">effect</span>() <span class="comment">// 19</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(()=&gt;&#123;</span><br><span class="line">  <span class="comment">// 使用proxy进行代理后，使用代理后的对象名</span></span><br><span class="line">  <span class="comment">// 触发设置操作，此时会取出effect函数进行执行</span></span><br><span class="line">  data_proxy<span class="selector-class">.age</span>++ <span class="comment">// 2秒后输出 20</span></span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一开始会执行一次<code>effect</code>，然后函数两秒钟后会执行代理对象设置操作，再次执行<code>effect</code>函数，输出20。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/256dcd81870a4859b13719ebce24412d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="Jul-24-2022 17-31-39.gif"></p>
<p>此时整个响应式流程的功能是这样的：</p>
<p>阶段一，在属性被读取时，为对象属性收集依赖函数：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5a6f1e8b1a94060878cee2cb388ee10~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p>
<p>阶段二，当属性发生改变时，再次触发依赖函数</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9f81765c42f4943a82d00a17e27cee5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p>
<p>这样就实现了一个最基本的响应式的功能。</p>
<h3 id="4-完善"><a href="#4-完善" class="headerlink" title="4. 完善"></a>4. 完善</h3><p><strong>问题一</strong></p>
<p>其实上面实现的功能还有很大的缺陷，首先最明显的问题是，我们把<code>effect</code>函数给固定了，如果用户使用的依赖函数不叫<code>effect</code>怎么办，显然我们的功能就不能正常运行了。</p>
<p>所以先来进行第一步的优化：<strong>抽离出一个公共方法，依赖函数由用户来传递参数</strong>。</p>
<p>我们使用<code>effect</code>函数来接受用户传递的依赖函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// effect接受一个函数，把这个匿名函数当作依赖函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="comment">// 执行依赖函数</span></span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  nextVal = data.<span class="property">age</span> + <span class="number">1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(nextVal)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是<code>effect</code>函数内部只是执行了，在<code>get</code>函数中怎么能知道用户传递的依赖函数是什么呢，这两个操作并不在一个函数内啊？其实可以使用一个全局变量<code>activeEffect</code>来保存当前正在处理的依赖函数。</p>
<p>修改后的<code>effect</code>函数是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect <span class="comment">// 新增</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="comment">// 保存到全局变量activeEffect</span></span><br><span class="line">  activeEffect = fn <span class="comment">// 新增</span></span><br><span class="line">  <span class="comment">// 执行依赖函数</span></span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而在get内部只需要�收集activeEffect即可</span></span><br><span class="line"><span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  store.<span class="title function_">add</span>(activeEffect)</span><br><span class="line">  <span class="keyword">return</span> target[key]</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调用<code>effect</code>函数传递一个匿名函数作为依赖函数，当执行时，首先会把匿名函数赋值给全局变量<code>activeEffect</code>，然后触发属性的读取操作，进而触发<code>get</code>拦截，将全局变量<code>activeEffect</code>进行收集。</p>
<p><strong>问题二</strong></p>
<p>从上面我们定义的对象可以看到，我们的对象<code>data</code>中有两个属性，上面的例子中我们只给<code>age</code>建立了响应式连接，那么如果我现在也想给<code>name</code>建立响应式连接怎么办呢？那好说，那我们直接向“仓库”中继续添加依赖函数不就行了吗。</p>
<p>其实这会带来很严重的问题，由于 <strong>“仓库”并没有与被操作的目标属性之间建立联系</strong>，而上面我们的实现只是将整个“仓库”遍历了一遍，所以无论哪个属性被触发，都会将“仓库”中所有的依赖函数都取出来执行一遍，因为整个执行程序中可能有很多对象及属性都设置了响应式联系，这将会带来很大的性能浪费。所谓牵一发而动全身，这种结果显然不是我们想要的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;pino&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4381410ee6d1419aa556655569cf4047~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p>
<p>所以我们要重新设计一下“仓库”的数据结构，目的就是为了可以在属性这个粒度下和“仓库”建立明确的联系。</p>
<p>就拿我们上面进行操作的对象来说，存在着两层的结构，有两个角色，对象<code>data</code>以及属性<code>name``age</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;pino&#x27;</span>,</span><br><span class="line"> <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>他们的关系是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">data</span><br><span class="line">       -&gt; name</span><br><span class="line">               -&gt; effectFn</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果两个属性读取了同一个依赖函数</span></span><br><span class="line">data</span><br><span class="line">       -&gt; name</span><br><span class="line">               -&gt; effectFn</span><br><span class="line">       -&gt; age</span><br><span class="line">               -&gt; effectFn</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果两个属性读取了不同的依赖函数</span></span><br><span class="line">data</span><br><span class="line">       -&gt; name</span><br><span class="line">               -&gt; effectFn</span><br><span class="line">       -&gt; age</span><br><span class="line">               -&gt; effectFn1</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是两个不同的对象</span></span><br><span class="line">data</span><br><span class="line">       -&gt; name</span><br><span class="line">               -&gt; effectFn</span><br><span class="line">       -&gt; age</span><br><span class="line">               -&gt; effectFn1</span><br><span class="line">data2</span><br><span class="line">       -&gt; addr</span><br><span class="line">               -&gt; effectFn</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来我们实现一下代码，为了方便调用，将设置响应式数据的操作封装为一个函数<code>reactive</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newObj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="comment">// 读取拦截</span></span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, propKey</span>) &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 设置拦截</span></span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">target, propKey, value</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装为</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="comment">// 读取拦截</span></span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 设置拦截</span></span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">target, propKey, value</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">      <span class="comment">// 收集依赖</span></span><br><span class="line">      <span class="title function_">track</span>(target, key)</span><br><span class="line">      <span class="keyword">return</span> target[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, newVal</span>) &#123;</span><br><span class="line">      target[key] = newVal</span><br><span class="line">      <span class="comment">// 触发依赖</span></span><br><span class="line">      <span class="title function_">trigger</span>(target, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果没有依赖函数，则不需要进行收集。直接return</span></span><br><span class="line">  <span class="keyword">if</span> (!activeEffect) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取target，也就是对象名，对应上面例子中的data</span></span><br><span class="line">  <span class="keyword">let</span> depsMap = store.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    store.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取对象中的key值，对应上面例子中的name或age</span></span><br><span class="line">  <span class="keyword">let</span> deps = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!deps) &#123;</span><br><span class="line">    depsMap.<span class="title function_">set</span>(key, (deps = <span class="keyword">new</span> <span class="title class_">Set</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 收集依赖函数</span></span><br><span class="line">  deps.<span class="title function_">add</span>(activeEffect)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="comment">// 取出对象对应的Map</span></span><br><span class="line">  <span class="keyword">let</span> depsMap = store.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span>(!depsMap) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 取出key所对应的Set</span></span><br><span class="line">  <span class="keyword">let</span> deps = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="comment">// 执行依赖函数</span></span><br><span class="line">  deps &amp;&amp; deps.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们将读取操作封装为了函数<code>track</code>，触发依赖函数的动作封装为了<code>trigger</code>方便调用，现在的整个“仓库”结构是这样的：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7c830761e764e60bdda99b8b685844f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p>
<h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>可能有人会问了，为什么设置“仓库”要使用<code>WeakMap</code>呢，我使用一个普通对象来创建不行吗？ -</p>
<p><code>WeakMap</code> 结构与 <code>Map</code> 结构类似，也是用于生成键值对的集合。</p>
<p><code>WeakMap</code> 与 <code>Map</code> 的区别有两点。</p>
<p>首先， <code>WeakMap</code> 只接受对象作为键名（ <code>null</code> 除外），不接受其他类型的值作为键名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object!</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="title class_">Symbol</span>(), <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中，如果将数值 <code>1</code> 和 <code>Symbol</code> 值作为 WeakMap 的键名，都会报错。</p>
<p>其次， <code>WeakMap</code> 的键名所指向的对象，不计入垃圾回收机制。</p>
<p><code>WeakMap</code> 的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> e1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> e2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">    [e1, <span class="string">&#x27;foo 元素&#x27;</span>],</span><br><span class="line">    [e2, <span class="string">&#x27;bar 元素&#x27;</span>],</span><br><span class="line">];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中， <code>e1</code> 和 <code>e2</code> 是两个对象，我们通过 <code>arr</code> 数组对这两个对象添加一些文字说明。这就形成了 <code>arr</code> 对 <code>e1</code> 和 <code>e2</code> 的引用。</p>
<p>一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放 <code>e1</code> 和 <code>e2</code> 占用的内存。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需要 e1 和 e2 的时候</span></span><br><span class="line"><span class="comment">// 必须手动删除引用</span></span><br><span class="line">arr [<span class="number">0</span>] = <span class="literal">null</span>;</span><br><span class="line">arr [<span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。</p>
<p>它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，<code>WeakMap</code> 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p>
<p>如果我们上文中<code>target</code>对象没有任何引用了，那么说明用户已经不需要用到它了，这时垃圾回收器会自动执行回收，而如果使用<code>Map</code>来进行收集，那么即使其他地方的代码已经对<code>target</code>没有任何引用，这个<code>target</code>也不会被回收。</p>
<h4 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h4><p>在vue3中的实现方式和我们的基本实现还有一点不同就是在vue3中是使用<code>Reflect</code>来操作数据的，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">   <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">     <span class="title function_">track</span>(target, key)</span><br><span class="line">     <span class="comment">// 使用Reflect.get操作读取数据</span></span><br><span class="line">     <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">     <span class="title function_">trigger</span>(target, key)</span><br><span class="line">     <span class="comment">// 使用Reflect.set来操作触发数据</span></span><br><span class="line">     <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么为什么要使用<code>Reflect</code>来操作数据呢，像之前一样直接操作原对象不行吗，我们先来看一下一种特殊的情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">bar</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>effect</code>依赖函数中通过代理对象p访问bar属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">effect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">bar</span>) <span class="comment">// 1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以分析一下这个过程发生了什么，当<code>effect</code>函数被调用时，会读取<code>p.bar</code>属性，他发现<code>p.bar</code>属性是一个访问器属性，因此会执行<code>getter</code>函数，由于在<code>getter</code>函数中通过<code>this.foo</code>读取了<code>foo</code>属性的值，因此我们会认为副作用函数与属性<code>foo</code>之间也会建立联系，当修改<code>p.foo</code>的值的时候因该也能够触发响应，使依赖函数重新执行才对，然而当修改<code>p.foo</code>的时候，并没有触发依赖函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="property">foo</span>++</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际上问题就出在<code>bar</code>属性中的访问器函数<code>getter</code>上：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title function_">bar</span>() &#123;</span><br><span class="line">  <span class="comment">// 这个this究竟指向谁？</span></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当通过代理对象p访问<code>p.bar</code>，这回触发代理对象的<code>get</code>拦截函数执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxt</span>(obj, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="title function_">track</span>(target, key)</span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到在<code>get</code>的拦截函数中，通过<code>target[key]</code>返回属性值，其中<code>target</code>是原始对象<code>obj</code>，而<code>key</code>就是字符串<code>&#39;bar&#39;</code>，所以<code>target[key]</code>就相当于<code>obj.bar</code>。因此当我们使用<code>p.bar</code>访问<code>bar</code>属性时，他的<code>getter</code>函数内的<code>this</code>其实指向原始对象<code>obj</code>，这说明我们最终访问的是<code>obj.foo</code>。所以在依赖函数内部通过原始对象访问他的某个属性是不会建立响应联系的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">effect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// obj是原始数据，不是代理对象，不会建立响应联系</span></span><br><span class="line">  obj.<span class="property">foo</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么怎么解决这个问题呢，这时候就需要用到 <code>Reflect</code>出场了。</p>
<p>先来看一下<code>Reflect</code>是啥：</p>
<p><code>Reflect</code>函数的功能就是提供了访问一个对象属性的默认行为，例如下面两个操作是等价的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接读取</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">foo</span>) <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Reflect.get读取</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">get</span>(obj, <span class="string">&#x27;foo&#x27;</span>)) <span class="comment">// 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际上<code>Reflect.get</code>函数还能接受第三个函数，即制定接受者<code>receiver</code>，可以把它理解为函数调用过程中的<code>this</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">get</span>(obj, <span class="string">&#x27;foo&#x27;</span>, &#123; <span class="attr">foo</span>: <span class="number">2</span> &#125;)) <span class="comment">// 输出的是 2 而不是 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这段代码中，指定了第三个参数receiver为一个对象<code>&#123; foo: 2 &#125;</code>，这是读取到的值时<code>receiver</code>对象的<code>foo</code>属性。</p>
<p>而我们上文中的问题的解决方法就是在操作对象数据的时候通过<code>Reflect</code>的方法来传递第三个参数<code>receiver</code>，它代表谁在读取属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxt</span>(obj, &#123;</span><br><span class="line">  <span class="comment">// 读取属性接收receiver</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="title function_">track</span>(target, key)</span><br><span class="line">    <span class="comment">// 使用Reflect.get返回读取到的属性值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当使用代理对象<code>p</code>访问<code>bar</code>属性时，那么<code>receiver</code>就是p，可以把它理解为函数调用中的<code>this</code>。</p>
<p>所以我们改造一下<code>reactive</code>函数的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">   <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">     <span class="title function_">track</span>(target, key)</span><br><span class="line">     <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">     <span class="title function_">trigger</span>(target, key)</span><br><span class="line">     <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>扩展</strong></p>
<p><strong>Proxy -&gt; get()</strong></p>
<p><code>get</code> 方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 <code>proxy</code> (代理) 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</p>
<p><strong>Reflect.get(target, name, receiver)</strong></p>
<p><code>Reflect.get</code> 方法查找并返回 <code>target</code> 对象的 <code>name</code> 属性，如果没有该属性，则返回 <code>undefined</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line"><span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line"><span class="keyword">get</span> <span class="title function_">baz</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span> + <span class="variable language_">this</span>.<span class="property">bar</span>;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;foo&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;bar&#x27;</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;baz&#x27;</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果 <code>name</code> 属性部署了读取函数（ getter ），则读取函数的 <code>this</code> 绑定 <code>receiver</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line"><span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line"><span class="keyword">get</span> <span class="title function_">baz</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span> + <span class="variable language_">this</span>.<span class="property">bar</span>;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myReceiverObject = &#123;</span><br><span class="line"><span class="attr">foo</span>: <span class="number">4</span>,</span><br><span class="line"><span class="attr">bar</span>: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;baz&#x27;</span>, myReceiverObject) <span class="comment">// 8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果第一个参数不是对象， <code>Reflect.get</code> 方法会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(<span class="number">1</span>, <span class="string">&#x27;foo&#x27;</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(<span class="literal">false</span>, <span class="string">&#x27;foo&#x27;</span>) <span class="comment">// 报错</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Reflect.set(target, name, value, receiver)</strong></p>
<p><code>Reflect.set</code> 方法设置 <code>target</code> 对象的 <code>name</code> 属性等于 <code>value</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line"><span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line"><span class="keyword">set</span> <span class="title function_">bar</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span> = value;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObject.<span class="property">foo</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(myObject, <span class="string">&#x27;foo&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">myObject.<span class="property">foo</span> <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(myObject, <span class="string">&#x27;bar&#x27;</span>, <span class="number">3</span>)</span><br><span class="line">myObject.<span class="property">foo</span> <span class="comment">// 3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果 <code>name</code> 属性设置了赋值函数，则赋值函数的 <code>this</code> 绑定 <code>receiver</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line"><span class="attr">foo</span>: <span class="number">4</span>,</span><br><span class="line"><span class="keyword">set</span> <span class="title function_">bar</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span> = value;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myReceiverObject = &#123;</span><br><span class="line"><span class="attr">foo</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(myObject, <span class="string">&#x27;bar&#x27;</span>, <span class="number">1</span>, myReceiverObject);</span><br><span class="line">myObject.<span class="property">foo</span> <span class="comment">// 4</span></span><br><span class="line">myReceiverObject.<span class="property">foo</span> <span class="comment">// 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，如果 <code>Proxy</code> 对象和 <code>Reflect</code> 对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了 <code>receiver</code> ，那么 <code>Reflect.set</code> 会触发 <code>Proxy.defineProperty</code> 拦截。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = &#123;</span><br><span class="line"><span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line"><span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set&#x27;</span>);</span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">defineProperty</span>(<span class="params">target, key, attribute</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;defineProperty&#x27;</span>);</span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, key, attribute);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(p, handler);</span><br><span class="line">obj.<span class="property">a</span> = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="comment">// set</span></span><br><span class="line"><span class="comment">// defineProperty</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中， <code>Proxy.set</code> 拦截里面使用了 <code>Reflect.set</code> ，而且传入了 <code>receiver</code> ，导致触发 <code>Proxy.defineProperty</code> 拦截。这是因为 <code>Proxy.set</code> 的 <code>receiver</code> 参数总是指向当前的 <code>Proxy</code> 实例（即上例的 <code>obj</code> ），而 <code>Reflect.set</code> 一旦传入 <code>receiver</code> ，就会将属性赋值到 <code>receiver</code> 上面（即 <code>obj</code> ），导致触发 <code>defineProperty</code> 拦截。如果 <code>Reflect.set</code> 没有传入 <code>receiver</code> ，那么就不会触发 <code>defineProperty</code> 拦截。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = &#123;</span><br><span class="line"><span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line"><span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set&#x27;</span>);</span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">defineProperty</span>(<span class="params">target, key, attribute</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;defineProperty&#x27;</span>);</span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, key, attribute);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(p, handler);</span><br><span class="line">obj.<span class="property">a</span> = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="comment">// set</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果第一个参数不是对象， <code>Reflect.set</code> 会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;foo&#x27;</span>, &#123;&#125;) <span class="comment">// 报错</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(<span class="literal">false</span>, <span class="string">&#x27;foo&#x27;</span>, &#123;&#125;) <span class="comment">// 报错</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到这里，一个非常基本的响应式的功能就完成了，整体代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义仓库</span></span><br><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"><span class="comment">// 定义当前处理的依赖函数</span></span><br><span class="line"><span class="keyword">let</span> activeEffect</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="comment">// 将操作包装为一个函数</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">effectFn</span> = (<span class="params"></span>)=&gt; &#123;</span><br><span class="line">    activeEffect = effectFn</span><br><span class="line">    <span class="title function_">fn</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">effectFn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">      <span class="comment">// 收集依赖</span></span><br><span class="line">      <span class="title function_">track</span>(target, key)</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, newVal, receiver</span>) &#123;</span><br><span class="line">      <span class="comment">// 触发依赖</span></span><br><span class="line">      <span class="title function_">trigger</span>(target, key)</span><br><span class="line">      <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newVal, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果没有依赖函数，则不需要进行收集。直接return</span></span><br><span class="line">  <span class="keyword">if</span> (!activeEffect) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取target，也就是对象名</span></span><br><span class="line">  <span class="keyword">let</span> depsMap = store.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    store.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取对象中的key值</span></span><br><span class="line">  <span class="keyword">let</span> deps = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!deps) &#123;</span><br><span class="line">    depsMap.<span class="title function_">set</span>(key, (deps = <span class="keyword">new</span> <span class="title class_">Set</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 收集依赖函数</span></span><br><span class="line">  deps.<span class="title function_">add</span>(activeEffect)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="comment">// 取出对象对应的Map</span></span><br><span class="line">  <span class="keyword">let</span> depsMap = store.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 取出key所对应的Set</span></span><br><span class="line">  <span class="keyword">const</span> effects = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="comment">// 执行依赖函数</span></span><br><span class="line">  <span class="comment">// 为避免污染，创建一个新的Set来进行执行依赖函数</span></span><br><span class="line">  <span class="keyword">let</span> effectsToRun = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"></span><br><span class="line">  effects &amp;&amp; effects.<span class="title function_">forEach</span>(<span class="function"><span class="params">effectFn</span> =&gt;</span> &#123;</span><br><span class="line">      effectsToRun.<span class="title function_">add</span>(effectFn)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  effectsToRun.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> <span class="title function_">effect</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二-嵌套effect"><a href="#二-嵌套effect" class="headerlink" title="二. 嵌套effect"></a>二. 嵌套effect</h2><p>在日常的工作中，<code>effect</code>函数并不是单独存在的，比如在vue的渲染函数中，各个组件之间互相嵌套，那么他们在组件中所使用的<code>effect</code>是必然会发生嵌套的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">effect</span>(<span class="keyword">function</span> <span class="title function_">effectFn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">effect</span>(<span class="keyword">function</span> <span class="title function_">effectFn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当组件中发生嵌套时，此时的渲染函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">effect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="title class_">Father</span>.<span class="title function_">render</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//嵌套子组件</span></span><br><span class="line">  <span class="title function_">effect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title class_">Son</span>.<span class="title function_">render</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是此时我们实现的<code>effect</code>并没有这个能力，执行下面这段代码，并不会出现意料之中的行为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">foo</span>: <span class="string">&#x27;pino&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;在干啥&#x27;</span> &#125;</span><br><span class="line"><span class="comment">// 创建代理对象</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1, p2;</span><br><span class="line"><span class="comment">// 设置obj.foo的依赖函数</span></span><br><span class="line"><span class="title function_">effect</span>(<span class="keyword">function</span> <span class="title function_">effect1</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;effect1执行&#x27;</span>);</span><br><span class="line">  <span class="comment">// 嵌套，obj.bar的依赖函数</span></span><br><span class="line">  <span class="title function_">effect</span>(<span class="keyword">function</span> <span class="title function_">effect2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    p2 = obj.<span class="property">bar</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;effect2执行&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  p1 = obj.<span class="property">foo</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这段代码中，定义了代理对象<code>obj</code>，里面有两个属性<code>foo</code>和<code>bar</code>，然后定义了收集<code>foo</code>的依赖函数，在依赖函数的内部又定义了<code>bar</code>的依赖函数。 在理想状态下，我们希望依赖函数与属性之间的关系如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj</span><br><span class="line">        <span class="punctuation">-&gt;</span> foo</span><br><span class="line">                <span class="punctuation">-&gt;</span> effect1</span><br><span class="line">        <span class="punctuation">-&gt;</span> bar</span><br><span class="line">                <span class="punctuation">-&gt;</span> effect2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当修改<code>obj.foo</code>的值的时候，会触发<code>effect1</code>函数执行，由于<code>effect2</code>函数在<code>effect</code>函数内部，所以<code>effect2</code>函数也会执行，而当修改<code>obj.bar</code>时，只会触发<code>effect2</code>函数。接下来修改一下<code>obj.foo</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">foo</span>: <span class="string">&#x27;pino&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;在干啥&#x27;</span> &#125;</span><br><span class="line"><span class="comment">// 创建代理对象</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1, p2;</span><br><span class="line"><span class="comment">// 设置obj.foo的依赖函数</span></span><br><span class="line"><span class="title function_">effect</span>(<span class="keyword">function</span> <span class="title function_">effect1</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;effect1执行&#x27;</span>);</span><br><span class="line">  <span class="comment">// 嵌套，obj.bar的依赖函数</span></span><br><span class="line">  <span class="title function_">effect</span>(<span class="keyword">function</span> <span class="title function_">effect2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    p2 = obj.<span class="property">bar</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;effect2执行&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  p1 = obj.<span class="property">foo</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改obj.foo的值</span></span><br><span class="line">obj.<span class="property">foo</span> = <span class="string">&#x27;前来买瓜&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看一下执行结果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11ff0565e88140af8381ea563200ca2e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image_1659170045716_0.png"></p>
<p>可以看到<code>effect2</code>函数竟然执行了两次？按照之前的分析，当<code>obj.foo</code>被修改后，应当触发<code>effect1</code>这个依赖函数，但是为什么会<code>effect2</code>会被再次执行呢？ 来看一下我们<code>effect</code>函数的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="comment">// 将依赖函数进行包装</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">effectFn</span> = (<span class="params"></span>)=&gt; &#123;</span><br><span class="line">    activeEffect = effectFn</span><br><span class="line">    <span class="title function_">fn</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">effectFn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实在这里就已经很容易看出问题了，在接受用户传递过来的值时，我们直接将<code>activeEffect</code>这个全局变量进行了覆盖！所以在内部执行完后，<code>activeEffect</code>这个变量就已经是<code>effect2</code>函数了，而且永远不会再次变为<code>effect1</code>，此时再进行收集依赖函数时，永远收集的都是<code>effect2</code>函数。</p>
<p>那么如何解决这种问题呢，这种情况可以借鉴栈结构来进行处理，栈结构是一种后进先出的结构，在依赖函数执行时，将当前的依赖函数压入栈中，等待依赖函数执行完毕后将其从栈中弹出，始终<code>activeEffect</code>指向栈顶的依赖函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加effect调用栈</span></span><br><span class="line"><span class="keyword">const</span> effectStack = [] <span class="comment">// 新增</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> effectFn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    activeEffect = effectFn</span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    effectStack.<span class="title function_">push</span>(effectFn) <span class="comment">// 新增</span></span><br><span class="line">    <span class="comment">// 执行函数的时候进行get收集</span></span><br><span class="line">    <span class="title function_">fn</span>()</span><br><span class="line">    <span class="comment">// 收集完毕后弹出</span></span><br><span class="line">    effectStack.<span class="title function_">pop</span>() <span class="comment">// 新增</span></span><br><span class="line">    <span class="comment">// 始终指向栈顶</span></span><br><span class="line">    activeEffect = effectStack[effectStack.<span class="property">length</span> - <span class="number">1</span>] <span class="comment">// 新增</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">effectFn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6f218c9b130475dab6befbfb873dede~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="未命名.drawio_1659171750374_0.png"></p>
<p>此时两个属性所对应的依赖函数便不会发生错乱了。</p>
<h2 id="三-避免无限循环"><a href="#三-避免无限循环" class="headerlink" title="三. 避免无限循环"></a>三. 避免无限循环</h2><p>如果现在将<code>effect</code>函数中传递的依赖函数改一下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个对象</span></span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;pino&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将data更改为响应式对象</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title function_">reactive</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  obj.<span class="property">age</span>++</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这段代码中，我们将代理对象<code>obj</code>的<code>age</code>属性执行自增操作，但是执行这段代码，却发现竟然栈溢出了？这是怎么回事呢？</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b45cf79a802b45bcbf188a57dd228768~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image_1659163246902_0.png"></p>
<p>其实在<code>effect</code>中处理依赖函数时，<code>obj.age++</code>的操作其实可以看做是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">effect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 等式右边的操作是先执行了一次读取操作</span></span><br><span class="line">  obj.<span class="property">age</span> = obj.<span class="property">age</span> + <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码的执行流程是这样的：首先读取<code>obj.foo</code>的值，这会触发<code>track</code>函数进行收集操作，也就是将当前的依赖函数收集到“仓库”中，接着将其加1后再赋值给<code>obj.foo</code>，此时会触发<code>trigger</code>操作，即把“仓库”中的依赖函数取出并执行。但是此时该依赖函数正在执行中，还没有执行完就要再次开始下一次的执行。就会导致无限的递归调用自己。</p>
<p>解决这个问题，其实只需要在触发函数执行时，判断当前取出的依赖函数是否等于<code>activeEffect</code>，就可以避免重复执行同一个依赖函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="comment">// 取出对象对应的Map</span></span><br><span class="line">  <span class="keyword">let</span> depsMap = store.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 取出key所对应的Set</span></span><br><span class="line">  <span class="keyword">const</span> effects = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="comment">// // 执行依赖函数</span></span><br><span class="line">  <span class="comment">// 因为删除又添加都在同一个deps中，所以会产生无限执行</span></span><br><span class="line">  <span class="keyword">let</span> effectsToRun = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"></span><br><span class="line">  effects &amp;&amp; effects.<span class="title function_">forEach</span>(<span class="function"><span class="params">effectFn</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果trigger出发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行</span></span><br><span class="line">    <span class="keyword">if</span> (effectFn !== activeEffect) &#123;</span><br><span class="line">            effectsToRun.<span class="title function_">add</span>(effectFn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  effectsToRun.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> <span class="title function_">effect</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="四-computed"><a href="#四-computed" class="headerlink" title="四.computed"></a>四.computed</h2><p><code>computed</code>是vue3中的计算属性，它可以根据传入的参数进行响应式的处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> plusOne = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> count.<span class="property">value</span> + <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据<code>computed</code>的用法，我们可以知道它的几个特点：</p>
<ol>
<li>懒执行，值变化时才会触发</li>
<li>缓存功能，如果值没有变化，就会返回上一次的执行结果 在实现这两个核心功能之前，我们先来改造一下之前实现的<code>effect</code>函数。</li>
</ol>
<p>怎么能使<code>effect</code>函数变成懒执行呢，比如计算属性的这种功能，我们不想要他立即执行，而是希望在它需要的时候才执行。</p>
<p>这时候我们可以在<code>effect</code>函数中传递第二个参数，一个对象，用来设置一些额外的功能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">fn, options = &#123;&#125;</span>) &#123; <span class="comment">// 修改</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> effectFn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    activeEffect = effectFn</span><br><span class="line">    effectStack.<span class="title function_">push</span>(effectFn)</span><br><span class="line">    <span class="title function_">fn</span>()</span><br><span class="line">    effectStack.<span class="title function_">pop</span>()</span><br><span class="line">    activeEffect = effectStack[effectStack.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只有当非lazy的时候才直接执行</span></span><br><span class="line">  <span class="keyword">if</span>(!options.<span class="property">lazy</span>) &#123;</span><br><span class="line">    <span class="title function_">effectFn</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将依赖函数组为返回值进行返回</span></span><br><span class="line">  <span class="keyword">return</span> effectFn <span class="comment">// 新增</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这时，如果传递了<code>lazy</code>属性，那么该<code>effect</code>将不会立即执行，需要手动进行执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">foo</span>)</span><br><span class="line">&#125;, &#123; <span class="attr">lazy</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动执行</span></span><br><span class="line"><span class="title function_">effectFn</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是如果我们想要获取手动执行后的值呢，这时只需要在<code>effect</code>函数中将其返回即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">fn, options = &#123;&#125;</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> effectFn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    activeEffect = effectFn</span><br><span class="line">    effectStack.<span class="title function_">push</span>(effectFn)</span><br><span class="line">    <span class="comment">// 保存返回值</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="title function_">fn</span>() <span class="comment">// 新增</span></span><br><span class="line">    effectStack.<span class="title function_">pop</span>()</span><br><span class="line">    activeEffect = effectStack[effectStack.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res <span class="comment">// 新增</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只有当非lazy的时候才直接执行</span></span><br><span class="line">  <span class="keyword">if</span>(!options.<span class="property">lazy</span>) &#123;</span><br><span class="line">    <span class="title function_">effectFn</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将依赖函数组为返回值进行返回</span></span><br><span class="line">  <span class="keyword">return</span> effectFn</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来开始实现<code>computed</code>函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">computed</span>(<span class="params">getter</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个可手动调用的依赖函数</span></span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(getter, &#123;</span><br><span class="line">    <span class="attr">lazy</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 当对象被访问的时候才调用依赖函数</span></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">effectFn</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是此时还做不到对值进行缓存和对比，增加两个变量，一个存储执行的值，另一个为一个开关，表示“是否可以重新执行依赖函数”：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">computed</span>(<span class="params">getter</span>) &#123;</span><br><span class="line">  <span class="comment">// 定义value保存执行结果</span></span><br><span class="line">  <span class="comment">// isRun表示是否需要执行依赖函数</span></span><br><span class="line">  <span class="keyword">let</span> value, isRun = <span class="literal">true</span>; <span class="comment">// 新增</span></span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(getter, &#123;</span><br><span class="line">    <span class="attr">lazy</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">      <span class="comment">// 增加判断，isRun为true时才会重新执行</span></span><br><span class="line">      <span class="keyword">if</span>(isRun) &#123;  <span class="comment">// 新增</span></span><br><span class="line">        <span class="comment">// 保存执行结果</span></span><br><span class="line">        value = <span class="title function_">effectFn</span>() <span class="comment">// 新增</span></span><br><span class="line">        <span class="comment">// 执行完毕后再次重置执行开关</span></span><br><span class="line">        isRun = <span class="literal">false</span> <span class="comment">// 新增</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是上面的实现还有一个问题，就是好像<code>isRun</code>执行一次后好像永远都不会变成<code>true</code>了，我们的本意是在<strong>数据发生变动的时候需要再次触发依赖函数，也就是将isRun变为true</strong>，实现这种效果，需要我们为<code>options</code>再传递一个函数，用于用户自定义的<em>调度执行</em>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">fn, options = &#123;&#125;</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> effectFn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    activeEffect = effectFn</span><br><span class="line">    effectStack.<span class="title function_">push</span>(effectFn)</span><br><span class="line">    <span class="keyword">const</span> res = <span class="title function_">fn</span>() </span><br><span class="line">    effectStack.<span class="title function_">pop</span>()</span><br><span class="line">    activeEffect = effectStack[effectStack.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 挂载用户自定义的调度执行器</span></span><br><span class="line">  effectFn.<span class="property">options</span> = options <span class="comment">// 新增</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!options.<span class="property">lazy</span>) &#123;</span><br><span class="line">    <span class="title function_">effectFn</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effectFn</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来需要修改一下<code>trigger</code>如果传递了<code>scheduler</code>这个函数，那么只执行<code>scheduler</code>这个函数而不执行依赖函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> depsMap = store.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> effects = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">let</span> effectsToRun = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"></span><br><span class="line">  effects &amp;&amp; effects.<span class="title function_">forEach</span>(<span class="function"><span class="params">effectFn</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (effectFn !== activeEffect) &#123;</span><br><span class="line">        effectsToRun.<span class="title function_">add</span>(effectFn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  effectsToRun.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果存在调度器scheduler，那么直接调用该调度器，并将依赖函数进行传递</span></span><br><span class="line">    <span class="keyword">if</span>(effectFn.<span class="property">options</span>.<span class="property">scheduler</span>) &#123; <span class="comment">// 新增</span></span><br><span class="line">      effectFn.<span class="property">options</span>.<span class="title function_">scheduler</span>(effect) <span class="comment">// 新增</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">effect</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么在<code>computed</code>中就可以实现重置执行开关<code>isRun</code>的操作了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">computed</span>(<span class="params">getter</span>) &#123;</span><br><span class="line">  <span class="comment">// 定义value保存执行结果</span></span><br><span class="line">  <span class="comment">// isRun表示是否需要执行依赖函数</span></span><br><span class="line">  <span class="keyword">let</span> value, isRun = <span class="literal">true</span>; <span class="comment">// 新增</span></span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(getter, &#123;</span><br><span class="line">    <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="title function_">scheduler</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!isRun) &#123;</span><br><span class="line">        isRun = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">      <span class="comment">// 增加判断，isRun为true时才会重新执行</span></span><br><span class="line">      <span class="keyword">if</span>(isRun) &#123;  <span class="comment">// 新增</span></span><br><span class="line">        <span class="comment">// 保存执行结果</span></span><br><span class="line">        value = <span class="title function_">effectFn</span>() <span class="comment">// 新增</span></span><br><span class="line">        <span class="comment">// 执行完毕后再次重置执行开关</span></span><br><span class="line">        isRun = <span class="literal">false</span> <span class="comment">// 新增</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当<code>computed</code>传入的依赖函数中的值发生改变时，会触发响应式对象的<code>trigger</code>函数，而计算属性创建响应式对象时传入了<code>scheduler</code>，所以当数据改变时，只会执行<code>scheduler</code>函数，在<code>scheduler</code>函数内我们将执行开关重置为<code>true</code>，再下次访问数据触发<code>get</code>函数时，就会重新执行依赖函数。这也就实现了<em>当数据发生改变时，会再次触发依赖函数</em>的功能了。</p>
<p>为了避免计算属性被另外一个依赖函数调用而失去响应，我们还需要为计算属性单独进行绑定响应式的功能，形成一个<code>effect</code>嵌套。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">computed</span>(<span class="params">getter</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> value, isRun = <span class="literal">true</span>; </span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(getter, &#123;</span><br><span class="line">    <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="title function_">scheduler</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!isRun) &#123;</span><br><span class="line">        isRun = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 当计算属性依赖的响应式数据发生变化时，手动调用trigger函数触发响应</span></span><br><span class="line">        <span class="title function_">trigger</span>(obj, <span class="string">&#x27;value&#x27;</span>) <span class="comment">// 新增</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">      <span class="keyword">if</span>(isRun) &#123; </span><br><span class="line">        value = <span class="title function_">effectFn</span>()</span><br><span class="line">        isRun = <span class="literal">false</span> </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 当读取value时，手动调用track函数进行追踪</span></span><br><span class="line">          <span class="title function_">track</span>(obj, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="五-watch"><a href="#五-watch" class="headerlink" title="五. watch"></a>五. watch</h2><p>先来看一下<code>watch</code>函数的用法，它的用法也非常简单：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>(obj, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(改变了)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改数据，触发watch函数</span></span><br><span class="line">obj.<span class="property">age</span>++</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>watch</code>接受两个参数，第一个参数为绑定的响应式数据，第二个参数为依赖函数，我们依然可以沿用之前的思路来进行处理，利用<code>effect</code>以及<code>scheduler</code>来改变触发执行时机。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">watch</span>(<span class="params">source, fn</span>) &#123;</span><br><span class="line">  <span class="title function_">effect</span>(</span><br><span class="line">    <span class="comment">// 递归读取对象中的每一项，变为响应式数据，绑定依赖函数</span></span><br><span class="line">        <span class="function">()=&gt;</span> <span class="title function_">bindData</span>(source),</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="title function_">scheduler</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 当数据发生改变时，调用依赖函数</span></span><br><span class="line">        <span class="title function_">fn</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// readData保存已读取过的数据，防止重复读取</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bindData</span>(<span class="params">value, readData = <span class="keyword">new</span> <span class="built_in">Set</span>()</span>) &#123;</span><br><span class="line">  <span class="comment">// 此处只考虑对象的情况，如果值已被读取/值不存在/值不为对象，那么直接返回</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> value !== <span class="string">&#x27;object&#x27;</span> || value == <span class="literal">null</span> || readData.<span class="title function_">has</span>(value)) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 保存已读取对象</span></span><br><span class="line">  readData.<span class="title function_">add</span>(value)</span><br><span class="line">  <span class="comment">// 遍历对象</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> value) &#123;</span><br><span class="line">    <span class="comment">// 递归进行读取</span></span><br><span class="line">    <span class="title function_">bindData</span>(value[key], readData)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>watch</code>函数还有另外一种用法，就是除了接收对象，还可以接受一个<code>getter</code>函数，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">    <span class="function">()=&gt;</span> obj.<span class="property">age</span>,</span><br><span class="line">    <span class="function">()=&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;改变了&#x27;</span>)</span><br><span class="line">    &#125; </span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种情况下只需要将用户传入的<code>getter</code>将我们自定义的<code>bindData</code>替代即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">watch</span>(<span class="params">source, fn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> getter = <span class="keyword">typeof</span> source === <span class="string">&#x27;function&#x27;</span> ? source : ((）=&gt; <span class="title function_">bindData</span>(source))</span><br><span class="line"></span><br><span class="line">  <span class="title function_">effect</span>(</span><br><span class="line">    <span class="comment">// 执行getter</span></span><br><span class="line">        <span class="function">()=&gt;</span> <span class="title function_">getter</span>(),</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="title function_">scheduler</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 当数据发生改变时，调用依赖函数</span></span><br><span class="line">        <span class="title function_">fn</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实<code>watch</code>函数还有一个很重要的功能：就是在用户传递的依赖函数中可以获取新值和旧值，但是我们目前还做不到这一点。实现这个功能我们可以配置前文中的<code>lazy</code>属性来实现。 来回顾一下<code>lazy</code>属性：设置了<code>lazy</code>之后一开始不会执行依赖函数，手动执行时会返回执行结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">watch</span>(<span class="params">source, fn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> getter = <span class="keyword">typeof</span> source === <span class="string">&#x27;function&#x27;</span> ? source : ((）=&gt; <span class="title function_">bindData</span>(source))</span><br><span class="line">  <span class="comment">// 定义新值与旧值</span></span><br><span class="line">  <span class="keyword">let</span> newVal, oldVal; <span class="comment">// 新增</span></span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(</span><br><span class="line">    <span class="comment">// 执行getter</span></span><br><span class="line">        <span class="function">()=&gt;</span> <span class="title function_">getter</span>(),</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="title function_">scheduler</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 在scheduler重新执行依赖函数，得到新值</span></span><br><span class="line">        newVal = <span class="title function_">effectFn</span>() <span class="comment">// 新增</span></span><br><span class="line">        <span class="title function_">fn</span>(newVal, oldVal) <span class="comment">// 新增</span></span><br><span class="line">        <span class="comment">// 执行完毕后更新旧值</span></span><br><span class="line">        oldVal = newVal <span class="comment">// 新增</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// 手动调用依赖函数，取得旧值</span></span><br><span class="line">  oldVal = <span class="title function_">effectFn</span>() <span class="comment">// 新增</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此外，<code>watch</code>函数还有一个功能，就是可以自定义执行时机，比如<code>immediate</code>属性，他会在创建时立即执行一次：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>(obj, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;改变了&#x27;</span>)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  <span class="attr">immediate</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以把<code>scheduler</code>封装为一个函数，以便在不同的时机去调用他：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">watch</span>(<span class="params">source, fn, options = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> getter = <span class="keyword">typeof</span> source === <span class="string">&#x27;function&#x27;</span> ? source : ((）=&gt; <span class="title function_">bindData</span>(source))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newVal, oldVal; </span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">run</span> = (<span class="params"></span>) =&gt; &#123; <span class="comment">// 新增</span></span><br><span class="line">    newVal = <span class="title function_">effectFn</span>()</span><br><span class="line">    <span class="title function_">fn</span>(newVal, oldVal)</span><br><span class="line">    oldVal = newVal</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(</span><br><span class="line">        <span class="function">()=&gt;</span> <span class="title function_">getter</span>(),</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 使用run来执行依赖函数</span></span><br><span class="line">      <span class="attr">scheduler</span>: run  <span class="comment">// 修改</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// 当immediate为true时，立即执行一次依赖函数</span></span><br><span class="line">  <span class="keyword">if</span>(options.<span class="property">immediate</span>) &#123; <span class="comment">// 新增</span></span><br><span class="line">    <span class="title function_">run</span>() <span class="comment">// 新增</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    oldVal = <span class="title function_">effectFn</span>() </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>watch</code>函数还支持其他的执行调用时机，这里只实现了<code>immediate</code>。</p>
<h2 id="六-浅响应与深响应"><a href="#六-浅响应与深响应" class="headerlink" title="六. 浅响应与深响应"></a>六. 浅响应与深响应</h2><p>深响应和浅响应的区别：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reatcive</span>(&#123; <span class="attr">foo</span>: &#123; <span class="attr">bar</span>: <span class="number">1</span>&#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">foo</span>.<span class="property">bar</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改obj.foo.bar的值，并不能触发响应</span></span><br><span class="line">obj.<span class="property">foo</span>.<span class="property">bar</span> = <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为之前实现的拦截，无论对于什么类型的数据都是直接进行返回的，如果实现深响应，那么首先应该判断是否为对象类型的值，如果是对象类型的值，应当递归调用<code>reactive</code>方法进行转换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收第二个参数，标记为是否为浅响应</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createReactive</span>(<span class="params">obj, isShallow = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">      <span class="comment">// 访问raw时，返回原对象</span></span><br><span class="line">      <span class="keyword">if</span>(key === <span class="string">&#x27;raw&#x27;</span>) <span class="keyword">return</span> tar<span class="keyword">get</span></span><br><span class="line">      <span class="title function_">track</span>(<span class="params">target, key</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">      <span class="comment">// 如果是浅响应，直接返回值</span></span><br><span class="line">      <span class="keyword">if</span>(isShallow) &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断res是否为对象并且不为null，循环调用reatcive</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> &amp;&amp; res !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reatcive</span>(res)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...省略其他</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将创建响应式对象的方法抽离出去，通过传递<code>isShallow</code>参数来决定是否创建深响应&#x2F;浅响应对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深响应</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactive</span>(obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅响应</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowReactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactive</span>(obj, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="七-浅只读与深只读"><a href="#七-浅只读与深只读" class="headerlink" title="七. 浅只读与深只读"></a>七. 浅只读与深只读</h2><p>有时候我们并不需要对值进行修改，也就是需要值为只读的，这个操作也分为深只读和浅只读，首先需要在<code>createReactive</code>函数中增加一个参数<code>isReadOnly</code>，代表是否为只读属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅只读</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowReadOnly</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactive</span>(obj, <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深只读</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readOnly</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactive</span>(obj, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">set</span>(<span class="params">target, key, newValue, receiver</span>) &#123;</span><br><span class="line">  <span class="comment">// 是否为只读属性，如果是则打印警告信息并直接返回</span></span><br><span class="line">  <span class="keyword">if</span>(isReadOnly) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`属性<span class="subst">$&#123;key&#125;</span>是只读的`</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> oldVal = target[key]</span><br><span class="line">  <span class="keyword">const</span> type = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(target, key) ? triggerType.<span class="property">SET</span> : triggerType.<span class="property">ADD</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newValue, receiver)</span><br><span class="line">  <span class="keyword">if</span> (target === receiver.<span class="property">raw</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldVal !== newValue &amp;&amp; (oldVal === oldVal || newValue === newValue)) &#123;</span><br><span class="line">      <span class="title function_">trigger</span>(target, key, type)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果为只读属性，那么也不需要为其建立响应联系 如果为只读属性，那么在进行深层次遍历的时候，需要调用<code>readOnly</code>函数对值进行包装</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createReactive</span>(<span class="params">obj, isShallow = <span class="literal">false</span>, isReadOnly = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">      <span class="comment">// 访问raw时，返回原对象</span></span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&#x27;raw&#x27;</span>) <span class="keyword">return</span> target</span><br><span class="line"></span><br><span class="line">      <span class="comment">//只有在非只读的时候才需要建立响应联系</span></span><br><span class="line">      <span class="keyword">if</span>(!isReadOnly) &#123;</span><br><span class="line">        <span class="title function_">track</span>(target, key)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">      <span class="comment">// 如果是浅响应，直接返回值</span></span><br><span class="line">      <span class="keyword">if</span> (isShallow) &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断res是否为对象并且不为null，循环调用creative</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> &amp;&amp; res !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果数据为只读，则调用readOnly对值进行包装</span></span><br><span class="line">        <span class="keyword">return</span> isReadOnly ? <span class="title function_">readOnly</span>(res) : <span class="title function_">creative</span>(res)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="八-处理数组"><a href="#八-处理数组" class="headerlink" title="八. 处理数组"></a>八. 处理数组</h2><h3 id="数组的索引与length"><a href="#数组的索引与length" class="headerlink" title="数组的索引与length"></a>数组的索引与length</h3><p>如果操作数组时，设置的索引值大于数组当前的长度，那么要更新数组的<code>length</code>属性，所以当通过索引设置元素值时，可能会隐式的修改<code>length</code>的属性值，因此再j进行触发响应时，也应该触发与<code>length</code>属性相关联的副作用函数重新执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="title function_">reactive</span>([<span class="string">&#x27;foo&#x27;</span>]) <span class="comment">// 数组原来的长度为1</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">length</span>) <span class="comment">//1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置索引为1的值，会导致数组长度变为2</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在判断操作类型时，新增对数组类型的判断，如果代理目标是数组，那么对于操作类型的判断作出处理：</p>
<p>如果设置的索引值小于数组的长度，就视为<code>SET</code>操作，因为他不会改变数组长度，如果设置的索引值大于当前数组的长度，那么应该被视为<code>ADD</code>操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义常量，便于修改</span></span><br><span class="line"><span class="keyword">const</span> triggerType = &#123;</span><br><span class="line">  <span class="attr">ADD</span>: <span class="string">&#x27;add&#x27;</span>,</span><br><span class="line">  <span class="attr">SET</span>: <span class="string">&#x27;set&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">set</span>(<span class="params">target, key, newValue, receiver</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(isReadOnly) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`属性<span class="subst">$&#123;key&#125;</span>是只读的`</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> oldVal = target[key]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果目标对象是数组，检测被设置的索引值是否小于数组长度</span></span><br><span class="line">  <span class="keyword">const</span> type = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) &amp;&amp; (<span class="title class_">Number</span>(key) &gt; target.<span class="property">length</span> ? triggerType.<span class="property">ADD</span> : triggerType.<span class="property">SET</span>)</span><br><span class="line">  <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newValue, receiver)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">trigger</span>(target, key, type)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key, type</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> depsMap = store.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> effects = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">let</span> effectsToRun = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"></span><br><span class="line">  effects &amp;&amp; effects.<span class="title function_">forEach</span>(<span class="function"><span class="params">effectFn</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (effectFn !== activeEffect) &#123;</span><br><span class="line">      effectsToRun.<span class="title function_">add</span>(effectFn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当操作类型是ADD并且目标对象时数组时，应该取出执行那些与 length 属性相关的副作用函数</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) &amp;&amp; type === triggerType.<span class="property">ADD</span>) &#123;</span><br><span class="line">    <span class="comment">// 取出与length相关的副作用函数</span></span><br><span class="line">    <span class="keyword">const</span> lengthEffects = deps.<span class="title function_">get</span>(<span class="string">&#x27;length&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    lengthEffects &amp;&amp; lengthEffects.<span class="title function_">forEach</span>(<span class="function"><span class="params">effectFn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (effectFn !== activeEffect) &#123;</span><br><span class="line">        effectsToRun.<span class="title function_">add</span>(effectFn)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  effectsToRun.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (effectFn.<span class="property">options</span>.<span class="property">scheduler</span>) &#123;</span><br><span class="line">      effectFn.<span class="property">options</span>.<span class="title function_">scheduler</span>(effect)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">effect</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还有一点：其实修改数组的<code>length</code>属性也会隐式的影响数组元素：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="title function_">reactive</span>([<span class="string">&#x27;foo&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 访问数组的第0个元素</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arrr[<span class="number">0</span>]) <span class="comment">// foo</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组的长度修改为0，导致第0个元素被删除，因此应该触发响应</span></span><br><span class="line">arr.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如上所示，在副作用函数内部访问了第0个元素，然后将数组的<code>length</code>属性修改为0，这回隐式的影响数组元素，及所有的元素都会被删除，所以应该触发副作用函数重新执行。</p>
<p>然而并非所有的对<code>length</code>属性值的修改都会影响数组中的已有元素，如果设置的<code>length</code>属性为100，这并不会影响第0个元素，<strong>当修改属性值时，只有那些索引值大于等于新的<code>length</code>属性值的元素才需要触发响应。</strong></p>
<p>调用<code>trigger</code>函数时传入新值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">set</span>(<span class="params">target, key, newValue, receiver</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(isReadOnly) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`属性<span class="subst">$&#123;key&#125;</span>是只读的`</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> oldVal = target[key]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果目标对象是数组，检测被设置的索引值是否小于数组长度</span></span><br><span class="line">  <span class="keyword">const</span> type = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) &amp;&amp; (<span class="title class_">Number</span>(key) &gt; target.<span class="property">length</span> ? triggerType.<span class="property">ADD</span> : triggerType.<span class="property">SET</span>)</span><br><span class="line">  <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newValue, receiver)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将新的值进行传递，及触发响应的新值</span></span><br><span class="line">  <span class="title function_">trigger</span>(target, key, type, newValue) <span class="comment">// 新增</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>判断新的下标值与需要操作的新的下标值进行判断，因为数组的<code>key</code>为下标，所以副作用函数搜集器是以下标作为<code>key</code>值的，当<code>length</code>发生变动时，只需要将新值与每个下标的<code>key</code>判断，大于等于新的<code>length</code>值的需要重新执行副作用函数。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b1e5ceb414c4df389eeff97908ba903~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="未命名绘图.drawio_(2)_1659679803962_0.png"></p>
<p>如上图所示，<code>Map</code>为根据数组的<code>key</code>，也就是<code>id</code>组成的<code>Map</code>结构，他们的每一个<code>key</code>都对应一个<code>Set</code>，用于保存这个<code>key</code>下面的所有的依赖函数。</p>
<p>当<code>length</code>属性发生变动时，应当取出所有<code>key</code>值大于等于<code>length</code>值的所有依赖函数进行执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key, type, newValue</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> depsMap = store.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> effects = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">let</span> effectsToRun = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"></span><br><span class="line">  effects &amp;&amp; effects.<span class="title function_">forEach</span>(<span class="function"><span class="params">effectFn</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (effectFn !== activeEffect) &#123;</span><br><span class="line">      effectsToRun.<span class="title function_">add</span>(effectFn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果操作目标是数组，并且修改了数组的length属性</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) &amp;&amp; key === <span class="string">&#x27;length&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 对于索引值大于或等于新的length元素</span></span><br><span class="line">    <span class="comment">// 需要把所有相关联的副作用函数取出并添加到effectToRun中待执行</span></span><br><span class="line">    depsMap.<span class="title function_">forEach</span>(<span class="function">(<span class="params">effects, key</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">// key 与 newValue均为数组下标，因为数组中key为index</span></span><br><span class="line">      <span class="keyword">if</span>(key &gt;= newValue) &#123;</span><br><span class="line">        effects.<span class="title function_">forEach</span>(<span class="function"><span class="params">effectFn</span>=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (effectFn !== activeEffect) &#123;</span><br><span class="line">            effectsToRun.<span class="title function_">add</span>(effectFn)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>本文的实现数组这种数据结构只考虑了针对长度发生变化的情况。</p>
<h2 id="九-ref"><a href="#九-ref" class="headerlink" title="九. ref"></a>九. ref</h2><p>由于Proxy的代理目标是非原始值，所以没有任何手段去拦截对原始值的操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;hi&#x27;</span></span><br><span class="line"><span class="comment">// 无法拦截对值的修改</span></span><br><span class="line">str = <span class="string">&#x27;pino&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解决方法是：使用一个非原始值去包裹原始值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ref</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个对象对原始值进行包裹</span></span><br><span class="line">  <span class="keyword">const</span> wrapper = &#123;</span><br><span class="line">    <span class="attr">value</span>: val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用reactive函数将包裹对象编程响应式数据并返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">reactive</span>(wrapper)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如何判断是用户传入的对象还是包裹对象呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ref1 = <span class="title function_">ref</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> ref2 = <span class="title function_">reactive</span>(&#123; <span class="attr">value</span>: <span class="number">1</span> &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>只需要在包裹对象内部定义一个不可枚举且不可写的属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ref</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个对象对原始值进行包裹</span></span><br><span class="line">  <span class="keyword">const</span> wrapper = &#123;</span><br><span class="line">    <span class="attr">value</span>: val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义一个属性值__v_isRef，值为true，代表是包裹对象</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(wrapper, <span class="string">&#x27;_isRef&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 使用reactive函数将包裹对象编程响应式数据并返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">reactive</span>(wrapper)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="十-响应丢失问题与toRefs"><a href="#十-响应丢失问题与toRefs" class="headerlink" title="十. 响应丢失问题与toRefs"></a>十. 响应丢失问题与toRefs</h2><p>在使用…解构赋值时会导致响应式丢失：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>(&#123; <span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">bar</span>: <span class="number">2</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将响应式数据展开到一个新的对象newObj</span></span><br><span class="line"><span class="keyword">const</span> newObj = &#123;</span><br><span class="line">  ...obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时相当于：</span></span><br><span class="line"><span class="keyword">const</span> newObj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//在副作用函数中通过新对象newObj读取foo属性值</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newObj.<span class="property">foo</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj,foo并不会触发响应</span></span><br><span class="line">obj.<span class="property">foo</span> = <span class="number">100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先创建一个响应式对象obj，然后使用展开运算符得到一个新对象<code>newObj</code>，他是一个普通对象，不具有响应式的能力，所以修改<code>obj.foo</code>的值不会触发副作用函数重新更新。</p>
<p>解决方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newObj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: &#123;</span><br><span class="line">    <span class="comment">// 用于返回其原始的响应式对象</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> obj.<span class="property">foo</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">bar</span>: &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> obj.<span class="property">bar</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将单个值包装为一个对象，相当于访问该属性的时候会得到该属性的<code>getter</code>，在<code>getter</code>中返回原始的响应式对象。</p>
<p>相当于解构访问<code>newObj.foo</code> &#x3D;&#x3D;&#x3D; <code>obj.foo</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> obj.<span class="property">foo</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toRefs</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line">  <span class="comment">// 处理整个对象时，将属性依次进行遍历，调用toRef进行转化</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    res[key] = <span class="title function_">toRef</span>(obj, key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toRef</span>(<span class="params">obj, key</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = &#123;</span><br><span class="line">    <span class="comment">// 允许读取值</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> obj[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 允许设置值</span></span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">val</span>) &#123;</span><br><span class="line">      obj[key] = val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 标志为ref对象</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(wrapper, <span class="string">&#x27;_isRef&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> wrapper</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用<code>toRefs</code>处理整个对象，在<code>toRefs</code>这个函数中循环处理了对象所包含的所有属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newObj = &#123; ...<span class="title function_">toRefs</span>(obj) &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当设置<code>value</code>属性值的时候，最终设置的是响应式数据的同名属性值。</p>
<p>一个基本的<code>vue3</code>响应式就完成了，但是本文所实现的依然是阉割版本，有很多情况都没有进行考虑，还有好多功能没有实现，比如：拦截 <code>Map</code>，<code>Set</code>，数组的其他问题，对象的其他问题，其他api的实现，但是上面的实现已经足够让你理解vue3响应式原理实现的核心了，这里还有很多其他的资料需要推荐，比如阮一峰老师的es6教程，对于vue3底层原理的实现，许多知识依然是需要回顾和复习，查看原始底层的实现，再比如霍春阳老师的《vue.js的设计与实现》这本书，这本书目前我也只看完了一半，但是截止到目前我认为这本书对于学习<code>vue3</code>的原理是非常深入浅出，鞭辟入里的，本文的许多例子也是借鉴了这本书。</p>
<p>最后当然是需要取读一读源码，不过在读源码之前能够先了解一下实现的核心原理，再去看源码是事半功倍的。希望大家都能早日学透源码，面试的时候能够对答如流，工作中遇到的问题也能从原理层面去理解和更好地解决！</p>
<p>目前我也在实现一个<code>mini-vue</code>，截止到目前只实现了响应式部分，而且与本文的实现方式有所不同，后续还会继续实现编译和虚拟DOM部分，欢迎star！👇</p>
<p><a href="https://link.juejin.cn/?target=https://github.com/konvyi/k-vue">k-vue</a></p>
<p>如果想学习《vue.js的设计与实现》这本书这本书，那么请关注下面这个链接👇作为参考，里面包含了根据具体的问题的功能进行拆分实现，同样也只实现了响应式的部分！</p>
<p><a href="https://link.juejin.cn/?target=https://github.com/konvyi/vue3-analysis">vue3-analysis</a></p>
<p><strong>实现一个mini-vue系列文章</strong></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7102217959669497887">超详细整理vue3基础知识💥</a></p>
<p><strong>写在最后</strong> ⛳</p>
<p>未来可能会更新实现<code>mini-vue3</code>和<code>javascript</code>基础知识系列，希望能一直坚持下去，期待多多点赞🤗🤗，一起进步！🥳🥳</p>
<p><strong>本文参考</strong></p>
<p><a href="https://link.juejin.cn/?target=https://es6.ruanyifeng.com/%23docs/proxy">es6.ruanyifeng.com&#x2F;#docs&#x2F;proxy</a></p>
<p><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;…</a></p>
<p><a href="https://link.juejin.cn/?target=https://book.douban.com/subject/35768338/">book.douban.com&#x2F;subject&#x2F;357…</a></p>
<p>出处<br>作者：小黄瓜没有刺<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7129644396533776420">https://juejin.cn/post/7129644396533776420</a><br>来源：稀土掘金</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://leejs.cn">李鹏辉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://leejs.cn/82750b40/">https://leejs.cn/82750b40/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://leejs.cn" target="_blank">Lee Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/vue3/">vue3</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/">数据双向绑定</a></div><div class="post_share"><div class="social-share" data-image="https://images-origin.wallwiz.link/58860b456e9f6a00013b8f0f_1" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/aa6a8b54/"><img class="prev-cover" src="https://images-origin.wallwiz.link/58860c5cdc1d3f00010acee5_1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">好文 可复制的沟通力</div></div></a></div><div class="next-post pull-right"><a href="/cd70c25c/"><img class="next-cover" src="https://images-origin.wallwiz.link/58860cbe6e9f6a00013b9112_1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">常见数据分析模型</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/8aca716b/" title="VUE3 项目搭建"><img class="cover" src="https://images-origin.wallwiz.link/59c13323c6a7580001cc9bfd_1" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-23</div><div class="title">VUE3 项目搭建</div></div></a></div><div><a href="/9a3c1b5f/" title="vue3 API学习列表"><img class="cover" src="https://images-origin.wallwiz.link/58860e926e9f6a00013b9386_1" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-02</div><div class="title">vue3 API学习列表</div></div></a></div><div><a href="/1342917158/" title="vue3 watch 理解"><img class="cover" src="https://images-origin.wallwiz.link/58860cbe6e9f6a00013b9112_1" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-12</div><div class="title">vue3 watch 理解</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">李鹏辉</div><div class="author-info__description">学习 生活 成长</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%96%84%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">一. 实现一个完善的响应式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Object-defineProperty"><span class="toc-number">2.1.</span> <span class="toc-text">1. Object.defineProperty()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Proxy"><span class="toc-number">2.2.</span> <span class="toc-text">2. Proxy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">3. 一个最简单的响应式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AE%8C%E5%96%84"><span class="toc-number">2.4.</span> <span class="toc-text">4. 完善</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WeakMap"><span class="toc-number">2.4.1.</span> <span class="toc-text">WeakMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reflect"><span class="toc-number">2.4.2.</span> <span class="toc-text">Reflect</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%B5%8C%E5%A5%97effect"><span class="toc-number">3.</span> <span class="toc-text">二. 嵌套effect</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E9%81%BF%E5%85%8D%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.</span> <span class="toc-text">三. 避免无限循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-computed"><span class="toc-number">5.</span> <span class="toc-text">四.computed</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-watch"><span class="toc-number">6.</span> <span class="toc-text">五. watch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E6%B5%85%E5%93%8D%E5%BA%94%E4%B8%8E%E6%B7%B1%E5%93%8D%E5%BA%94"><span class="toc-number">7.</span> <span class="toc-text">六. 浅响应与深响应</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E6%B5%85%E5%8F%AA%E8%AF%BB%E4%B8%8E%E6%B7%B1%E5%8F%AA%E8%AF%BB"><span class="toc-number">8.</span> <span class="toc-text">七. 浅只读与深只读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84"><span class="toc-number">9.</span> <span class="toc-text">八. 处理数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%8Elength"><span class="toc-number">9.1.</span> <span class="toc-text">数组的索引与length</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D-ref"><span class="toc-number">10.</span> <span class="toc-text">九. ref</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81-%E5%93%8D%E5%BA%94%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E4%B8%8EtoRefs"><span class="toc-number">11.</span> <span class="toc-text">十. 响应丢失问题与toRefs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#toRefs"><span class="toc-number">11.1.</span> <span class="toc-text">toRefs</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/5feabfc2/" title="浏览器indexDB"><img src="https://images-origin.wallwiz.link/58860f026e9f6a00013b9428_1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="浏览器indexDB"/></a><div class="content"><a class="title" href="/5feabfc2/" title="浏览器indexDB">浏览器indexDB</a><time datetime="2024-03-07T11:59:05.000Z" title="发表于 2024-03-07 19:59:05">2024-03-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/37cd135e/" title="关于浏览器缓存"><img src="https://images-origin.wallwiz.link/58860ead6e9f6a00013b93b1_1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于浏览器缓存"/></a><div class="content"><a class="title" href="/37cd135e/" title="关于浏览器缓存">关于浏览器缓存</a><time datetime="2024-03-07T11:42:59.000Z" title="发表于 2024-03-07 19:42:59">2024-03-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/a3f55816/" title="理想国 第一卷"><img src="https://images-origin.wallwiz.link/58860f026e9f6a00013b9428_1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="理想国 第一卷"/></a><div class="content"><a class="title" href="/a3f55816/" title="理想国 第一卷">理想国 第一卷</a><time datetime="2023-12-01T07:55:06.000Z" title="发表于 2023-12-01 15:55:06">2023-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/34588bfd/" title="TS 基础中的基础"><img src="https://images-origin.wallwiz.link/58860e96dc1d3f00010ad1e2_1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TS 基础中的基础"/></a><div class="content"><a class="title" href="/34588bfd/" title="TS 基础中的基础">TS 基础中的基础</a><time datetime="2023-12-01T03:38:30.000Z" title="发表于 2023-12-01 11:38:30">2023-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2fe79698/" title="canvas VS WebGL"><img src="https://images-origin.wallwiz.link/59c13437ccb8f80001ef65ea_1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="canvas VS WebGL"/></a><div class="content"><a class="title" href="/2fe79698/" title="canvas VS WebGL">canvas VS WebGL</a><time datetime="2023-11-01T11:13:19.000Z" title="发表于 2023-11-01 19:13:19">2023-11-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 李鹏辉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>