<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>js 数据结构 | Lee Blog</title><meta name="keywords" content="js"><meta name="author" content="李鹏辉,ahuinet@163.com"><meta name="copyright" content="李鹏辉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、前言首先，为什么我会学习数据结构与算法呢，其实主要是有两方面  第一，是我在今年的flag里明确说到我会学这个东西 第二，学了这些，对自己以后在工作或者面试也会带来许多好处  然后，本文是最近学习的一个总结文章，文中的算法题，大部分都是leetcode中的，如不太理解题意，可直接去leetcode中找到对应的题。 二、基本概念常常听到算法的时候，就会有人说到 时间复杂度， 空间复杂度。那么这俩">
<meta property="og:type" content="article">
<meta property="og:title" content="js 数据结构">
<meta property="og:url" content="https://leejs.cn/abd146cd/index.html">
<meta property="og:site_name" content="Lee Blog">
<meta property="og:description" content="一、前言首先，为什么我会学习数据结构与算法呢，其实主要是有两方面  第一，是我在今年的flag里明确说到我会学这个东西 第二，学了这些，对自己以后在工作或者面试也会带来许多好处  然后，本文是最近学习的一个总结文章，文中的算法题，大部分都是leetcode中的，如不太理解题意，可直接去leetcode中找到对应的题。 二、基本概念常常听到算法的时候，就会有人说到 时间复杂度， 空间复杂度。那么这俩">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images-origin.wallwiz.link/59c13437ccb8f80001ef65ea_1">
<meta property="article:published_time" content="2023-09-18T06:24:52.000Z">
<meta property="article:modified_time" content="2023-09-18T06:26:31.832Z">
<meta property="article:author" content="李鹏辉">
<meta property="article:tag" content="js">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images-origin.wallwiz.link/59c13437ccb8f80001ef65ea_1"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://leejs.cn/abd146cd/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'js 数据结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-18 14:26:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> Media</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-image"></i><span> Gallery</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://images-origin.wallwiz.link/59c13437ccb8f80001ef65ea_1')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lee Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> Media</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-image"></i><span> Gallery</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">js 数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-18T06:24:52.000Z" title="发表于 2023-09-18 14:24:52">2023-09-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-18T06:26:31.832Z" title="更新于 2023-09-18 14:26:31">2023-09-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="js 数据结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h1><p>首先，为什么我会学习数据结构与算法呢，其实主要是有两方面</p>
<ul>
<li>第一，是我在今年的flag里明确说到我会学这个东西</li>
<li>第二，学了这些，对自己以后在工作或者面试也会带来许多好处</li>
</ul>
<p>然后，本文是最近学习的一个<code>总结文章</code>，文中的算法题，<strong>大部分都是leetcode中</strong>的，如不太理解题意，可直接去leetcode中找到对应的题。</p>
<h1 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a><strong>二、基本概念</strong></h1><p>常常听到算法的时候，就会有人说到 <strong>时间复杂度</strong>， <strong>空间复杂度</strong>。那么这俩玩意是啥呢，下面我们就来一一解释</p>
<h2 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1. 时间复杂度"></a>1. 时间复杂度</h2><p>其实就是一个函数，用大 O 表示， 比如 O(1)、 O(n)…</p>
<p>它的作用就是用来<code>定义描述算法的运行时间</code></p>
<ul>
<li><strong>O(1)</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let i = 0</span><br><span class="line">i += 1</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>O(n)：</strong> 如果是 O(1) + O(n) 则还是 O(n)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; n; i += 1) &#123;</span><br><span class="line">  console.log(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>O(n^2)：</strong> O(n) * O(n), 也就是双层循环，自此类推：O(n^3)…</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; n; i += 1) &#123;</span><br><span class="line">  for (let j = 0; j &lt; n; j += 1) &#123;</span><br><span class="line">    console.log(i, j)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>O(logn)：</strong> 就是求 log 以 2 为底的多少次方等于 n</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 这个例子就是求2的多少次方会大于i，然后就会结束循环。 这就是一个典型的 O(logn)</span><br><span class="line">let i = 1</span><br><span class="line">while (i &lt; n) &#123;</span><br><span class="line">  console.log(i)</span><br><span class="line">  i *= 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-空间复杂度"><a href="#2-空间复杂度" class="headerlink" title="2. 空间复杂度"></a>2. 空间复杂度</h2><p>和时间复杂度一样，空间复杂度也是用大 O 表示，比如 O(1)、 O(n)…</p>
<p>它用来<code>定义描述算法运行过程中临时占用的存储空间大小</code></p>
<blockquote>
<p>占用越少 代码写的就越好</p>
</blockquote>
<ul>
<li><strong>O(1)：</strong> 单个变量，所以占用永远是 O(1)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let i = 0</span><br><span class="line">i += 1</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>O(n)：</strong> 声明一个数组， 添加 n 个值， 相当于占用了 n 个空间单元</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const arr = []</span><br><span class="line">for (let i = 0; i &lt; n; i += 1) &#123;</span><br><span class="line">  arr.push(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>O(n^2)：</strong> 类似一个矩阵的概念，就是二维数组的意思</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const arr = []</span><br><span class="line">for (let i = 0; i &lt; n; i += 1) &#123;</span><br><span class="line">  arr.push([])</span><br><span class="line">  for (let j = 0; j &lt; n; j += 1) &#123;</span><br><span class="line">    arr[i].push(j)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、数据结构"><a href="#三、数据结构" class="headerlink" title="三、数据结构"></a><strong>三、数据结构</strong></h1><h2 id="1-栈"><a href="#1-栈" class="headerlink" title="1. 栈"></a>1. 栈</h2><p>一个<code>后进先出</code>的数据结构</p>
<p>按照常识理解就是有序的挤公交，<strong>最后上车</strong>的人会在门口，然后门口的人会<strong>最先下车</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQTBMt0dgTbnFELuibCicYdN0tVb5QfqG2dU3S4k7nN34FXiaARTpia5hqcshP5ia987ib3tmqSBDgeWPaSA/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<blockquote>
<p>js中没有栈的数据类型，但我们可以通过<strong>Array来模拟一个</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const stack = [];</span><br><span class="line"></span><br><span class="line">stack.push(1); // 入栈</span><br><span class="line">stack.push(2); // 入栈</span><br><span class="line"></span><br><span class="line">const item1 = stack.pop();  //出栈的元素</span><br></pre></td></tr></table></figure>

<h3 id="1）十进制转二进制"><a href="#1）十进制转二进制" class="headerlink" title="1）十进制转二进制"></a>1）十进制转二进制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度 O(n) n为二进制的长度</span><br><span class="line">// 空间复杂度 O(n) n为二进制的长度</span><br><span class="line">const dec2bin = (dec) =&gt; &#123;</span><br><span class="line">  // 创建一个字符串</span><br><span class="line">  let res = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">  // 创建一个栈</span><br><span class="line">  let stack = []</span><br><span class="line"></span><br><span class="line">  // 遍历数字 如果大于0 就可以继续转换2进制</span><br><span class="line">  while (dec &gt; 0) &#123;</span><br><span class="line">    // 将数字的余数入栈</span><br><span class="line">    stack.push(dec % 2);</span><br><span class="line"></span><br><span class="line">    // 除以2</span><br><span class="line">    dec = dec &gt;&gt; 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 取出栈中的数字</span><br><span class="line">  while (stack.length) &#123;</span><br><span class="line">    res += stack.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 返回这个字符串</span><br><span class="line">  return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2）判断字符串的有效括号"><a href="#2）判断字符串的有效括号" class="headerlink" title="2）判断字符串的有效括号"></a>2）判断字符串的有效括号</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度O(n) n为s的length</span><br><span class="line">// 空间复杂度O(n)</span><br><span class="line">const isValid = (s) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  // 如果长度不等于2的倍数肯定不是一个有效的括号</span><br><span class="line">  if (s.length % 2 === 1) return false;</span><br><span class="line"></span><br><span class="line">  // 创建一个栈</span><br><span class="line">  let stack = [];</span><br><span class="line"></span><br><span class="line">  // 遍历字符串</span><br><span class="line">  for (let i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    const c = s[i];</span><br><span class="line"></span><br><span class="line">    // 如果是左括号就入栈</span><br><span class="line">    if (c === &#x27;(&#x27; || c === &quot;&#123;&quot; || c === &quot;[&quot;) &#123;</span><br><span class="line">      stack.push(c);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      // 如果不是左括号 且栈为空 肯定不是一个有效的括号 返回false</span><br><span class="line">      if (!stack.length) return false</span><br><span class="line"></span><br><span class="line">      // 拿到最后一个左括号</span><br><span class="line">      const top = stack[stack.length - 1];</span><br><span class="line"></span><br><span class="line">      // 如果是右括号和左括号能匹配就出栈</span><br><span class="line">      if ((top === &quot;(&quot; &amp;&amp; c === &quot;)&quot;) || (top === &quot;&#123;&quot; &amp;&amp; c === &quot;&#125;&quot;) || (top === &quot;[&quot; &amp;&amp; c === &quot;]&quot;)) &#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        // 否则就不是一个有效的括号</span><br><span class="line">        return false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  return stack.length === 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-队列"><a href="#2-队列" class="headerlink" title="2. 队列"></a>2. 队列</h2><p>和栈相反 <code>先进先出</code>的一个数据结构</p>
<p>按照常识理解就是银行排号办理业务, <strong>先去</strong>领号排队的人, <strong>先办理</strong>业务</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQTBMt0dgTbnFELuibCicYdN0toJqJs70SlmSGjIsHZ9dcv08m0icTXiaQv5ub7NFLhofg7WpJsReLVNyw/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<blockquote>
<p>同样 js中没有栈的数据类型，但我们可以通过 <strong>Array来模拟一个</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const queue = [];</span><br><span class="line"></span><br><span class="line">// 入队</span><br><span class="line">queue.push(1);</span><br><span class="line">queue.push(2);</span><br><span class="line"></span><br><span class="line">// 出队</span><br><span class="line">const first = queue.shift();</span><br><span class="line">const end = queue.shift();</span><br></pre></td></tr></table></figure>

<h3 id="1）最近的请求次数"><a href="#1）最近的请求次数" class="headerlink" title="1）最近的请求次数"></a>1）最近的请求次数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var RecentCounter = function () &#123;</span><br><span class="line">  // 初始化队列</span><br><span class="line">  this.q = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 输入 inputs = [[],[1],[100],[3001],[3002]] 请求间隔为 3000ms</span><br><span class="line">// 输出 outputs = [null,1,2,3,3]   </span><br><span class="line"></span><br><span class="line">// 时间复杂度 O(n) n为剔出老请求的长度</span><br><span class="line">// 空间复杂度 O(n) n为最近请求的次数</span><br><span class="line">RecentCounter.prototype.ping = function (t) &#123;</span><br><span class="line">  // 如果传入的时间小于等于最近请求的时间，则直接返回0</span><br><span class="line">  if (!t) return null</span><br><span class="line"></span><br><span class="line">  // 将传入的时间放入队列</span><br><span class="line">  this.q.push(t);</span><br><span class="line"></span><br><span class="line">  // 如果队头小于 t - 3000 则剔除队头</span><br><span class="line">  while (this.q[0] &lt; t - 3000) &#123;</span><br><span class="line">    this.q.shift();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 返回最近请求的次数</span><br><span class="line">  return this.q.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-链表"><a href="#3-链表" class="headerlink" title="3. 链表"></a>3. 链表</h2><p>多个元素组成的列表，元素存储不连续，<code>通过 next 指针来链接</code>, 最底层为 null</p>
<p>就类似于 <strong>父辈链接关系</strong> 吧， 比如：你爷爷的儿子是你爸爸，你爸爸的儿子是你，而你假如目前还没有结婚生子，那你就暂时木有儿子</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQTBMt0dgTbnFELuibCicYdN0tBIUnQo2nKvvIic7YsM4Kr7jjqVNMSyjN4a2NqRiaY9lbM4BkeBrHz1Og/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<blockquote>
<p>js中类似于链表的典型就是原型链, 但是js中没有链表这种数据结构，我们可以通过一个<strong>object来模拟链表</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">const a = &#123;</span><br><span class="line">  val: &quot;a&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const b = &#123;</span><br><span class="line">  val: &quot;b&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const c = &#123;</span><br><span class="line">  val: &quot;c&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const d = &#123;</span><br><span class="line">  val: &quot;d&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.next = b;</span><br><span class="line">b.next = c;</span><br><span class="line">c.next = d;</span><br><span class="line"></span><br><span class="line">// const linkList = &#123;</span><br><span class="line">//    val: &quot;a&quot;,</span><br><span class="line">//    next: &#123;</span><br><span class="line">//        val: &quot;b&quot;,</span><br><span class="line">//        next: &#123;</span><br><span class="line">//            val: &quot;c&quot;,</span><br><span class="line">//            next: &#123;</span><br><span class="line">//                val: &quot;d&quot;,</span><br><span class="line">//                next: null</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;</span><br><span class="line">//    &#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// 遍历链表</span><br><span class="line">let p = a;</span><br><span class="line">while (p) &#123;</span><br><span class="line">  console.log(p.val);</span><br><span class="line">  p = p.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 插入</span><br><span class="line">const e = &#123; val: &#x27;e&#x27; &#125;;</span><br><span class="line">c.next = e;</span><br><span class="line">e.next = d;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 删除</span><br><span class="line">c.next = d;</span><br></pre></td></tr></table></figure>

<h3 id="1）手写instanceOf"><a href="#1）手写instanceOf" class="headerlink" title="1）手写instanceOf"></a>1）手写instanceOf</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const myInstanceOf = (A, B) =&gt; &#123;</span><br><span class="line">  // 声明一个指针</span><br><span class="line">  let p = A;</span><br><span class="line">  </span><br><span class="line">  // 遍历这个链表</span><br><span class="line">  while (p) &#123;</span><br><span class="line">    if (p === B.prototype) return true;</span><br><span class="line">    p = p.__proto__;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myInstanceOf([], Object)</span><br></pre></td></tr></table></figure>

<h3 id="2）删除链表中的节点"><a href="#2）删除链表中的节点" class="headerlink" title="2）删除链表中的节点"></a>2）删除链表中的节点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂和空间复杂度都是 O(1)</span><br><span class="line">const deleteNode = (node) =&gt; &#123;</span><br><span class="line">  // 把当前链表的指针指向下下个链表的值就可以了</span><br><span class="line">  node.val = node.next.val;</span><br><span class="line">  node.next = node.next.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3）删除排序链表中的重复元素"><a href="#3）删除排序链表中的重复元素" class="headerlink" title="3）删除排序链表中的重复元素"></a>3）删除排序链表中的重复元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 3 </span><br><span class="line">// 1 -&gt; 2 -&gt; 3 -&gt; null</span><br><span class="line"></span><br><span class="line">// 时间复杂度 O(n) n为链表的长度</span><br><span class="line">// 空间复杂度 O(1)</span><br><span class="line">const deleteDuplicates = (head) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  // 创建一个指针</span><br><span class="line">  let p = head;</span><br><span class="line"></span><br><span class="line">  // 遍历链表</span><br><span class="line">  while (p &amp;&amp; p.next) &#123;</span><br><span class="line"></span><br><span class="line">    // 如果当前节点的值等于下一个节点的值</span><br><span class="line">    if (p.val === p.next.val) &#123;</span><br><span class="line"></span><br><span class="line">      // 删除下一个节点</span><br><span class="line">      p.next = p.next.next</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      // 否则继续遍历</span><br><span class="line">      p = p.next</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //  最后返回原来链表</span><br><span class="line">  return head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4）反转链表"><a href="#4）反转链表" class="headerlink" title="4）反转链表"></a>4）反转链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null</span><br><span class="line">// 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; null</span><br><span class="line"></span><br><span class="line">// 时间复杂度 O(n) n为链表的长度</span><br><span class="line">// 空间复杂度 O(1)</span><br><span class="line">var reverseList = function (head) &#123;</span><br><span class="line"></span><br><span class="line">  // 创建一个指针</span><br><span class="line">  let p1 = head;</span><br><span class="line"></span><br><span class="line">  // 创建一个新指针</span><br><span class="line">  let p2 = null;</span><br><span class="line"></span><br><span class="line">  // 遍历链表</span><br><span class="line">  while (p1) &#123;</span><br><span class="line"></span><br><span class="line">    // 创建一个临时变量</span><br><span class="line">    const tmp = p1.next;</span><br><span class="line"></span><br><span class="line">    // 将当前节点的下一个节点指向新链表</span><br><span class="line">    p1.next = p2;</span><br><span class="line"></span><br><span class="line">    // 将新链表指向当前节点</span><br><span class="line">    p2 = p1;</span><br><span class="line"></span><br><span class="line">    // 将当前节点指向临时变量</span><br><span class="line">    p1 = tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 最后返回新的这个链表</span><br><span class="line">  return p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverseList(list</span><br></pre></td></tr></table></figure>

<h2 id="4-集合"><a href="#4-集合" class="headerlink" title="4. 集合"></a>4. 集合</h2><p>一种<code>无序且唯一</code>的数据结构</p>
<blockquote>
<p>ES6中有集合 <strong>Set类型</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 1, 1, 2, 2, 3];</span><br><span class="line"></span><br><span class="line">// 去重</span><br><span class="line">const arr2 = [...new Set(arr)];</span><br><span class="line"></span><br><span class="line">// 判断元素是否在集合中</span><br><span class="line">const set = new Set(arr);</span><br><span class="line">set.has(2) // true</span><br><span class="line"></span><br><span class="line">//  交集</span><br><span class="line">const set2 = new Set([1, 2]);</span><br><span class="line">const set3 = new Set([...set].filter(item =&gt; set.has(item)));</span><br></pre></td></tr></table></figure>

<h3 id="1）去重"><a href="#1）去重" class="headerlink" title="1）去重"></a>1）去重</h3><p>具体代码在上面介绍中有写过，就不再重写了</p>
<h3 id="2）两个数组的交集"><a href="#2）两个数组的交集" class="headerlink" title="2）两个数组的交集"></a>2）两个数组的交集</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度 O(n^2) n为数组长度</span><br><span class="line">// 空间复杂度 O(n)  n为去重后的数组长度</span><br><span class="line">const intersection = (nums1, nums2) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  // 通过数组的filter选出交集</span><br><span class="line">  // 然后通过 Set集合 去重 并生成数组</span><br><span class="line">  return [...new Set(nums1.filter(item =&gt; nums2.includes(item)))];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-字典"><a href="#5-字典" class="headerlink" title="5. 字典"></a>5. 字典</h2><p>与集合类似，<code>一个存储唯一值</code>的结构,以<code>键值对</code>的形式存储</p>
<blockquote>
<p>js中有字典数据结构 就是 <strong>Map 类型</strong></p>
</blockquote>
<h3 id="1）两数之和"><a href="#1）两数之和" class="headerlink" title="1）两数之和"></a>1）两数之和</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// nums = [2, 7, 11, 15] target = 9</span><br><span class="line"></span><br><span class="line">// 时间复杂度O(n) n为nums的length</span><br><span class="line">// 空间复杂度O(n)</span><br><span class="line">var twoSum = function (nums, target) &#123;</span><br><span class="line"></span><br><span class="line">  // 建立一个字典数据结构来保存需要的值</span><br><span class="line">  const map = new Map();</span><br><span class="line">  for (let i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">  </span><br><span class="line">    // 获取当前的值，和需要的值</span><br><span class="line">    const n = nums[i];</span><br><span class="line">    const n2 = target - n;</span><br><span class="line">    </span><br><span class="line">    // 如字典中有需要的值，就匹配成功</span><br><span class="line">    if (map.has(n2)) &#123;</span><br><span class="line">      return [map.get(n2), i];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    </span><br><span class="line">    // 如没有，则把需要的值添加到字典中</span><br><span class="line">      map.set(n, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2）两个数组的交集-1"><a href="#2）两个数组的交集-1" class="headerlink" title="2）两个数组的交集"></a>2）两个数组的交集</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">// 输出：[2]</span><br><span class="line"></span><br><span class="line">// 时间复杂度 O(m + n) m为nums1长度 n为nums2长度</span><br><span class="line">// 空间复杂度 O(m) m为交集的数组长度</span><br><span class="line">const intersection = (nums1, nums2) =&gt; &#123;</span><br><span class="line">  // 创建一个字典</span><br><span class="line">  const map = new Map();</span><br><span class="line"></span><br><span class="line">  // 将数组1中的数字放入字典</span><br><span class="line">  nums1.forEach(n =&gt; map.set(n, true));</span><br><span class="line"></span><br><span class="line">  // 创建一个新数组</span><br><span class="line">  const res = [];</span><br><span class="line"></span><br><span class="line">  // 将数组2遍历 并判断是否在字典中</span><br><span class="line">  nums2.forEach(n =&gt; &#123;</span><br><span class="line">    if (map.has(n)) &#123;</span><br><span class="line">      res.push(n);</span><br><span class="line"></span><br><span class="line">      // 如果在字典中，则删除该数字</span><br><span class="line">      map.delete(n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3）字符的有效的括号"><a href="#3）字符的有效的括号" class="headerlink" title="3）字符的有效的括号"></a>3）字符的有效的括号</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 用字典优化</span><br><span class="line"></span><br><span class="line">// 时间复杂度 O(n) n为s的字符长度</span><br><span class="line">// 空间复杂度 O(n) </span><br><span class="line">const isValid = (s) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  // 如果长度不等于2的倍数肯定不是一个有效的括号</span><br><span class="line">  if (s.length % 2 !== 0) return false</span><br><span class="line"></span><br><span class="line">  // 创建一个字典</span><br><span class="line">  const map = new Map();</span><br><span class="line">  map.set(&#x27;(&#x27;, &#x27;)&#x27;);</span><br><span class="line">  map.set(&#x27;&#123;&#x27;, &#x27;&#125;&#x27;);</span><br><span class="line">  map.set(&#x27;[&#x27;, &#x27;]&#x27;);</span><br><span class="line"></span><br><span class="line">  // 创建一个栈</span><br><span class="line">  const stack = [];</span><br><span class="line"></span><br><span class="line">  // 遍历字符串</span><br><span class="line">  for (let i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    // 取出字符</span><br><span class="line">    const c = s[i];</span><br><span class="line"></span><br><span class="line">    // 如果是左括号就入栈</span><br><span class="line">    if (map.has(c)) &#123;</span><br><span class="line">      stack.push(c)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      // 取出栈顶</span><br><span class="line">      const t = stack[stack.length - 1];</span><br><span class="line"></span><br><span class="line">      // 如果字典中有这个值 就出栈</span><br><span class="line">      if (map.get(t) === c) &#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        // 否则就不是一个有效的括号</span><br><span class="line">        return false</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return stack.length === 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4）最小覆盖字串"><a href="#4）最小覆盖字串" class="headerlink" title="4）最小覆盖字串"></a>4）最小覆盖字串</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// 输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">// 输出：&quot;BANC&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 时间复杂度 O(m + n) m是t的长度 n是s的长度</span><br><span class="line">// 空间复杂度 O(k) k是字符串中不重复字符的个数</span><br><span class="line">var minWindow = function (s, t) &#123;</span><br><span class="line">  // 定义双指针维护一个滑动窗口</span><br><span class="line">  let l = 0;</span><br><span class="line">  let r = 0;</span><br><span class="line"></span><br><span class="line">  // 建立一个字典</span><br><span class="line">  const need = new Map();</span><br><span class="line"></span><br><span class="line">  //  遍历t</span><br><span class="line">  for (const c of t) &#123;</span><br><span class="line">    need.set(c, need.has(c) ? need.get(c) + 1 : 1)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let needType = need.size</span><br><span class="line"></span><br><span class="line">  // 记录最小子串</span><br><span class="line">  let res = &quot;&quot;</span><br><span class="line"></span><br><span class="line">  // 移动右指针</span><br><span class="line">  while (r &lt; s.length) &#123;</span><br><span class="line">  </span><br><span class="line">    // 获取当前字符</span><br><span class="line">    const c = s[r];</span><br><span class="line"></span><br><span class="line">    // 如果字典里有这个字符</span><br><span class="line">    if (need.has(c)) &#123;</span><br><span class="line">    </span><br><span class="line">      // 减少字典里面的次数</span><br><span class="line">      need.set(c, need.get(c) - 1);</span><br><span class="line"></span><br><span class="line">      // 减少需要的值</span><br><span class="line">      if (need.get(c) === 0) needType -= 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果字典中所有的值都为0了 就说明找到了一个最小子串</span><br><span class="line">    while (needType === 0) &#123;</span><br><span class="line">    </span><br><span class="line">      // 取出当前符合要求的子串</span><br><span class="line">      const newRes = s.substring(l, r + 1)</span><br><span class="line"></span><br><span class="line">      // 如果当前子串是小于上次的子串就进行覆盖</span><br><span class="line">      if (!res || newRes.length &lt; res.length) res = newRes;</span><br><span class="line"></span><br><span class="line">      // 获取左指针的字符</span><br><span class="line">      const c2 = s[l];</span><br><span class="line"></span><br><span class="line">      // 如果字典里有这个字符</span><br><span class="line">      if (need.has(c2)) &#123;</span><br><span class="line">        // 增加字典里面的次数</span><br><span class="line">        need.set(c2, need.get(c2) + 1);</span><br><span class="line"></span><br><span class="line">        // 增加需要的值</span><br><span class="line">        if (need.get(c2) === 1) needType += 1;</span><br><span class="line">      &#125;</span><br><span class="line">      l += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    r += 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="6-树"><a href="#6-树" class="headerlink" title="6. 树"></a>6. 树</h2><p>一种<code>分层数据的抽象模型</code>， 比如DOM树、树形控件等</p>
<blockquote>
<p>js中没有树 但是可以用 <strong>Object 和 Array 构建树</strong></p>
</blockquote>
<h3 id="1）普通树"><a href="#1）普通树" class="headerlink" title="1）普通树"></a>1）普通树</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 这就是一个常见的普通树形结构</span><br><span class="line">const tree = &#123;</span><br><span class="line">  val: &quot;a&quot;,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      val: &quot;b&quot;,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          val: &quot;d&quot;,</span><br><span class="line">          children: [],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          val: &quot;e&quot;,</span><br><span class="line">          children: [],</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      val: &quot;c&quot;,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          val: &quot;f&quot;,</span><br><span class="line">          children: [],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          val: &quot;g&quot;,</span><br><span class="line">          children: [],</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gt-深度优先遍历"><a href="#gt-深度优先遍历" class="headerlink" title="&gt; 深度优先遍历"></a>&gt; 深度优先遍历</h4><ul>
<li>尽可能深的搜索树的分支,就比如遇到一个节点就会<strong>直接去遍历他的子节点</strong>，<strong>不会立刻去遍历他的兄弟节点</strong></li>
<li>口诀：</li>
<li>访问根节点</li>
<li>对根节点的 children 挨个进行深度优先遍历</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 深度优先遍历</span><br><span class="line">const dfs = (tree) =&gt; &#123;</span><br><span class="line">  tree.children.forEach(dfs)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="gt-广度优先遍历"><a href="#gt-广度优先遍历" class="headerlink" title="&gt; 广度优先遍历"></a>&gt; 广度优先遍历</h4><ul>
<li>先访问离根节点最近的节点, 如果有兄弟节点就会<strong>先遍历兄弟节点</strong>，<strong>再去遍历自己的子节点</strong></li>
<li>口诀</li>
<li>新建一个队列 并把根节点入队</li>
<li>把队头出队并访问</li>
<li>把队头的children挨个入队</li>
<li>重复第二 、三步 直到队列为空</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 广度优先遍历</span><br><span class="line">const bfs = (tree) =&gt; &#123;</span><br><span class="line">  const q = [tree];</span><br><span class="line"></span><br><span class="line">  while (q.length &gt; 0) &#123;</span><br><span class="line">    const n = q.shift()</span><br><span class="line">    console.log(n.val);</span><br><span class="line">    n.children.forEach(c =&gt; q.push(c))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2）二叉树"><a href="#2）二叉树" class="headerlink" title="2）二叉树"></a>2）二叉树</h3><p>树中每个节点 <strong>最多只能有两个子节点</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQTBMt0dgTbnFELuibCicYdN0tKKG3NMfOIJO6oAMyl2wzJHQ6COPhd4yKVb5s69uYvWCRpfcibj3gfHQ/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> const bt = &#123;</span><br><span class="line">  val: 1,</span><br><span class="line">  left: &#123;</span><br><span class="line">    val: 2,</span><br><span class="line">    left: null,</span><br><span class="line">    right: null</span><br><span class="line">  &#125;,</span><br><span class="line">  right: &#123;</span><br><span class="line">    val: 3,</span><br><span class="line">    left: &#123;</span><br><span class="line">      val: 4,</span><br><span class="line">      left: null,</span><br><span class="line">      right: null</span><br><span class="line">    &#125;,</span><br><span class="line">    right: &#123;</span><br><span class="line">      val: 5,</span><br><span class="line">      left: null,</span><br><span class="line">      right: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gt-二叉树的先序遍历"><a href="#gt-二叉树的先序遍历" class="headerlink" title="&gt; 二叉树的先序遍历"></a>&gt; 二叉树的先序遍历</h4><ul>
<li>访问根节点</li>
<li>对根节点的左子树进行先序遍历</li>
<li>对根节点的右子树进行先序遍历</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 先序遍历 递归</span><br><span class="line">const preOrder = (tree) =&gt; &#123;</span><br><span class="line">  if (!tree) return</span><br><span class="line"></span><br><span class="line">  console.log(tree.val);</span><br><span class="line"></span><br><span class="line">  preOrder(tree.left);</span><br><span class="line">  preOrder(tree.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 先序遍历 非递归</span><br><span class="line">const preOrder2 = (tree) =&gt; &#123;</span><br><span class="line">  if (!tree) return</span><br><span class="line"></span><br><span class="line">  // 新建一个栈</span><br><span class="line">  const stack = [tree];</span><br><span class="line"></span><br><span class="line">  while (stack.length &gt; 0) &#123;</span><br><span class="line">    const n = stack.pop();</span><br><span class="line">    console.log(n.val);</span><br><span class="line"></span><br><span class="line">    // 负负为正</span><br><span class="line">    if (n.right) stack.push(n.right);</span><br><span class="line">    if (n.left) stack.push(n.left);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gt-二叉树的中序遍历"><a href="#gt-二叉树的中序遍历" class="headerlink" title="&gt; 二叉树的中序遍历"></a>&gt; 二叉树的中序遍历</h4><ul>
<li>对根节点的左子树进行中序遍历</li>
<li>访问根节点</li>
<li>对根节点的右子树进行中序遍历</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQTBMt0dgTbnFELuibCicYdN0tmy9ffFdXFg855xcT5k009lroEibicaaFsbPGvKwwGatJIKWtmicJxO9IQ/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 中序遍历 递归</span><br><span class="line">const inOrder = (tree) =&gt; &#123;</span><br><span class="line">  if (!tree) return;</span><br><span class="line">  inOrder(tree.left)</span><br><span class="line">  console.log(tree.val);</span><br><span class="line">  inOrder(tree.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 中序遍历 非递归</span><br><span class="line">const inOrder2 = (tree) =&gt; &#123;</span><br><span class="line">  if (!tree) return;</span><br><span class="line"></span><br><span class="line">  // 新建一个栈</span><br><span class="line">  const stack = [];</span><br><span class="line"></span><br><span class="line">  // 先遍历所有的左节点</span><br><span class="line">  let p = tree;</span><br><span class="line">  while (stack.length || p) &#123;</span><br><span class="line"></span><br><span class="line">    while (p) &#123;</span><br><span class="line">      stack.push(p)</span><br><span class="line">      p = p.left</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const n = stack.pop();</span><br><span class="line">    console.log(n.val);</span><br><span class="line"></span><br><span class="line">    p = n.right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gt-二叉树的后序遍历"><a href="#gt-二叉树的后序遍历" class="headerlink" title="&gt; 二叉树的后序遍历"></a>&gt; 二叉树的后序遍历</h4><ul>
<li>对根节点的左子树进行后序遍历</li>
<li>对根节点的右子树进行后序遍历</li>
<li>访问根节点</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQTBMt0dgTbnFELuibCicYdN0tiawMnkQ3QWmoOwZicbzvMmHeRMUIFZiaUqBeNibY5zHYXodMBgGOp0nkrQ/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 后序遍历 递归</span><br><span class="line">const postOrder = (tree) =&gt; &#123;</span><br><span class="line">  if (!tree) return</span><br><span class="line"></span><br><span class="line">  postOrder(tree.left)</span><br><span class="line">  postOrder(tree.right)</span><br><span class="line">  console.log(tree.val)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 后序遍历 非递归</span><br><span class="line">const postOrder2 = (tree) =&gt; &#123;</span><br><span class="line">  if (!tree) return</span><br><span class="line"></span><br><span class="line">  const stack = [tree];</span><br><span class="line">  const outputStack = [];</span><br><span class="line"></span><br><span class="line">  while (stack.length) &#123;</span><br><span class="line">    const n = stack.pop();</span><br><span class="line">    outputStack.push(n)</span><br><span class="line">    // 负负为正</span><br><span class="line">    if (n.left) stack.push(n.left);</span><br><span class="line">    if (n.right) stack.push(n.right);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  while (outputStack.length) &#123;</span><br><span class="line">    const n = outputStack.pop();</span><br><span class="line">    console.log(n.val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="gt-二叉树的最大深度"><a href="#gt-二叉树的最大深度" class="headerlink" title="&gt; 二叉树的最大深度"></a>&gt; 二叉树的最大深度</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 给一个二叉树，需要你找出其最大的深度，从根节点到叶子节点的距离</span><br><span class="line"></span><br><span class="line">// 时间复杂度 O(n) n为树的节点数</span><br><span class="line">// 空间复杂度 有一个递归调用的栈 所以为 O(n) n也是为二叉树的最大深度</span><br><span class="line">var maxDepth = function (root) &#123;</span><br><span class="line">  let res = 0;</span><br><span class="line">    </span><br><span class="line">  // 使用深度优先遍历</span><br><span class="line">  const dfs = (n, l) =&gt; &#123;</span><br><span class="line">    if (!n) return;</span><br><span class="line">    if (!n.left &amp;&amp; !n.right) &#123;</span><br><span class="line">     // 没有叶子节点就把深度数量更新</span><br><span class="line">      res = Math.max(res, l);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(n.left, l + 1)</span><br><span class="line">    dfs(n.right, l + 1)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dfs(root, 1)</span><br><span class="line"></span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gt-二叉树的最小深度"><a href="#gt-二叉树的最小深度" class="headerlink" title="&gt; 二叉树的最小深度"></a>&gt; 二叉树的最小深度</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 给一个二叉树，需要你找出其最小的深度， 从根节点到叶子节点的距离</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 时间复杂度O(n) n是树的节点数量</span><br><span class="line">// 空间复杂度O(n) n是树的节点数量</span><br><span class="line">var minDepth = function (root) &#123;</span><br><span class="line">  if (!root) return 0</span><br><span class="line">  </span><br><span class="line">  // 使用广度优先遍历</span><br><span class="line">  const q = [[root, 1]];</span><br><span class="line"></span><br><span class="line">  while (q.length) &#123;</span><br><span class="line">    // 取出当前节点</span><br><span class="line">    const [n, l] = q.shift();</span><br><span class="line">    </span><br><span class="line">    // 如果是叶子节点直接返回深度就可</span><br><span class="line">    if (!n.left &amp;&amp; !n.right) return l</span><br><span class="line">    if (n.left) q.push([n.left, l + 1]);</span><br><span class="line">    if (n.right) q.push([n.right, l + 1]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gt-二叉树的层序遍历"><a href="#gt-二叉树的层序遍历" class="headerlink" title="&gt; 二叉树的层序遍历"></a>&gt; 二叉树的层序遍历</h4><p><img src="https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQTBMt0dgTbnFELuibCicYdN0tKKG3NMfOIJO6oAMyl2wzJHQ6COPhd4yKVb5s69uYvWCRpfcibj3gfHQ/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 需要返回 [[1], [2,3], [4,5]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 时间复杂度 O(n) n为树的节点数</span><br><span class="line">// 空间复杂度 O(n) </span><br><span class="line">var levelOrder = function (root) &#123;</span><br><span class="line">  if (!root) return []</span><br><span class="line">   </span><br><span class="line">  // 广度优先遍历</span><br><span class="line">  const q = [root];</span><br><span class="line">  const res = [];</span><br><span class="line">  while (q.length) &#123;</span><br><span class="line">    let len = q.length</span><br><span class="line"></span><br><span class="line">    res.push([])</span><br><span class="line">    </span><br><span class="line">    // 循环每层的节点数量次</span><br><span class="line">    while (len--) &#123;</span><br><span class="line">      const n = q.shift();</span><br><span class="line">      </span><br><span class="line">      res[res.length - 1].push(n.val)</span><br><span class="line">      </span><br><span class="line">      if (n.left) q.push(n.left);</span><br><span class="line">      if (n.right) q.push(n.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="7-图"><a href="#7-图" class="headerlink" title="7. 图"></a>7. 图</h2><p>图是<code>网络结构的抽象模型</code>, 是一组由边连接的节点</p>
<blockquote>
<p>js中可以利用<strong>Object和Array构建图</strong></p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQTBMt0dgTbnFELuibCicYdN0t7jd0ZvMWOibZHWfb1qKwUzPqwibzL6PjRKp8euclPWawv1QysGAHDp2w/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 上图可以表示为</span><br><span class="line">const graph = &#123;</span><br><span class="line">  0: [1, 2],</span><br><span class="line">  1: [2],</span><br><span class="line">  2: [0, 3],</span><br><span class="line">  3: [3]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 深度优先遍历，对根节点没访问过的相邻节点挨个进行遍历</span><br><span class="line">&#123;</span><br><span class="line">    // 记录节点是否访问过</span><br><span class="line">    const visited = new Set();</span><br><span class="line">    const dfs = (n) =&gt; &#123;</span><br><span class="line">      visited.add(n);</span><br><span class="line">      </span><br><span class="line">      // 遍历相邻节点</span><br><span class="line">      graph[n].forEach(c =&gt; &#123;</span><br><span class="line">        // 没访问过才可以，进行递归访问</span><br><span class="line">        if(!visited.has(c))&#123;</span><br><span class="line">          dfs(c)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 从2开始进行遍历</span><br><span class="line">    dfs(2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 广度优先遍历 </span><br><span class="line">&#123;</span><br><span class="line">    const visited = new Set();</span><br><span class="line">    // 新建一个队列， 根节点入队， 设2为根节点</span><br><span class="line">    const q = [2];</span><br><span class="line">    visited.add(2)</span><br><span class="line">    while (q.length) &#123;</span><br><span class="line">    </span><br><span class="line">      // 队头出队，并访问</span><br><span class="line">      const n = q.shift();</span><br><span class="line">      console.log(n);</span><br><span class="line">      graph[n].forEach(c =&gt; &#123;</span><br><span class="line">      </span><br><span class="line">        // 对没访问过的相邻节点入队</span><br><span class="line">        if (!visited.has(c)) &#123;</span><br><span class="line">          q.push(c)</span><br><span class="line">          visited.add(c)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1）有效数字"><a href="#1）有效数字" class="headerlink" title="1）有效数字"></a>1）有效数字</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 生成数字关系图 只有状态为 3 5 6 的时候才为一个数字</span><br><span class="line">const graph = &#123;</span><br><span class="line">  0: &#123; &#x27;blank&#x27;: 0, &#x27;sign&#x27;: 1, &quot;.&quot;: 2, &quot;digit&quot;: 6 &#125;,</span><br><span class="line">  1: &#123; &quot;digit&quot;: 6, &quot;.&quot;: 2 &#125;,</span><br><span class="line">  2: &#123; &quot;digit&quot;: 3 &#125;,</span><br><span class="line">  3: &#123; &quot;digit&quot;: 3, &quot;e&quot;: 4 &#125;,</span><br><span class="line">  4: &#123; &quot;digit&quot;: 5, &quot;sign&quot;: 7 &#125;,</span><br><span class="line">  5: &#123; &quot;digit&quot;: 5 &#125;,</span><br><span class="line">  6: &#123; &quot;digit&quot;: 6, &quot;.&quot;: 3, &quot;e&quot;: 4 &#125;,</span><br><span class="line">  7: &#123; &quot;digit&quot;: 5 &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 时间复杂度 O(n) n是字符串长度</span><br><span class="line">// 空间复杂度 O(1) </span><br><span class="line">var isNumber = function (s) &#123;</span><br><span class="line"></span><br><span class="line">  // 记录状态</span><br><span class="line">  let state = 0;</span><br><span class="line"></span><br><span class="line">  // 遍历字符串</span><br><span class="line">  for (c of s.trim()) &#123;</span><br><span class="line">    // 把字符进行转换</span><br><span class="line">    if (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;</span><br><span class="line">      c = &#x27;digit&#x27;;</span><br><span class="line">    &#125; else if (c === &quot; &quot;) &#123;</span><br><span class="line">      c = &#x27;blank&#x27;;</span><br><span class="line">    &#125; else if (c === &quot;+&quot; || c === &quot;-&quot;) &#123;</span><br><span class="line">      c = &quot;sign&quot;;</span><br><span class="line">    &#125; else if (c === &quot;E&quot; || c === &quot;e&quot;) &#123;</span><br><span class="line">      c = &quot;e&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 开始寻找图</span><br><span class="line">    state = graph[state][c];</span><br><span class="line"></span><br><span class="line">    // 如果最后是undefined就是错误</span><br><span class="line">    if (state === undefined) return false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 判断最后的结果是不是合法的数字</span><br><span class="line">  if (state === 3 || state === 5 || state === 6) return true</span><br><span class="line">  return false</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h2 id="8-堆"><a href="#8-堆" class="headerlink" title="8. 堆"></a>8. 堆</h2><p>一种<code>特殊的完全二叉树</code>, 所有的节点都大于等于最大堆,或者小于等于最小堆的子节点</p>
<blockquote>
<p>js通常使用<strong>数组来表示堆</strong></p>
</blockquote>
<ul>
<li>左侧子节点的位置是 <strong>2*index + 1</strong></li>
<li>右侧子节点的位置是 <strong>2*index + 2</strong></li>
<li>父节点的位置是 <strong>(index - 1) &#x2F; 2</strong> , 取余数</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQTBMt0dgTbnFELuibCicYdN0t2hczdHicDo4gewutUP5FYtOg6rnd6pnxxsfpjDFicA56bRKjVd650rXg/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="2）JS实现一个最小堆"><a href="#2）JS实现一个最小堆" class="headerlink" title="2）JS实现一个最小堆"></a>2）JS实现一个最小堆</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">// js实现最小堆类</span><br><span class="line">class MinHeap &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    // 元素容器</span><br><span class="line">    this.heap = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 交换节点的值</span><br><span class="line">  swap(i1, i2) &#123;</span><br><span class="line">    [this.heap[i1], this.heap[i2]] = [this.heap[i2], this.heap[i1]]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //  获取父节点</span><br><span class="line">  getParentIndex(index) &#123;</span><br><span class="line">    // 除以二， 取余数</span><br><span class="line">    return (index - 1) &gt;&gt; 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 获取左侧节点索引</span><br><span class="line">  getLeftIndex(i) &#123;</span><br><span class="line">    return (i &lt;&lt; 1) + 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 获取右侧节点索引</span><br><span class="line">  getRightIndex(i) &#123;</span><br><span class="line">    return (i &lt;&lt; 1) + 2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 上移</span><br><span class="line">  shiftUp(index) &#123;</span><br><span class="line">    if (index == 0) return;</span><br><span class="line"></span><br><span class="line">    // 获取父节点</span><br><span class="line">    const parentIndex = this.getParentIndex(index);</span><br><span class="line"></span><br><span class="line">    // 如果父节点的值大于当前节点的值 就需要进行交换</span><br><span class="line">    if (this.heap[parentIndex] &gt; this.heap[index]) &#123;</span><br><span class="line">      this.swap(parentIndex, index);</span><br><span class="line"></span><br><span class="line">      // 然后继续上移</span><br><span class="line">      this.shiftUp(parentIndex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 下移</span><br><span class="line">  shiftDown(index) &#123;</span><br><span class="line">    // 获取左右节点索引</span><br><span class="line">    const leftIndex = this.getLeftIndex(index);</span><br><span class="line">    const rightIndex = this.getRightIndex(index);</span><br><span class="line"></span><br><span class="line">    // 如果左子节点小于当前的值</span><br><span class="line">    if (this.heap[leftIndex] &lt; this.heap[index]) &#123;</span><br><span class="line"></span><br><span class="line">      // 进行节点交换</span><br><span class="line">      this.swap(leftIndex, index);</span><br><span class="line"></span><br><span class="line">      // 继续进行下移</span><br><span class="line">      this.shiftDown(leftIndex)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果右侧节点小于当前的值</span><br><span class="line">    if (this.heap[rightIndex] &lt; this.heap[index]) &#123;</span><br><span class="line">      this.swap(rightIndex, index);</span><br><span class="line">      this.shiftDown(rightIndex)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 插入元素</span><br><span class="line">  insert(value) &#123;</span><br><span class="line">    // 插入到堆的底部</span><br><span class="line">    this.heap.push(value);</span><br><span class="line"></span><br><span class="line">    // 然后上移： 将这个值和它的父节点进行交换，知道父节点小于等于这个插入的值</span><br><span class="line">    this.shiftUp(this.heap.length - 1)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 删除堆项</span><br><span class="line">  pop() &#123;</span><br><span class="line"></span><br><span class="line">    // 把数组最后一位 转移到数组头部</span><br><span class="line">    this.heap[0] = this.heap.pop();</span><br><span class="line"></span><br><span class="line">    // 进行下移操作</span><br><span class="line">    this.shiftDown(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 获取堆顶元素</span><br><span class="line">  peek() &#123;</span><br><span class="line">    return this.heap[0]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 获取堆大小</span><br><span class="line">  size() &#123;</span><br><span class="line">    return this.heap.length</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2）数组中的第k个最大元素"><a href="#2）数组中的第k个最大元素" class="headerlink" title="2）数组中的第k个最大元素"></a>2）数组中的第k个最大元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 输入 [3,2,1,5,6,4] 和 k = 2</span><br><span class="line">// 输出 5</span><br><span class="line"></span><br><span class="line">// 时间复杂度 O(n * logK) K就是堆的大小</span><br><span class="line">// 空间复杂度 O(K) K是参数k</span><br><span class="line">var findKthLargest = function (nums, k) &#123;</span><br><span class="line"></span><br><span class="line">  // 使用上面js实现的最小堆类，来构建一个最小堆</span><br><span class="line">  const h = new MinHeap();</span><br><span class="line">  </span><br><span class="line">  // 遍历数组</span><br><span class="line">  nums.forEach(n =&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    // 把数组中的值依次插入到堆里</span><br><span class="line">    h.insert(n);</span><br><span class="line">    </span><br><span class="line">    if (h.size() &gt; k) &#123;</span><br><span class="line">      // 进行优胜劣汰</span><br><span class="line">      h.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return h.peek()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3）前-K-个高频元素"><a href="#3）前-K-个高频元素" class="headerlink" title="3）前 K 个高频元素"></a>3）前 K 个高频元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">// 输出: [1,2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 时间复杂度 O(n * logK) </span><br><span class="line">// 空间复杂度 O(k)</span><br><span class="line">var topKFrequent = function (nums, k) &#123;</span><br><span class="line"></span><br><span class="line">  // 统计每个元素出现的频率</span><br><span class="line">  const map = new Map();</span><br><span class="line"></span><br><span class="line">  // 遍历数组 建立映射关系</span><br><span class="line">  nums.forEach(n =&gt; &#123;</span><br><span class="line">    map.set(n, map.has(n) ? map.get(n) + 1 : 1);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // 建立最小堆</span><br><span class="line">  const h = new MinHeap();</span><br><span class="line"></span><br><span class="line">  // 遍历映射关系</span><br><span class="line">  map.forEach((value, key) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 由于插入的元素结构发生了变化，所以需要对 最小堆的类 进行改造一下,改造的方法我会写到最后</span><br><span class="line">    h.insert(&#123; value, key &#125;)</span><br><span class="line">    if (h.size() &gt; k) &#123;</span><br><span class="line">      h.pop()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return h.heap.map(item =&gt; item.key)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 改造上移和下移操作即可</span><br><span class="line">// shiftUp(index) &#123;</span><br><span class="line">//   if (index == 0) return;</span><br><span class="line">//   const parentIndex = this.getParentIndex(index);</span><br><span class="line">//   if (this.heap[parentIndex] &amp;&amp; this.heap[parentIndex].value &gt; this.heap[index].value) &#123;</span><br><span class="line">//     this.swap(parentIndex, index);</span><br><span class="line">//     this.shiftUp(parentIndex);</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br><span class="line">// shiftDown(index) &#123;</span><br><span class="line">//   const leftIndex = this.getLeftIndex(index);</span><br><span class="line">//   const rightIndex = this.getRightIndex(index);</span><br><span class="line"></span><br><span class="line">//   if (this.heap[leftIndex] &amp;&amp; this.heap[leftIndex].value &lt; this.heap[index].value) &#123;</span><br><span class="line">//     this.swap(leftIndex, index);</span><br><span class="line">//     this.shiftDown(leftIndex)</span><br><span class="line">//   &#125;</span><br><span class="line"></span><br><span class="line">//   if (this.heap[rightIndex] &amp;&amp; this.heap[rightIndex].value &lt; this.heap[index].value) &#123;</span><br><span class="line">//     this.swap(rightIndex, index);</span><br><span class="line">//     this.shiftDown(rightIndex)</span><br><span class="line">//   &#125;</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、常见算法及算法思想"><a href="#四、常见算法及算法思想" class="headerlink" title="四、常见算法及算法思想"></a><strong>四、常见算法及算法思想</strong></h1><h2 id="1-排序"><a href="#1-排序" class="headerlink" title="1. 排序"></a>1. 排序</h2><p><code>把某个乱序的数组变成升序序或者降序的数组</code>， js比较常用<strong>sort方法进行排序</strong></p>
<h3 id="1）冒泡排序"><a href="#1）冒泡排序" class="headerlink" title="1）冒泡排序"></a>1）冒泡排序</h3><ul>
<li>比较所有相邻元素，如果第一个比第二个大就<strong>交换他们</strong></li>
<li>执行一次后可以保证最后一个数字是最大的</li>
<li>重复执行 n-1 次，就可以完成排序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度 O(n ^ 2) n为数组长度</span><br><span class="line">// 空间复杂度 O(1)</span><br><span class="line">Array.prototype.bubbleSort = function () &#123;</span><br><span class="line">  for (i = 0; i &lt; this.length - 1; i++) &#123;</span><br><span class="line">    for (let j = 0; j &lt; this.length - 1 - i; j++) &#123;</span><br><span class="line">      if (this[j] &gt; this[j + 1]) &#123;</span><br><span class="line">      </span><br><span class="line">        // 交换数据</span><br><span class="line">        [this[j], this[j + 1]] = [this[j + 1], this[j]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2）选择排序"><a href="#2）选择排序" class="headerlink" title="2）选择排序"></a>2）选择排序</h3><ul>
<li>找到数组中<strong>最小的值</strong>,选中它并放到第一位</li>
<li>接着找到数组中<strong>第二小的值</strong>,选中它并放到第二位</li>
<li>重复上述步骤执行 n-1 次</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度：O(n ^ 2) n为数组长度</span><br><span class="line">// 空间复杂度：O(1)</span><br><span class="line">Array.prototype.selectionSort = function () &#123;</span><br><span class="line">  for (let i = 0; i &lt; this.length - 1; i++) &#123;</span><br><span class="line">    let indexMin = i;</span><br><span class="line"></span><br><span class="line">    for (let j = i; j &lt; this.length; j++) &#123;</span><br><span class="line"></span><br><span class="line">      // 如果当前这个元素 小于最小值的下标 就更新最小值的下标</span><br><span class="line">      if (this[j] &lt; this[indexMin]) &#123;</span><br><span class="line">        indexMin = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 避免自己和自己进行交换</span><br><span class="line">    if (indexMin !== i) &#123;</span><br><span class="line"></span><br><span class="line">      // 进行交换数据</span><br><span class="line">      [this[i], this[indexMin]] = [this[indexMin], this[i]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3）插入排序"><a href="#3）插入排序" class="headerlink" title="3）插入排序"></a>3）插入排序</h3><ul>
<li>从第二个数，<strong>开始往前比较</strong></li>
<li>如<strong>它大就往后排</strong></li>
<li>以此类推进行到最后一个数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度 O(n ^ 2)</span><br><span class="line">Array.prototype.insertionSort = function () &#123;</span><br><span class="line"></span><br><span class="line">  // 遍历数组 从第二个开始</span><br><span class="line">  for (let i = 1; i &lt; this.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    // 获取第二个元素</span><br><span class="line">    const temp = this[i];</span><br><span class="line"></span><br><span class="line">    let j = i;</span><br><span class="line">    while (j &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">      // 如果当前元素小于前一个元素 就开始往后移动</span><br><span class="line">      if (this[j - 1] &gt; temp) &#123;</span><br><span class="line">        this[j] = this[j - 1];</span><br><span class="line">      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        // 否则就跳出循环</span><br><span class="line">        break</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 递减</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 前一位置赋值为当前元素</span><br><span class="line">    this[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4）归并排序"><a href="#4）归并排序" class="headerlink" title="4）归并排序"></a>4）归并排序</h3><ul>
<li>分：把数组<strong>劈成两半</strong> 在递归的对子数组进行分操作，直到分成一个个<strong>单独的数</strong></li>
<li>合：把两个树<strong>合并为有序数组</strong>，再对有序数组进行合并， 直到全部子数组合并为一个完整的数组</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度 O(nlogn) 分需要劈开数组，所以是logn， 合则是n</span><br><span class="line">// 空间复杂度 O(n)</span><br><span class="line">Array.prototype.mergeSort = function () &#123;</span><br><span class="line"></span><br><span class="line">  const rec = (arr) =&gt; &#123;</span><br><span class="line">    // 递归终点</span><br><span class="line">    if (arr.length === 1) return arr</span><br><span class="line"></span><br><span class="line">    // 获取中间索引</span><br><span class="line">    const mid = arr.length &gt;&gt; 1;</span><br><span class="line"></span><br><span class="line">    // 通过中间下标,进行分割数组</span><br><span class="line">    const left = arr.slice(0, mid);</span><br><span class="line">    const right = arr.slice(mid);</span><br><span class="line"></span><br><span class="line">    // 左边和右边的数组进行递归,会得到有序的左数组,和有序的右数组</span><br><span class="line">    const orderLeft = rec(left);</span><br><span class="line">    const orderRight = rec(right);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 存放结果的数组</span><br><span class="line">    const res = [];</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    while (orderLeft.length || orderRight.length) &#123;</span><br><span class="line"></span><br><span class="line">      // 如左边和右边数组都有值</span><br><span class="line">      if (orderLeft.length &amp;&amp; orderRight.length) &#123;</span><br><span class="line"></span><br><span class="line">        // 左边队头的值小于右边队头的值 就左边队头出队,否则就是右边队头出队</span><br><span class="line">        res.push(orderLeft[0] &lt; orderRight[0] ? orderLeft.shift() : orderRight.shift())</span><br><span class="line">      &#125; else if (orderLeft.length) &#123;</span><br><span class="line"></span><br><span class="line">        // 把左边的队头放入数组</span><br><span class="line">        res.push(orderLeft.shift())</span><br><span class="line">      &#125; else if (orderRight.length) &#123;</span><br><span class="line"></span><br><span class="line">        // 把右边的队头放入数组</span><br><span class="line">        res.push(orderRight.shift())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const res = rec(this)</span><br><span class="line"></span><br><span class="line">  // 把结果放入原数组</span><br><span class="line">  res.forEach((n, i) =&gt; this[i] = n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gt-合并两个有序链表"><a href="#gt-合并两个有序链表" class="headerlink" title="&gt; 合并两个有序链表"></a>&gt; 合并两个有序链表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度O(n) n为链表1和链表2的长度之和</span><br><span class="line">// 空间复杂度O(1)</span><br><span class="line">var mergeTwoLists = function (list1, list2) &#123;</span><br><span class="line"></span><br><span class="line">  // 新建一个新链表 作为返回值</span><br><span class="line">  const res = &#123;</span><br><span class="line">    val: 0,</span><br><span class="line">    next: null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 指向新链表的指针</span><br><span class="line">  let p = res;</span><br><span class="line"></span><br><span class="line">  // 建立两个指针</span><br><span class="line">  let p1 = list1;</span><br><span class="line">  let p2 = list2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 遍历两个链表</span><br><span class="line">  while (p1 &amp;&amp; p2) &#123;</span><br><span class="line"></span><br><span class="line">    // 如果链表1 小于 链表2的值 就接入链表1的值</span><br><span class="line">    if (p1.val &lt; p2.val) &#123;</span><br><span class="line">      p.next = p1;</span><br><span class="line"></span><br><span class="line">      // 需要往后移动</span><br><span class="line">      p1 = p1.next;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      // 否则接入链表2的值</span><br><span class="line">      p.next = p2;</span><br><span class="line"></span><br><span class="line">      // 需要往后移动</span><br><span class="line">      p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // p永远要往后移动一位</span><br><span class="line">    p = p.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 如果链表1或者链表2还有值,就把后面的值全部接入新链表</span><br><span class="line">  if (p1) &#123;</span><br><span class="line">    p.next = p1;</span><br><span class="line">  &#125;</span><br><span class="line">  if (p2) &#123;</span><br><span class="line">    p.next = p2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return res.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5）快速排序"><a href="#5）快速排序" class="headerlink" title="5）快速排序"></a>5）快速排序</h3><ul>
<li>分区：从数组中任意选择一个 <strong>基准</strong>， 所有<strong>比基准小的元素放在基准前面</strong>，<strong>比基准大的元素放在基准后面</strong></li>
<li>递归： <strong>递归的对基准前后的子数组进行分区</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度 O(nlogN)</span><br><span class="line">// 空间复杂度 O(1)</span><br><span class="line">Array.prototype.quickSort = function () &#123;</span><br><span class="line">  const rec = (arr) =&gt; &#123;</span><br><span class="line">  </span><br><span class="line">    // 如果数组长度小于等于1 就不用排序了</span><br><span class="line">    if (arr.length &lt;= 1) &#123; return arr &#125;</span><br><span class="line"></span><br><span class="line">    // 存放基准前后的数组</span><br><span class="line">    const left = [];</span><br><span class="line">    const right = [];</span><br><span class="line"></span><br><span class="line">    // 取基准</span><br><span class="line">    const mid = arr[0];</span><br><span class="line"></span><br><span class="line">    for (let i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">      // 如果当前值小于基准就放到基准前数组里面</span><br><span class="line">      if (arr[i] &lt; mid) &#123;</span><br><span class="line">        left.push(arr[i]);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        // 否则就放到基准后数组里面</span><br><span class="line">        right.push(arr[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归调用两边的子数组</span><br><span class="line">    return [...rec(left), mid, ...rec(right)];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const res = rec(this);</span><br><span class="line">  res.forEach((n, i) =&gt; this[i] = n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-搜索"><a href="#2-搜索" class="headerlink" title="2. 搜索"></a>2. 搜索</h2><p><code>找出数组中某个元素的下标</code>，js中通常使用<strong>indexOf方法进行搜索</strong></p>
<h3 id="1）顺序搜索"><a href="#1）顺序搜索" class="headerlink" title="1）顺序搜索"></a>1）顺序搜索</h3><ul>
<li>就比如indexOf方法， <strong>从头开始搜索数组中的某个元素</strong></li>
</ul>
<h3 id="2）二分搜索"><a href="#2）二分搜索" class="headerlink" title="2）二分搜索"></a>2）二分搜索</h3><ul>
<li>从数组中的<strong>中间位置开始搜索</strong>，如果中间元素<strong>正好是目标值，则搜索结束</strong></li>
<li>如果<strong>目标值大于或者小于中间元素</strong>，则在大于或者小于中间元素的那<strong>一半数组中搜索</strong></li>
<li><code>数组必须是有序的，如不是则需要先进行排序</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度：O(log n)</span><br><span class="line">// 空间复杂度：O(1)</span><br><span class="line">Array.prototype.binarySearch = function (item) &#123;</span><br><span class="line">  // 代表数组的最小索引</span><br><span class="line">  let low = 0;</span><br><span class="line"></span><br><span class="line">  // 和最大索引</span><br><span class="line">  let higt = this.length - 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  while (low &lt;= higt) &#123;</span><br><span class="line"></span><br><span class="line">    // 获取中间元素索引</span><br><span class="line">    const mid = (low + higt) &gt;&gt; 1;</span><br><span class="line">    </span><br><span class="line">    const element = this[mid];</span><br><span class="line"></span><br><span class="line">    // 如果中间元素小于于要查找的元素 就把最小索引更新为中间索引的下一个</span><br><span class="line">    if (element &lt; item) &#123;</span><br><span class="line">      low = mid + 1</span><br><span class="line">    &#125; else if (element &gt; item) &#123;</span><br><span class="line"></span><br><span class="line">    // 如果中间元素大于要查找的元素 就把最大索引更新为中间索引的前一个</span><br><span class="line">      higt = mid - 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 如果中间元素等于要查找的元素 就返回索引</span><br><span class="line">      return mid;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gt-猜数字大小"><a href="#gt-猜数字大小" class="headerlink" title="&gt; 猜数字大小"></a>&gt; 猜数字大小</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度 O(logn) 分割成两半的 基本都是logn</span><br><span class="line">// 空间复杂度 O(1)</span><br><span class="line">var guessNumber = function (n) &#123;</span><br><span class="line"></span><br><span class="line">  // 定义范围最小值和最大值</span><br><span class="line">  const low = 1;</span><br><span class="line">  const high = n;</span><br><span class="line"></span><br><span class="line">  while (low &lt;= high) &#123;</span><br><span class="line"></span><br><span class="line">    // 获取中间值</span><br><span class="line">    const mid = (low + high) &gt;&gt;&gt; 1;</span><br><span class="line"></span><br><span class="line">    // 这个方法是 leetcode 中的方法</span><br><span class="line">    // 如果返回值为-1 就是小了</span><br><span class="line">    // 如果返回值为1  就是大了</span><br><span class="line">    // 如果返回值为0  就是找到了 </span><br><span class="line">    const res = guess(mid);</span><br><span class="line">    </span><br><span class="line">    // 剩下的操作就和二分搜索一样</span><br><span class="line">    if (res === 0) &#123;</span><br><span class="line">      return mid</span><br><span class="line">    &#125; else if (res === 1) &#123;</span><br><span class="line">      low = mid + 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      high = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-分而治之"><a href="#3-分而治之" class="headerlink" title="3. 分而治之"></a>3. 分而治之</h2><p>算法设计中的一种思想，将一个问题<strong>分成多个子问题</strong>，<strong>递归解决子问题</strong>，然后将子问题的解<strong>合并成最终的解</strong></p>
<h3 id="1）归并排序"><a href="#1）归并排序" class="headerlink" title="1）归并排序"></a>1）归并排序</h3><ul>
<li>分：把数组从中间一分为二</li>
<li>解：递归地对两个子数组进行归并排序</li>
<li>合：合并有序子数组</li>
</ul>
<h3 id="2）快速排序"><a href="#2）快速排序" class="headerlink" title="2）快速排序"></a>2）快速排序</h3><ul>
<li>分：选基准，按基准把数组分成两个子数组</li>
<li>解：递归地对两个子数组进行快速排序</li>
<li>合：对两个子数组进行合并</li>
</ul>
<h3 id="3）二分搜索"><a href="#3）二分搜索" class="headerlink" title="3）二分搜索"></a>3）二分搜索</h3><ul>
<li>二分搜索也属于分而治之这种思想</li>
</ul>
<h4 id="gt-分而治之思想：猜数字大小"><a href="#gt-分而治之思想：猜数字大小" class="headerlink" title="&gt; 分而治之思想：猜数字大小"></a>&gt; 分而治之思想：猜数字大小</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度 O(logn) </span><br><span class="line">// 空间复杂度 O(logn) 递归调用栈 所以是logn</span><br><span class="line">var guessNumber = function (n) &#123;</span><br><span class="line"></span><br><span class="line">  // 递归函数 接受一个搜索范围</span><br><span class="line">  const rec = (low, high) =&gt; &#123;</span><br><span class="line">  </span><br><span class="line">    // 递归结束条件</span><br><span class="line">    if (low &gt; high) return;</span><br><span class="line"></span><br><span class="line">    // 获取中间元素</span><br><span class="line">    const mid = (low + high) &gt;&gt;&gt; 1;</span><br><span class="line"></span><br><span class="line">    // 判断是否猜对</span><br><span class="line">    const res = guess(mid)</span><br><span class="line"></span><br><span class="line">    // 猜对</span><br><span class="line">    if (res === 0) &#123;</span><br><span class="line">      return mid</span><br><span class="line">    &#125; else if (res === 1) &#123;</span><br><span class="line">      // 猜大了</span><br><span class="line">      return rec(mid + 1, high)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 猜小了</span><br><span class="line">      return rec(low, mid - 1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return rec(1, n)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="gt-分而治之思想：翻转二叉树"><a href="#gt-分而治之思想：翻转二叉树" class="headerlink" title="&gt; 分而治之思想：翻转二叉树"></a>&gt; 分而治之思想：翻转二叉树</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度 O(n) n为树的节点数量</span><br><span class="line">// 空间复杂度 O(h) h为树的高度</span><br><span class="line">var invertTree = function (root) &#123;</span><br><span class="line">  if (!root) return null</span><br><span class="line">  return &#123;</span><br><span class="line">    val: root.val,</span><br><span class="line">    left: invertTree(root.right),</span><br><span class="line">    right: invertTree(root.left)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="gt-分而治之思想：相同的树"><a href="#gt-分而治之思想：相同的树" class="headerlink" title="&gt; 分而治之思想：相同的树"></a>&gt; 分而治之思想：相同的树</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度 o(n) n为树的节点数量</span><br><span class="line">// 空间复杂度 o(h) h为树的节点数</span><br><span class="line">var isSameTree = function (p, q) &#123;</span><br><span class="line">  if (!p &amp;&amp; !q) return true</span><br><span class="line">  </span><br><span class="line">  if (</span><br><span class="line">    p &amp;&amp; q</span><br><span class="line">    &amp;&amp; p.val === q.val</span><br><span class="line">    &amp;&amp; isSameTree(p.left, q.left)</span><br><span class="line">    &amp;&amp; isSameTree(p.right, q.right)</span><br><span class="line">  ) return true</span><br><span class="line"></span><br><span class="line">  return false</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="gt-分而治之思想：对称二叉树"><a href="#gt-分而治之思想：对称二叉树" class="headerlink" title="&gt; 分而治之思想：对称二叉树"></a>&gt; 分而治之思想：对称二叉树</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度 O(n)</span><br><span class="line">// 空间复杂度 O(n) </span><br><span class="line">var isSymmetric = function (root) &#123;</span><br><span class="line">  if (!root) return true</span><br><span class="line">  const isMirror = (l, r) =&gt; &#123;</span><br><span class="line">    if (!l &amp;&amp; !r) return true</span><br><span class="line">    if (</span><br><span class="line">      l &amp;&amp; r </span><br><span class="line">      &amp;&amp; l.val === r.val</span><br><span class="line">      &amp;&amp; isMirror(l.left, r.right)</span><br><span class="line">      &amp;&amp; isMirror(l.right, r.left)</span><br><span class="line">    ) return true</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return isMirror(root.left, root.right)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-动态规划"><a href="#4-动态规划" class="headerlink" title="4. 动态规划"></a>4. 动态规划</h2><p>动态规划是算法设计中的一种思想，将一个问题分解为<strong>相互重叠</strong>的子问题，通过反复求解子问题来解决原来的问题</p>
<h3 id="1）斐波那契数列"><a href="#1）斐波那契数列" class="headerlink" title="1）斐波那契数列"></a>1）斐波那契数列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度 O(n) </span><br><span class="line">// 空间复杂度 O(n)</span><br><span class="line">function fib(n) &#123;</span><br><span class="line">    let dp = [0, 1, 1];</span><br><span class="line">    for (let i = 3; i &lt;= n; i++) &#123;</span><br><span class="line"></span><br><span class="line">        // 当前值等于前两个值之和</span><br><span class="line">        dp[i] = dp[i - 1] + dp[i - 2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2）爬楼梯"><a href="#2）爬楼梯" class="headerlink" title="2）爬楼梯"></a>2）爬楼梯</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 正在爬楼梯, 需要n阶才能到达楼顶</span><br><span class="line">// 每次只能爬 1 或者 2 个台阶, 有多少中不同的方法可以到达楼顶</span><br><span class="line"></span><br><span class="line">// 时间复杂度 O(n) n是楼梯长度</span><br><span class="line">// 空间复杂度 O(1)</span><br><span class="line">var climbStairs = function (n) &#123;</span><br><span class="line">    if (n &lt; 2) return 1</span><br><span class="line"></span><br><span class="line">    let dp0 = 1;</span><br><span class="line">    let dp1 = 1</span><br><span class="line"></span><br><span class="line">    for (let i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        [dp0, dp1] = [dp1, dp1 + dp0]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5-贪心算法"><a href="#5-贪心算法" class="headerlink" title="5. 贪心算法"></a>5. 贪心算法</h2><p>贪心算法是算法设计中的一种思想，期盼通过每个阶段的<strong>局部最优</strong>选择，从而达到全局的最优，但 <strong>结果并不一定是最优</strong></p>
<h3 id="1）分发饼干"><a href="#1）分发饼干" class="headerlink" title="1）分发饼干"></a>1）分发饼干</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 每个孩子都有一个胃口g. 每个孩子只能拥有一个饼干</span><br><span class="line">// 输入: g = [1,2,3], s = [1,1]</span><br><span class="line">// 输出: 1</span><br><span class="line">// 三个孩子胃口值分别是1,2,3  但是只有两个饼干,所以只能让胃口1的孩子满足</span><br><span class="line"></span><br><span class="line">// 时间复杂度 O(nlogn) </span><br><span class="line">// 空间复杂度 O(1)</span><br><span class="line">var findContentChildren = function (g, s) &#123;</span><br><span class="line">    // 对饼干和孩子胃口进行排序</span><br><span class="line">    g.sort((a, b) =&gt; a - b)</span><br><span class="line">    s.sort((a, b) =&gt; a - b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 是第几个孩子</span><br><span class="line">    let i = 0</span><br><span class="line"></span><br><span class="line">    s.forEach((n) =&gt; &#123;</span><br><span class="line">        // 如果饼干能满足第一个孩子</span><br><span class="line">        if (n &gt;= g[i]) &#123; </span><br><span class="line">            // 就开始满足第二个孩子</span><br><span class="line">            i += 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2）买卖股票的最佳时机Ⅱ"><a href="#2）买卖股票的最佳时机Ⅱ" class="headerlink" title="2）买卖股票的最佳时机Ⅱ"></a>2）买卖股票的最佳时机Ⅱ</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度 O(n) n为股票的数量</span><br><span class="line">// 空间复杂度 O(1)</span><br><span class="line">var maxProfit = function (prices) &#123;</span><br><span class="line">  // 存放利润</span><br><span class="line">  const profit = 0;</span><br><span class="line">  for (let i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    // 不贪 如有更高的利润就直接卖出</span><br><span class="line">    if (prices[i] &gt; prices[i - 1]) &#123;</span><br><span class="line">      profit += prices[i] - prices[i - 1]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return profit</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="6-回溯算法"><a href="#6-回溯算法" class="headerlink" title="6. 回溯算法"></a>6. 回溯算法</h2><p>回溯算法是算法设计中的一种思想，一种<strong>渐进式</strong>寻找并构建问题解决方式的策略，会先从一个可能的动作开始解决问题，如不行，就<strong>回溯选择另外一个动作</strong>，直到找到一个解</p>
<h3 id="1）全排列"><a href="#1）全排列" class="headerlink" title="1）全排列"></a>1）全排列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 输入 [1, 2, 3]</span><br><span class="line">// 输出 [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 时间复杂度 O(n!) n! = 1 * 2 * 3 * ··· * (n-1) * n;</span><br><span class="line">// 空间复杂度 O(n)</span><br><span class="line">var permute = function (nums) &#123;</span><br><span class="line">  // 存放结果</span><br><span class="line">  const res = [];</span><br><span class="line"></span><br><span class="line">  const backTrack = (path) =&gt; &#123;</span><br><span class="line">    // 递归结束条件 </span><br><span class="line">    if (path.length === nums.length) &#123;</span><br><span class="line">      res.push(path)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历传入数组</span><br><span class="line">    nums.forEach(n =&gt; &#123;</span><br><span class="line">      // 如果子数组中有这个元素就是死路， 需要回溯回去走其他路</span><br><span class="line">      if (path.includes(n)) return;</span><br><span class="line"></span><br><span class="line">      // 加入到子数组里</span><br><span class="line">      backTrack(path.concat(n))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  backTrack([])</span><br><span class="line"></span><br><span class="line">  return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2）子集"><a href="#2）子集" class="headerlink" title="2）子集"></a>2）子集</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 输入 [1,2,3]</span><br><span class="line">// 输出 [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ]</span><br><span class="line"></span><br><span class="line">// 时间复杂度 O(2 ^ N) 每个元素都有两种可能</span><br><span class="line">// 空间复杂度 O(N)</span><br><span class="line">var subsets = function (nums) &#123;</span><br><span class="line">  // 存放结果数组</span><br><span class="line">  const res = [];</span><br><span class="line"></span><br><span class="line">  const backTrack = (path, l, start) =&gt; &#123;</span><br><span class="line">    // 递归结束条件</span><br><span class="line">    if (path.length === l) &#123;</span><br><span class="line">      res.push(path)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历输入的数组长度 起始位置是start</span><br><span class="line">    for (let i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">      // 递归调用 需要保证子集的有序, start为 i+1</span><br><span class="line">      backTrack(path.concat(nums[i]), l, i + 1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 遍历输入数组长度</span><br><span class="line">  for (let i = 0; i &lt;= nums.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    // 传入长度 起始索引</span><br><span class="line">    backTrack([], i, 0)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="五、结语"><a href="#五、结语" class="headerlink" title="五、结语"></a><strong>五、结语</strong></h1><p>本文中，仅对常见和常用的数据结构与算法进行了演示</p>
<p>算法这个东西，平时还是要 <strong>多练</strong>。记得看完后多刷一刷leetcode</p>
<p>推荐阅读 点击标题可跳转</p>
<p>1、<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651616780&idx=2&sn=952dd3f12447a04a5eb0b3b02040e346&chksm=8022a1cdb75528db08308f2575463be0f69021a652cfeab21c99878cc9b0da5c172246f0a6a8&scene=21#wechat_redirect">js 从原型链到继承——图解来龙去脉</a></p>
<p>2、<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651616446&idx=1&sn=1236382ba91ae93ebf7daf84b1b914bd&chksm=8022a37fb7552a69a1b590eeeaaed6b9d49790d3132947b593ccc93334b13d21d8427e03bcfa&scene=21#wechat_redirect">JS 高级用法：像大神一样玩转 JavaScript</a></p>
<p>3、<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651616408&idx=2&sn=05a67e35136acfd7246ab0bb4d1182bf&chksm=8022a359b7552a4f9af74807f00f563b824db531586a5d9c83a3ef8d2cbc1d71d1fd12d0d27c&scene=21#wechat_redirect">线上BUG引起思考：package.json 中的 ^~ 该保留吗？</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://leejs.cn">李鹏辉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://leejs.cn/abd146cd/">https://leejs.cn/abd146cd/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://leejs.cn" target="_blank">Lee Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/js/">js</a></div><div class="post_share"><div class="social-share" data-image="https://images-origin.wallwiz.link/59c13437ccb8f80001ef65ea_1" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/9d2bd8d6/"><img class="prev-cover" src="https://images-origin.wallwiz.link/588609686e9f6a00013b8c2f_1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ts 问题</div></div></a></div><div class="next-post pull-right"><a href="/9d24bb23/"><img class="next-cover" src="https://images-origin.wallwiz.link/58860ea5bcf65400017a54f0_1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">前端工程化解决方案</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/880232555/" title="JS dom元素位置相关的内容"><img class="cover" src="https://images-origin.wallwiz.link/58860b88dc1d3f00010acdc1_1" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-27</div><div class="title">JS dom元素位置相关的内容</div></div></a></div><div><a href="/3315289936/" title="JS new 一个对象的过程"><img class="cover" src="https://images-origin.wallwiz.link/59c13468ccb8f80001ef663f_1" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-29</div><div class="title">JS new 一个对象的过程</div></div></a></div><div><a href="/proto/" title="JS __proto__和prototype的区别和关系"><img class="cover" src="https://images-origin.wallwiz.link/59c12ed68ac7580001ce9ef8_1" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-15</div><div class="title">JS __proto__和prototype的区别和关系</div></div></a></div><div><a href="/3915840815/" title="JS this"><img class="cover" src="https://images-origin.wallwiz.link/5891eb8635e2fb00012d3a4f_1" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-01</div><div class="title">JS this</div></div></a></div><div><a href="/prototype/" title="JS prototype"><img class="cover" src="https://images-origin.wallwiz.link/58860e96dc1d3f00010ad1e2_1" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-29</div><div class="title">JS prototype</div></div></a></div><div><a href="/3369490582/" title="JS typeof instanceof 你应该知道这么多"><img class="cover" src="https://images-origin.wallwiz.link/58860ebbbcf65400017a550f_1" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-01</div><div class="title">JS typeof instanceof 你应该知道这么多</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">李鹏辉</div><div class="author-info__description">学习 生活 成长</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">一、前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">二、基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.1.</span> <span class="toc-text">1. 时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.2.</span> <span class="toc-text">2. 空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">三、数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A0%88"><span class="toc-number">3.1.</span> <span class="toc-text">1. 栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="toc-number">3.1.1.</span> <span class="toc-text">1）十进制转二进制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="toc-number">3.1.2.</span> <span class="toc-text">2）判断字符串的有效括号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%98%9F%E5%88%97"><span class="toc-number">3.2.</span> <span class="toc-text">2. 队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E6%9C%80%E8%BF%91%E7%9A%84%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0"><span class="toc-number">3.2.1.</span> <span class="toc-text">1）最近的请求次数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.</span> <span class="toc-text">3. 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E6%89%8B%E5%86%99instanceOf"><span class="toc-number">3.3.1.</span> <span class="toc-text">1）手写instanceOf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">3.3.2.</span> <span class="toc-text">2）删除链表中的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="toc-number">3.3.3.</span> <span class="toc-text">3）删除排序链表中的重复元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.4.</span> <span class="toc-text">4）反转链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%9B%86%E5%90%88"><span class="toc-number">3.4.</span> <span class="toc-text">4. 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%8E%BB%E9%87%8D"><span class="toc-number">3.4.1.</span> <span class="toc-text">1）去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="toc-number">3.4.2.</span> <span class="toc-text">2）两个数组的交集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AD%97%E5%85%B8"><span class="toc-number">3.5.</span> <span class="toc-text">5. 字典</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">3.5.1.</span> <span class="toc-text">1）两数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86-1"><span class="toc-number">3.5.2.</span> <span class="toc-text">2）两个数组的交集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">3.5.3.</span> <span class="toc-text">3）字符的有效的括号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%97%E4%B8%B2"><span class="toc-number">3.5.4.</span> <span class="toc-text">4）最小覆盖字串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%A0%91"><span class="toc-number">3.6.</span> <span class="toc-text">6. 树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E6%99%AE%E9%80%9A%E6%A0%91"><span class="toc-number">3.6.1.</span> <span class="toc-text">1）普通树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">3.6.1.1.</span> <span class="toc-text">&gt; 深度优先遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">3.6.1.2.</span> <span class="toc-text">&gt; 广度优先遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.6.2.</span> <span class="toc-text">2）二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">&gt; 二叉树的先序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.6.2.2.</span> <span class="toc-text">&gt; 二叉树的中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.6.2.3.</span> <span class="toc-text">&gt; 二叉树的后序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">3.6.2.4.</span> <span class="toc-text">&gt; 二叉树的最大深度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="toc-number">3.6.2.5.</span> <span class="toc-text">&gt; 二叉树的最小深度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.6.2.6.</span> <span class="toc-text">&gt; 二叉树的层序遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%9B%BE"><span class="toc-number">3.7.</span> <span class="toc-text">7. 图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97"><span class="toc-number">3.7.1.</span> <span class="toc-text">1）有效数字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%A0%86"><span class="toc-number">3.8.</span> <span class="toc-text">8. 堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89JS%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%80%E5%B0%8F%E5%A0%86"><span class="toc-number">3.8.1.</span> <span class="toc-text">2）JS实现一个最小堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-number">3.8.2.</span> <span class="toc-text">2）数组中的第k个最大元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="toc-number">3.8.3.</span> <span class="toc-text">3）前 K 个高频元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%8F%8A%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">4.</span> <span class="toc-text">四、常见算法及算法思想</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8E%92%E5%BA%8F"><span class="toc-number">4.1.</span> <span class="toc-text">1. 排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text">1）冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">4.1.2.</span> <span class="toc-text">2）选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">4.1.3.</span> <span class="toc-text">3）插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">4.1.4.</span> <span class="toc-text">4）归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">4.1.4.1.</span> <span class="toc-text">&gt; 合并两个有序链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">4.1.5.</span> <span class="toc-text">5）快速排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%90%9C%E7%B4%A2"><span class="toc-number">4.2.</span> <span class="toc-text">2. 搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2"><span class="toc-number">4.2.1.</span> <span class="toc-text">1）顺序搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="toc-number">4.2.2.</span> <span class="toc-text">2）二分搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">&gt; 猜数字大小</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B"><span class="toc-number">4.3.</span> <span class="toc-text">3. 分而治之</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">4.3.1.</span> <span class="toc-text">1）归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">4.3.2.</span> <span class="toc-text">2）快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="toc-number">4.3.3.</span> <span class="toc-text">3）二分搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">&gt; 分而治之思想：猜数字大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">&gt; 分而治之思想：翻转二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91"><span class="toc-number">4.3.3.3.</span> <span class="toc-text">&gt; 分而治之思想：相同的树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gt-%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.3.3.4.</span> <span class="toc-text">&gt; 分而治之思想：对称二叉树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">4.4.</span> <span class="toc-text">4. 动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-number">4.4.1.</span> <span class="toc-text">1）斐波那契数列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">4.4.2.</span> <span class="toc-text">2）爬楼梯</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">4.5.</span> <span class="toc-text">5. 贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="toc-number">4.5.1.</span> <span class="toc-text">1）分发饼干</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E2%85%A1"><span class="toc-number">4.5.2.</span> <span class="toc-text">2）买卖股票的最佳时机Ⅱ</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-number">4.6.</span> <span class="toc-text">6. 回溯算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">4.6.1.</span> <span class="toc-text">1）全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%AD%90%E9%9B%86"><span class="toc-number">4.6.2.</span> <span class="toc-text">2）子集</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%BB%93%E8%AF%AD"><span class="toc-number">5.</span> <span class="toc-text">五、结语</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/a3f55816/" title="理想国 第一卷"><img src="https://images-origin.wallwiz.link/58860b456e9f6a00013b8f0f_1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="理想国 第一卷"/></a><div class="content"><a class="title" href="/a3f55816/" title="理想国 第一卷">理想国 第一卷</a><time datetime="2023-12-01T07:55:06.000Z" title="发表于 2023-12-01 15:55:06">2023-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/34588bfd/" title="TS 基础中的基础"><img src="https://images-origin.wallwiz.link/58860b9a6e9f6a00013b8f89_1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TS 基础中的基础"/></a><div class="content"><a class="title" href="/34588bfd/" title="TS 基础中的基础">TS 基础中的基础</a><time datetime="2023-12-01T03:38:30.000Z" title="发表于 2023-12-01 11:38:30">2023-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2fe79698/" title="canvas VS WebGL"><img src="https://images-origin.wallwiz.link/59c13468ccb8f80001ef663f_1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="canvas VS WebGL"/></a><div class="content"><a class="title" href="/2fe79698/" title="canvas VS WebGL">canvas VS WebGL</a><time datetime="2023-11-01T11:13:19.000Z" title="发表于 2023-11-01 19:13:19">2023-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/sushu/" title="素书"><img src="https://images-origin.wallwiz.link/58860e926e9f6a00013b9386_1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="素书"/></a><div class="content"><a class="title" href="/sushu/" title="素书">素书</a><time datetime="2023-10-26T11:26:01.000Z" title="发表于 2023-10-26 19:26:01">2023-10-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/d396855b/" title="来处一个老程序员的忠告"><img src="https://images-origin.wallwiz.link/590bca5f90c79d0001e9cbff_1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="来处一个老程序员的忠告"/></a><div class="content"><a class="title" href="/d396855b/" title="来处一个老程序员的忠告">来处一个老程序员的忠告</a><time datetime="2023-10-19T05:45:55.000Z" title="发表于 2023-10-19 13:45:55">2023-10-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 李鹏辉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>