{"meta":{"title":".org Blog","subtitle":"Penghui's Blog","description":"记录学习 记录生活 记录成长","author":"李鹏辉","url":"http://didiorg.com","root":"/"},"pages":[{"title":"标签","date":"2019-11-21T03:26:15.000Z","updated":"2020-11-02T16:09:11.000Z","comments":true,"path":"tags/index.html","permalink":"http://didiorg.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-11-21T03:26:33.000Z","updated":"2020-11-02T16:09:10.000Z","comments":true,"path":"categories/index.html","permalink":"http://didiorg.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-11-21T03:26:43.000Z","updated":"2020-11-02T16:09:10.000Z","comments":true,"path":"about/index.html","permalink":"http://didiorg.com/about/index.html","excerpt":"","text":"李鹏辉 男 1992年5月生 身高：183 cm 体重：75 Kg 滴滴出行高级软件工程师 前端开发 爱好：滑雪、摄影、篮球、健身"}],"posts":[{"title":"cli","slug":"serverless/baidu-cli","date":"2022-07-24T15:47:13.000Z","updated":"2022-08-02T02:40:50.228Z","comments":true,"path":"/1224102205/","link":"","permalink":"http://didiorg.com/1224102205/","excerpt":"","text":"工具安装 安装 docker 桌面版: docker官网 安装 bsam cli 执行 sudo pip3 install bce-sam-cli 即可完成安装。 遇到问题： zsh: command not found: bsam ;原因是之前没有加 sudo 创建函数 初始化项目： bsam init --runtime nodejs12 --name lee-app 函数安装依赖： cd src npm install bsam local install 部署 打包 bsam package 发布 bsam deploy 发布之前要去配置 config， 把百度帐号的信息跟本地的cli绑定起来， 创建&#x2F;获取 AK&#x2F;SK执行 bsam configBCE Access Key ID:BCE Secret Access Key:BCE region (bj, gz, su): 执行完deploy命令后， 可到页面函数列表里边去看函数是否发布成功， 如果成功了， 就会在函数列表里边有 测试 本地 去src下边用 mocha 进行测试， 执行 npm run test CFC 函数列表可以进行测试点击函数列表后面的测试操作就可以 调用 添加一个触发器 http的触发器可以直接在浏览器地址栏访问览器地址栏访问","categories":[],"tags":[]},{"title":"fix","slug":"ts/fix","date":"2022-07-15T15:13:23.000Z","updated":"2022-08-02T02:44:51.377Z","comments":true,"path":"/1509574496/","link":"","permalink":"http://didiorg.com/1509574496/","excerpt":"","text":"如何在TypeScript中的window上显式设置新属性？ 要保持动态，只需使用： (window).MyNamespace","categories":[],"tags":[]},{"title":"output","slug":"tool/rollup/output","date":"2022-07-15T02:39:12.000Z","updated":"2022-08-02T02:44:29.007Z","comments":true,"path":"/3437106334/","link":"","permalink":"http://didiorg.com/3437106334/","excerpt":"","text":"Rollup 输出的不同格式js文件对比1amd , cjs , esm , iife , umd , system 一、IIFE 自执行函数 IIFE 的全称是 “immediately invoked function expression”。 1.1 打包结果分析让我们先看看本 demo 的 iife 格式打出来的包长什么样。 对上述代码做一些简化： 123456789101112131415161718192021var Test = (function (exports, lodash) &#123; &#x27;use strict&#x27;; // 自带严格模式，避免一些奇怪的兼容性问题 /** * 下面折行无用代码被 tree-shaking 掉了 * const unusedVar = &#x27;May the 4th&#x27; * */ var answer = 42; // 业务中被单一引用的模块，被直接抹平了 const printAnswer = () =&gt; &#123; console.log(`the answer is $&#123;answer&#125;`); console.log(lodash.repeat(&#x27;1&#x27;, answer)); &#125;; exports.printAnswer = printAnswer; // 把要export的属性挂在到exports上 return exports;&#125;)(&#123;&#125;, $); // exports是第一个入参，依赖的jquery是第二个入参 IIFE 是前端模块化早期的产物，它的核心思路是: 构建一个匿名函数 立刻执行这个匿名函数，对外部的依赖通过入参的形式传入 返回该模块的输出 1.2 如何运行IIFE 的运行其实很容易，如果它没有其他依赖，只需要去引入文件，然后在 window 上取相应的变量即可。如： 12345&lt;script src=&quot;http://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // jquery 就是典型的自执行函数模式，当你引入后，他就会挂在到 window.$ 上 window.$ // 这样就能取到 jquery 了&lt;/script&gt; 但是如果你像本 demo 中那样依赖了其他的模块，那你就必须保证以下两点才能正常运行： 此包所依赖的包，已在此包之前完成加载。 前置依赖的包，和 IIFE 只执行入参的变量命名是一致的。 以本 demo 的 IIFE 构建结果为例： 它前置依赖了 lodash，因此需要在它加载之前完成 lodash 的加载。 此 IIFE 的第二个入参是 lodash，作为前置条件，我们需要让 window.lodash 也指向 lodash。因此，运行时，代码如下： 12345678910&lt;head&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/lodash.js/4.17.21/lodash.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt;window.lodash = window._&lt;/script&gt; &lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; window.Test.printAnswer(); &lt;/script&gt;&lt;/body&gt; 1.3 优缺点 优点: 通过闭包营造了一个“私有”命名空间，防止影响全局，并防止被从外部修改私有变量。 简单易懂 对代码体积的影响不大 缺点： 输出的变量可能影响全局变量；引入依赖包时依赖全局变量。 需要使用者自行维护 script 标签的加载顺序。 优点就不细说了，缺点详细解释一下。 缺点一：输出的变量可能影响全局变量；引入依赖包时依赖全局变量。 前半句：输出的变量可能影响全局变量; 其实很好理解，以上面 demo 的输出为例： window.Test 就已经被影响了。这种明显的副作用在程序中其实是有隐患的。 后半句：引入依赖包时依赖全局变量； 我们为了让 demo 正常运行，因此加了一行代码让 window.lodash 也指向 lodash，但它确实是太脆弱了。 12&lt;!-- 没有这一行，demo就无法正常运行 --&gt;&lt;script&gt;window.lodash = window._&lt;/script&gt; 你瞧，IIFE 的执行对环境的依赖是苛刻的，除非它完全不依赖外部包。（Jquery: 正是在下！） 虽然 IIFE 的缺点很多，但并不妨碍它在 Jquery 时代极大地推动了 web 开发的进程，因为它确实解决了 js 本身存在的很多问题。 那么？后续是否还有 更为优秀 的前端模块化方案问世呢？ 当然有，往下看吧。 二、CommonJS2.1 分析打包结果先看看 CommonJs 打包的结果:简化一下，就长这样了： 1234567891011121314&#x27;use strict&#x27;;var lodash = require(&#x27;lodash&#x27;);var answer = 42;const printAnswer = () =&gt; &#123; // 打印 console.log(`the answer is $&#123;answer&#125;`); // 测试 lodash 的能力，打印42个1 console.log(lodash.repeat(&#x27;1&#x27;, answer));&#125;;exports.printAnswer = printAnswer; 以上格式，就是 CommonJS 规范的写法。 1234567// CommonJS 通过一个全局 require 方法进行模块的引入 var lodash = require(&#x27;lodash&#x27;);// CommonJS 进行模块内方法输出的方式module.exports.printAnswer = printAnswer;// 上面写法也等价于：exports.printAnswer = printAnswer;// 因为 exports 变量等价于 module.exports 为了解决 node.js 在模块化上的缺失， 2009年10月 CommonJS 规范首次被提出。 注意这个关键词： node.js。 是的，CommonJS 并不是在浏览器环境运行的规范，而是在 node.js 环境下运行的。 2.2 如何运行因此，我写了一个 run.js 脚本。如下： 123// run.jsconst Test = require(&#x27;./bundle-by-lodash&#x27;)Test.printAnswer() 然后，执行以下命令： 123456# 执行脚本node ./out/cjs/run.js # 输出1： &gt; the answer is 42# 输出2： &gt; 111111111111111111111111111111111111111111 可以看出，node.js 环境是天然支持 CommonJS 的。 2.3 优缺点 优点 完善的模块化方案，完美解决了 IIFE 的各种缺点。 缺点 不支持浏览器环境，因为这种同步的引入方式可能导致浏览器假死。 因此，前端界迫切地需要一种能在浏览器环境完美运行，完善的模块化方案。 三、AMD 和 requirejs ! AMD，YES! 2011年， amdjs-api 在业内被正式提出。 3.1 打包结果分析amd 格式的打包结果如下：可以看到，核心内容是一个全局方法 define 。 define 方法有三个入参，分别是： &quot;Test&quot;, 模块名称 [exports,lodash] 分别表示模块的输出和外部依赖 一个以 exports 和 lodash 作为入参的方法，代表模块的实际内容。 相比于 IIFE 和 CommonJs 而言，AMD 的写法无疑是复杂且别扭的。 但它却实实在在是解决了 IIFE 和 CommonJS 所面临的问题，对“浏览器里完善的JS模块方法” 提供了一套完善的方案。 尤其是 amd 标准的实现方案：requirejs。 requirejs 所实现的 AMD 不仅解决了 CommonJS 在浏览器端的不适，通过异步的方式进行模块加载实现了不会导致假死的能力；更是完全弥补了 IIFE 存在的各类缺陷。 requirejs 在使用时，一般情况下是以下四步法： 在浏览器内引入 require.js 通过 requirejs.config 方法定义全局的依赖 通过 requirejs.define 注册模块 通过 requirejs() 完成模块引入。 3.2 如何运行在 out/amd 打包目录下的 index.html 里，按如下方式编排代码： 12345678910111213141516171819202122232425&lt;head&gt; &lt;!-- 1. 引入 require.js --&gt; &lt;script src=&quot;./require.js&quot;&gt;&lt;/script&gt; &lt;!-- 2. 定义全局依赖 --&gt; &lt;script&gt; window.requirejs.config(&#123; paths: &#123; &quot;lodash&quot;: &quot;https://cdn.bootcdn.net/ajax/libs/lodash.js/4.17.21/lodash.min&quot; &#125; &#125;); &lt;/script&gt; &lt;!-- 3. 定义模块 --&gt; &lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 4. 开销模块 window.requirejs( [&#x27;Test&#x27;], function (test) &#123; test.printAnswer() &#125; ); &lt;/script&gt;&lt;/body&gt; 打开浏览器，我们可以正常地看到]控制台里被打印出来的 42 和 42个1 了。 3.3 优缺点 优点 解决了 CommonJS 的缺点 解决了 IIFE 的缺点 一套完备的浏览器里 js 文件模块化方案 缺点 代码组织形式别扭，可读性差 但好在我们拥有了各类打包工具，浏览器内的代码可读性再差也并不影响我们写出可读性ok的代码。 现在，我们拥有了面向 node.js 的 CommonJs 和 面向浏览器的 AMD 两套标准。 如果我希望我写出的代码能同时被浏览器和nodejs识别，我应该怎么做呢？ 四、UMD 伟大的整合 它没有做什么突破性的创造，但它是集大成者。 4.1 打包分析umd 格式构建出来的代码的可读性进一步降低了。 我相信任何正常人看到下面这段代码都会感到一阵头大： 是的，整整一大段代码，只是在处理兼容性问题，判断当前应该使用 amd 亦或是 CommonJS。 因此 umd 的代码和实现不在此进行过多分析，它所做的无非便是让同一段代码兼容了 amd 和 CommonJS。 4.2 如何运行？ 在浏览器端，它的运行方式和 amd 完全一致，可以完全参考 3.2 节的 demo。 在node.js端，它则和 CommonJS 的运行方式完全一致，在此就不赘述了。 4.3 优缺点 优点 抹平了一个包在 AMD 和 CommonJS 里的差异 缺点 会为了兼容产生大量不好理解的代码。（理解难度与包体积） 虽然在社区的不断努力下，CommonJS 、 AMD 、 UMD 都给业界交出了自己的答卷。 但很显然，它们都是不得已的选择。 浏览器应该有自己的加载标准。 ES6 草案里，虽然描述了模块应该如何被加载，但它没有 “加载程序的规范”。 五、SystemJs因此 WHATWG（Web Hypertext Application Technology Working Group） 即网页超文本应用技术工作小组，提出了一套更有远见的规范：whatwg&#x2F;loader。 也就是 JavaScript Loader Standard （JS 加载标准）。 本规范描述了从 JavaScript 宿主环境中加载 JavaScript 模块的行为。它还提供了用于拦截模块加载过程和自定义加载行为的 api。 基于此规范，SystemJS 诞生了。 SystemJS 是目前 whatwg/loader 规范的最佳实践者。 可以看出来，system 的打包结果其实和 amd 类似，提供了全局的对象 System，并提供了注册的方式和统一的写法。 就单纯的从打包结果上，其实看不出它相比对 AMD + require.js 有什么优势，难道只是写法上存在差异? 并不止于此！ 相比于 require.js，SystemJS 的 System.import(&#39;module/name&#39;) 方式允许你更为“懒”地加载模块，这意味着你无需每次都加载一大堆的 bundle，用户只需要为他能看见的页面开销带宽。 另外，正因为 SystemJS 是面向 whatwg/loader 规范实践的，因此它是面向未来的模块依赖方式。 抱歉，这个的 demo 我也没玩明白，就不误导大家了。希望有明白的大佬可以帮忙完善下demo。 六、ESM ECMAScript modules, 也叫 ESM, Javascript 模块化官方标准格式。 6.1 打包分析在 ESM 被提出来之前，JavaScript 一直没有真正意义上的模块（module）体系。 它的规范是通过 export 命令显式指定输出的代码，再通过 import 命令输入。 1234// 导入模块import &#123; foo &#125; from &#x27;bar&#x27;;// 导出命令export &#123; zap &#125;; 这也是我们日常开发中最为熟悉的写法。 因此，esm 格式打出来的包，可读性确实非常棒: 和阅读我们平时所写的业务代码完全没有区别。（rollup 依然没忘记做 tree-shaking） 6.2 如何运行 祝贺你，是这个时代的前端开发。 部分现代浏览器已经开始实装 &lt;script type=&quot;module&gt; 了，因此在浏览器上直接使用 esm 已成为现实。 但运行起来扔需要做一些前置步骤。 在js-modules目录下起一个本地静态服务 12# 在js-modules目录下起一个本地静态服务cd js-modules &amp;&amp; http-server 把 esm/bundle.js 文件的第一行修改为： 12import repeat from &#x27;../../node_modules/lodash-es/repeat.js&#x27;;// 因为默认的lodash并不是输出的 esm 格式，因此为了demo我们需要做一些特殊处理 在浏览器打开页面(假设端口是8080)，则打开：http://127.0.0.1:8080/out/esm/index.html 这样一来，代码就能成功运行，控制台就可以成功打印 42 和 42个1 了。 总结：分别适合在什么场景使用？ IIFE: 适合部分场景作为SDK进行使用，尤其是需要把自己挂到 window 上的场景。 CommonJS: 仅node.js使用的库。 AMD: 只需要在浏览器端使用的场景。 UMD: 既可能在浏览器端也可能在node.js里使用的场景。 SystemJs: 和UMD类似。目前较出名的 Angular 用的就是它。 ESM: 1. 还会被引用、二次编译的场景（如组件库等）；2.浏览器调试场景如 vite.js的开发时。3.对浏览器兼容性非常宽松的场景。 原文地址","categories":[],"tags":[]},{"title":"life","slug":"live/life","date":"2022-07-12T11:54:38.000Z","updated":"2022-08-02T02:40:28.708Z","comments":true,"path":"/432881407/","link":"","permalink":"http://didiorg.com/432881407/","excerpt":"","text":"男人的成熟只需要一瞬间—– 2022.7.10 看完《人生大事》 《人生大事》","categories":[],"tags":[]},{"title":"watch","slug":"vue3/watch","date":"2022-07-12T08:41:19.000Z","updated":"2022-08-02T02:44:56.848Z","comments":true,"path":"/1342917158/","link":"","permalink":"http://didiorg.com/1342917158/","excerpt":"","text":"vue3中 watch、watchEffect区别1、watch是惰性执行，也就是只有监听的值发生变化的时候才会执行，但是watchEffect不同，每次代码加载watchEffect都会执行（忽略watch第三个参数的配置，如果修改配置项也可以实现立即执行） 2、watch需要传递监听的对象，watchEffect不需要 3、watch只能监听响应式数据：ref定义的属性和reactive定义的对象，如果直接监听reactive定义对象中的属性是不允许的，除非使用函数转换一下 4、watchEffect如果监听reactive定义的对象是不起作用的，只能监听对象中的属性。 123456789101112131415161718let count = ref(0)let countObj = reactive(&#123;count: 0&#125;)// 惰性，首次加载不执行watch(count, (newVal, oldVal) =&gt;&#123;console.log(newVal, oldVal)&#125; )// watch 不能直接监听reactive里面的属性，只能监听ref、reactiveObject， function， array, 如果想监听reactive的某个属性，那么需要转换成函数watch(() =&gt; countObj.count, (newVal, oldVal) =&gt; &#123;console.log(oldVal, newVal)&#125;, &#123;&#125;)watch (countObj, (newVal, oldVal) =&gt; &#123; console.log(newVal, oldVal)&#125;)// 监听多个值，前面是监听数据的数组，后面的参数是两个数组，前面数组是变化后监听对象值的数组，后面是变化前监听对象值的数组watch ([countObj, count], ([oneNewName, twoNewName], [oneOldName, twoOldName]) =&gt; &#123; console.log(oneNewName, oneOldName, twoNewName, twoOldName)&#125;)// watchEffect，和watch不一样，1、会立即执行，只要定义了就会执行。2、他只能监听某个值，监听对象不管用。3、不需要传递参数，会自动管制代码中的变量。4、没法获取newVal和oldValconst watchEf = watchEffect(() =&gt; &#123; console.log(countObj.count)&#125;) 参考 原文地址","categories":[],"tags":[]},{"title":"d1","slug":"ddd/ddd","date":"2022-07-11T06:16:56.000Z","updated":"2022-08-02T02:40:21.713Z","comments":true,"path":"/295091303/","link":"","permalink":"http://didiorg.com/295091303/","excerpt":"","text":"Domain Driven Design（DDD）是Eric Evans于2004在其同名著作里提出的概念，它指明了让软件设计满足理想需求模型的方向。但是建模、设计这种事本来就很抽象，读懂这样的大作也是需要消耗不少脑细胞。本文希望能尽量以简单加实例的方式介绍DDD里的一些常见概念。 简介什么是领域《领域驱动设计》书里写的是：用户会把软件程序应用于某个主体区域，这个区域就是软件的领域。简单来说，就认为是公司的某块业务好了。如果领域比较大，可以将其拆分为多个子域（Subdomain），子域包含核心域（Core Domain）和支撑子域（Supporting Subdomain），核心域顾名思义，是最重要的子域，我们应该把关注点集中在它上面；其余的子域都是支撑子域。支撑子域里有一类特殊的用于解决通用问题的子域，称为通用子域（Generic Subdomain），例如用户和权限等。不过这些都是相对而言的，对于消费方来说，他的支撑子域有可能就是你的核心域。个别子域可能会有交集，称为共享内核（Shared Kernel），目的是减少重复，但是仍保持两个独立的上下文。由于不同子域的开发团队可能会同时修改共享内核，所以需要小心并注意沟通。 要DDD做什么DDD试图解决的是软件的复杂性问题，如果软件比较复杂，或者是预期会很复杂，或者是你不知道，那么都可以开始考虑DDD。否则，由于维系领域模型需要实现大量的封装和隔离，DDD会带来较大的成本。但是，DDD并不是一个笨重的开发过程，它能够和敏捷开发很好地结合起来，另外，DDD也倾向于“测试先行，逐步改进”。 战略建模（Strategic Modeling）通用语言（Ubiquitous Language）其实写软件就像是翻译，把领域上的业务需求翻译成软件的各个功能。业务需求来自领域专家（Domain Expert），程序员们需要把领域专家的语言翻译成程序。如果程序员们翻译的时候使用的是自己的语言，而领域专家使用自己的行话，导致术语不一致，就会使得沟通不顺畅，难于消化知识。所以团队需要一种通用语言来进行沟通。这样的通用语言尽量以业务语言为主，而非技术语言。一开始的通用语言可能不尽完美，但它就像是代码一样，经常需要重构。例如：“创建一个订单”就比“插入一条订单数据”更容易让领域专家明白谈话的背景。 限界上下文（Bounded Context）通用语言里，同一个名词在不同的场景里不一定有相同的意思。比如用户，在推荐好友（可能关注年龄、性别、地域）或是浏览商品（可能关注喜好、历史购买记录）的时候有着不同的含义。所谓的不同的场景，其实就是不同的限界上下文。子域在限界上下文中完成开发。限界上下文主要用来封装通用语言和领域模型，显式地定义了领域模型的边界。不同的限界上下文，都会有一套自己的通用语言。通过这样的划分方式，来让每个限界上下文都尽量保持简单，也算是SRP原则在不同粒度上的一个体现。如果不去做这样的划分，可能最终这个软件就会演变成一个大泥球，或者说是单块系统。尽管如此，对于比较小的业务或项目来说，可能只会有一个限界上下文。现在流行的微服务，很大程度上就是按照限界上下文来划分服务。例如：商品上下文，订单上下文，物流上下文等。当然，如果子域很小，不见得非得微服务化。 不同的限界上下文之间，通过上下文映射图（Context Map）来进行交互。上下文映射图其实就是一个简单的框图，表示限界上下文之间的的映射关系。下面这张图就是一个简单的例子： U表示上游（Upstream）的被依赖方，D表示下游（Downstream）的依赖方。由于上下游的限界上下文模型不同，实现时，可以用RPC、Restful、消息机制等集成方式。另外，下游需要防腐层（Anticorruption Layer）来将上游的返回内容翻译为下游的领域模型。如果防腐层过多地使用了各种赋值，从而导致上下游的模型非常类似，那就需要看看是否下游过多地使用了上游的数据，从而导致自己的模型不清晰。 战术建模（Tactical Modeling）模型实体（Entity）所谓领域，反映到代码里就是模型。模型分为实体和值对象两种。实体是有标识（Identity）的，两个拥有相同属性的实体不是相等的，除非它们的标识相等；而不同实体的标识不能相等。例如：某人下了两个相同的订单，里面都购买了相同的商品。这两个订单就是有标识（订单号）的两个实体，虽然内容相同，但它们是两个不同的实体。常用的标识有自增数字、Guid、自然标识（如邮箱、身份证号）等。实体具有生命周期，它们的内容可能在这期间会发生改变，但是标识是永远不会变化的。实体作为领域模型的主体，需要拥有自己的方法，方法名来自于通用语言。通过这些方法来保证自己始终是一致的状态，而非被调用者set来set去。例如：people.runTo(x, y)，而非people.setX(x);people.setY(y); 值对象（Value Object）实体用来表示领域中的一个东西，而值对象只用于描述或度量一个东西。值对象没有任何标识，只要两个值对象的属性相等，那么它们就是相等的。值对象是不可变的，如果要改变值对象的内容，那就重新创建一个值对象。值对象没有生命周期，因为它只是值而已。例如：金额（含数值和货币单位），颜色（含rgb值）等。因为不需要标识，所以它们其实比实体要简单许多。Java里的String类，就具有一个值对象的行为；C#的Struct其实就是一个值对象，不过一般还是会用Class来表示值对象。 不同的领域需求可能会催生不同的建模。例如：考虑一下演出的售票系统。如果需求是对号入座，那么座位就是实体，一旦某张演出票关联了某个座位，那么这个座位就再也不能被其它的演出票所关联了。如果需求是先到先坐，那么座位就是值对象，我们只关心卖了多少张演出票，不要超过座位上限即可，而并不用关心哪个座位被哪张票所关联了。 DDD的一个反模式就是拥有一堆get和set方法的贫血领域对象（Anemic Domain Object）。这样的对象只是一个数据持有器（data holder），而非我们想要的领域模型。值对象和实体一样，都需要有自己的方法。例如：金额值对象，有一个Add的方法，接受一个金额参数，返回一个新的值对象。 实体里可以包含值对象，值对象里也可以包含实体。 领域服务（Domain Service）有些操作不属于实体或者值对象，那就不用强塞给它们，创建领域服务来提供这些操作吧。留意通用语言，如果里面出现了名词，那一般就是实体或值对象；如果里面出现了动词，那通常就意味着领域服务。例如：支付，这是一个比较明显的业务操作。另外，如果有什么操作会让实体变得臃肿，也可以使用领域服务来解决。但是，不能把所有的东西都堆到领域服务里，过度使用领域服务会导致贫血对象的产生。 据Eric Evans所言，设计良好的领域服务具有以下三个特征： 操作不是实体&#x2F;值对象的一个自然的部分 接口根据领域模型的其它元素定义 操作无状态 还需要注意的是，不要把领域服务和应用服务混起来了。我们在领域服务里处理业务逻辑，而并不在应用服务里处理。应用服务是领域模型的直接客户，负责处理事务、安全等操作。 领域事件（Domain Event）《领域驱动设计》一书出版之后，DDD社区并没有停止前进的步伐。领域事件就是在那之后提出来的。领域事件是一个定义了领域专家所关心的事件的对象。当关心的状态由于模型行为而发生改变时，系统将发布领域事件。如果通用语言里出现了：“当……的时候，需要……”通常就意味着一个领域事件。例如：当订单完成支付时，商品需要出库。这里的订单完成支付就预示着一个OrderPaidEvent，里面持有着这个订单的标识。领域事件代表的是已经发生的事，所以命名上通常都使用过去时（如Paid）。对领域事件的处理就像是一个观察者模式，由领域事件的订阅方来决定。订阅方既可以是本地的限界上下文，也可以是外部的限界上下文。 模块（Module）如果领域模型发展得比较快，很难整体来讨论它，因为太大了。我们可以将模块视为Java中的包或是C#中的命名空间。将模型组织到不同的模块中，可以有效地降低领域的复杂性。模块之间应该是低耦合的，而模块内部应该是高内聚的。模块的名称应该是通用语言的组成部分，反映出领域的深层知识。 生命周期聚合（Aggregate）聚合就是一组应该呆在一起的对象，聚合根（Aggregate Root）就是聚合在一起的基础，并提供对这个聚合的操作。聚合除了聚合根以外，还有自己的边界（boundary），即聚合里有什么。例如：一个订单可以有多个订单明细，订单明细不可能脱离订单而存在，而订单也不可能没有订单明细。这种情况下，订单和订单明细就是一个聚合，而订单就是这个聚合的聚合根，订单和订单明细就处于这个聚合的边界之内。如果要变更订单明细，我们需要通过操作聚合根订单来实现，如order.changeItemCount()，而非订单明细自身。另外一个例子：一名客户可以有多个订单，订单不可能脱离客户而存在，而客户却可以没有订单。这种情况下，客户和订单就是不同的两个聚合，一个聚合以客户为聚合根，另一个聚合以订单为聚合根，引用客户的标识。客户里并不引用订单的标识，这样将关联减至最少有助于简化对象的关系网。但是带来的一个麻烦就是如果要查找某位客户的所有订单，就不得不从所有的订单里查，而不能从客户这个聚合里直接获得。最后再举一个多对多的例子：一个班级可以有多名学生，学生可以脱离这个班级而存在，而班级不能没有学生，学生也不能不在班级里。这种情况下，班级和学生也是不同的两个聚合，一个聚合以班级为聚合根，引用学生的标识；另一个聚合以学生为聚合根，引用班级的标识，将多对多转换成两个一对多。 聚合是持久化的一个单位，我们需要保证以聚合为单位的数据一致性。如果聚合太大，那就会导致并发修改困难，多人并发修改同一个聚合里的不同项目，结果就是只有第一个提交的人成功修改，其它人不得不重新刷新聚合才能再次修改。大聚合还会导致性能问题，因为操作实体时会将整个大聚合同时加载进内存。珍爱生命，拒绝大聚合。 聚合根必须是实体而非值对象，因为它需要整体持久化，所以一定会有标识。而聚合根里的各个元素，既可能是实体，也可能是值对象。例如：一个订单（聚合根）一般会有订单明细（实体）和送货地址（值对象）。这些元素里可以有对聚合根的引用，但是不能相互引用。任何对其它元素的操作都必须通过聚合根来进行。聚合根里的标识是全局的，聚合根里的实体标识是聚合里唯一的本地标识，因为对它的访问都是通过聚合根来操作的。聚合根拥有自己独立的生命周期，其实体的生命周期从属于其所属的聚合，值对象因为只是值而已，并没有生命周期。 工厂（Factory）工厂是生命周期的开始阶段，它可以用来创建复杂的对象或是一整个聚合。复杂对象的创建是领域层的职责，但它并不属于被创建的对象自身的职责。实体和值对象的工厂不太一样，因为值对象是不可变的，所以需要工厂一次性创建一个完整的值对象出来。而实体工厂则可以选择创建之后再补充一些细节。 资源库（Repository）资源库是生命周期的结束，它封装了基础设施以提供查询和持久化聚合的操作。这样能够让我们始终聚焦于模型，而把对象的存储和访问都委托给资源库来完成。以订单和订单明细的聚合为例，因为一定是通过订单这个聚合根来获取订单明细，所以可以有订单的资源库，但是不能有订单明细的资源库。也就是说，只有聚合才拥有资源库。需要注意的是，资源库并不是数据库的封装，而是领域层与基础设施之间的桥梁。DDD关心的是领域内的模型，而并非是数据库的操作。理想的资源库对客户（而非开发者）隐藏了内部的工作细节，委托基础设施层来干那些脏活，到关系型数据库、NOSQL、甚至内存里读取和存储数据。��和存储数据。","categories":[],"tags":[]},{"title":"d5","slug":"ddd/单一功能原则","date":"2022-07-11T06:16:56.000Z","updated":"2022-08-02T02:40:21.712Z","comments":true,"path":"/385579136/","link":"","permalink":"http://didiorg.com/385579136/","excerpt":"","text":"单一功能原则在面向对象编程领域中，单一功能原则（Single responsibility principle）规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。 这个术语由罗伯特·C·马丁（Robert Cecil Martin）在他的《敏捷软件开发，原则，模式和实践》一书中的一篇名为〈面向对象设计原则〉的文章中给出。 [1] 马丁表述该原则是基于的《结构化分析和系统规格》[2]一书中的内聚原则（Cohesion）上。 马丁把功能（职责）定义为：“改变的原因”，并且总结出一个类或者模块应该有且只有一个改变的原因。一个具体的例子就是，想象有一个用于编辑和打印报表的模块。这样的一个模块存在两个改变的原因。第一，报表的内容可以改变（编辑）。第二，报表的格式可以改变（打印）。这两方面的改变会因为完全不同的起因而发生：一个是本质的修改，一个是表面的修改。单一功能原则认为这两方面的问题事实上是两个分离的功能，因此他们应该分离在不同的类或者模块里。把有不同的改变原因的事物耦合在一起的设计是糟糕的。 保持一个类专注于单一功能点上的一个重要的原因是，它会使得类更加的健壮。继续上面的例子，如果有一个对于报表编辑流程的修改，那么将存在极大的危险性，因为假设这两个功能存在于同一个类中，修改报表的编辑流程会导致公共状态或者依赖关系的改变，打印功能的代码会因此不工作。 因此不工作。","categories":[],"tags":[]},{"title":"d2","slug":"ddd/业务模块","date":"2022-07-11T06:16:56.000Z","updated":"2022-08-02T02:40:21.711Z","comments":true,"path":"/2292182493/","link":"","permalink":"http://didiorg.com/2292182493/","excerpt":"","text":"业务系统和一般的应用有非常大的不同，一般的应用以提供给公司&#x2F;企业外的用户（消费者、普通玩家）提供服务，以完成2C的销售目的，而业务系统一般是2B或者自身消费的模式，完成的是自身业务的管理目标。所以，应用侧重服务，业务系统侧重管理。两者的不同，导致我们对项目开发中，代码的组织方式会有差别。2C应用要满足大量用户在使用时的舒适性，因此要提高项目中有关性能、用户体验、效果等方面的要求，以吸引用户付费。但业务系统则稍有差别，虽然系统的使用体验也很重要，但是不是占最重要的部分，业务系统最重要的部分，是必须保证用户看到的数据、流程等，必须与真实的业务、业务流程一致，否则会带来自身利益的损失，因此，在稳健性、安全性等方面要求更高。 什么是业务模块？首先，什么是业务系统？在这之前，又必须回答什么是业务？业务（Business）专指商业活动，是实现企业生产到利益回收的一个环节，它的总和，构成了该企业盈利活动的整个流程。一般而言，我们所指的业务是企业商业活动中的一个部分，有的甚至小到一个环节，例如“结算”这个环节。业务系统则是辅助这些商业活动的计算机在线系统，以信息化的形式管理和决策企业的商业活动（理论上没有业务系统企业也能运转，但信息化社会没有业务系统会让企业寸步难行）。 大部分情况下，业务系统会尽可能多的囊括企业的业务环节，其目标是将企业的所有商业管理在线化，完成除必须在线下完成的实体业务之外的所有管理活动。而且，通过业务系统的数据积累，可以让企业基于已有数据进行深入决策，比只有线下管理的竞争对手高出多个维度。企业的管理者和员工使用业务系统，参与到企业的各个业务环节，参与形式各有不同，根据员工的角色来决定，比如有的员工不接触系统界面，只通过工卡完成各项流程的录入，有的员工则需要完成在线申请或审批，有的员工需要使用复杂的第三方工具完成系统录入等等。 业务模块，是以业务系统的建设者（领域专家、系统工程师等）的角度看待业务系统时，将庞大的业务系统，按照某个业务活动的边界，进行划分的某个单元。但是技术上，一般一个模块还是粒度比较大的单元。一般而言，业务模块囊括了系统关于该业务的所有内容，且和其他业务有明显的界限，理论上，可以在脱离了其他业务模块的情况下独立运行。 有了以上的认知，我们就知道，我们需要掌握企业在某个业务中，不同的参与者都是如何工作的。在该业务模块没有上线到业务系统中时，没人能明确的告诉你这个业务模块应该长什么样子，你需要走访业务的参与成员，了解他们实际是怎么工作的，然后再思考，如果要将这些工作迁移到线上，应该关注哪些方面，是用户的操作形式？是界面的友好风格？是信息的准确？但是应该注意一点，如果业务系统致使工作效率降低，那么说明设计该系统的人没有真正掌握企业商业活动的核心要点。动的核心要点。","categories":[],"tags":[]},{"title":"d0","slug":"ddd/自己对ddd的理解","date":"2022-07-11T06:16:56.000Z","updated":"2022-08-02T02:40:21.713Z","comments":true,"path":"/1720814833/","link":"","permalink":"http://didiorg.com/1720814833/","excerpt":"","text":"背景 前端项目日益复杂，功能多 业务逻辑，数据流，渲染，交互等等功能都是放在一块， 没有经过成熟的设计，杂乱无章，功能多了之后， 改一个小东西要把逻辑从头到尾都动一遍 理解 是一个抽象概念一种思想，只在项目设计阶段存在，就是去划分项目每个模块的职责 核心点 建模，建模是整个ddd最重要的部分 需要去区分一个业务中的各个概念，为不同的概念建立不同类型的模型，并且找到它们之间的关系，通过建模，建立起我们编程的基础工程，后续所有的开发，都是在这些模型的基础上完成的 前端建模核心思想：分层思想（Layered Architecture）​ 比如一些常见的想法： 定义业务对象 控制数据流 界面渲染 用户交互��染 用户交互","categories":[],"tags":[]},{"title":"d4","slug":"ddd/领域驱动设计","date":"2022-07-11T06:16:56.000Z","updated":"2022-08-02T02:40:21.713Z","comments":true,"path":"/1643923690/","link":"","permalink":"http://didiorg.com/1643923690/","excerpt":"","text":"相关概念领域驱动设计（domain-driven-design）是软件代码的结构及语言需要符合业务领域中的习惯用法 领域驱动设计可以将实现对应到持续进化的模型 领域驱动设计的前提是： 把项目的主要重点放在核心领域（core domain）和领域逻辑 以领域中的模型为基础，进行复杂的设计 让技术人员以及领域专家合作，以迭代方式来完善特定领域问题的概念模型 上下文（Context）情境，脉络，上下文。比如：电子商务系统。 领域（Domain）知识、影响、活动。客户使用软件要处理的问题种类即为软件的领域。 模型（Model）一类描述域的不同方面并可用于解决相关问题的系统化的抽象 通用语言（Ubiquitous Language）一种领域专家使用，为了描述域模型而构造的语言，以减少沟通成本。 理想情况下，只有一个统一的模型。 但是通常情况下都无法实现，因此在实践中通常分成多个模型。 限界上下文任何大型项目都有多个模型。 然而，当基于不同模型的代码相结合，软件变得越来越多，不可靠，并且难以理解。 团队成员之间的交流变得越来越难。 模型的使用情境变得越来越不清晰。 因此：需要明确定义模型适用的上下文，并且根据团队组织，应用程序特定部分的使用情况以及代码库和数据库模式等物理表现明确设置边界。 保持模型在这些范围内严格一致，并且不被外部的问题影响。 持续集成当愈多人在相同的有限背景下工作时，模型就愈应该分裂。 团队越大，问题就越大，即使只有三四个人也会遇到严重的问题。 然而，将系统分解为更小的环境最终会失去一个有价值的集成和一致性。 因此：创建一个经常合并所有代码和其他实现工件的过程，用自动化测试快速标记碎片。通过持续地运用统一术语去夯实随着概念在不同人的头脑中的演变而逐渐形成对模型的共同观点。 上下文关系在缺乏全局认识的情况下，个别有界上下文会留下一些问题。 其他模型的背景可能仍然是模糊不清的。 其他团队的人不会意识到上下文的界限，并且会不知不觉地做出模糊边缘或使连接复杂化的变化。 当连接必须在不同的上下文之间进行时，它们往往会相互渗透。 因此：确定项目中正在使用的每个模型并定义其限界上下文。 这包括非面向对象子系统的隐式模型。 命名每个限界上下文，并将其命名为通用语言的一部分。 描述模型之间的关联点，确保任何用于共享交流的词语都有清晰明确的含义。 映射现有的情形。 DDD领域驱动设计DDD（Domain-Driven Design）是帮助工程师，应对复杂业务系统设计和开发的思想武器和方法论。它指导了我们如何去和领域专家（熟悉业务的负责人）进行沟通，如何和他们找到一门共通语言，并基于该语言构建一套关于领域知识的图谱，并且是按照我们做系统设计的思路构建这套图谱。 建模是DDD的核心方法论，你需要去区分一个业务中的各个概念，为不同的概念建立不同类型的模型，并且找到它们之间的关系，通过建模，建立起我们编程的基础工程，后续所有的开发，都是在这些模型的基础上完成的。 DDD是什么呢，DDD就是一个抽象的概念，DDD只在软件的架构设计阶段出现，它就是软件模块职责的划分 前端建模如果你使用vue组件，你会有一种为视图撰写模型的感觉，即ViewModel，它一定指向视图层（界面与用户交互）。但如我在多个场合提到的一样，vue组件是纯视图层的要件，如果你把有关业务的代码，写在vue组件中，你的代码将会是业务逻辑和视图逻辑混杂在一起的代码，你将无法在后来的维护中区分和把握到底要改业务逻辑还是改交互逻辑。实际上，这种操作是很多初级前端的惯用手法，因为大部分初级前端的编程习惯，都是随着意识流，按线性的思维写代码。而真正有经验的工程师，一定会在开始写代码之前先思考将要写作的代码，哪些是用于定义业务对象的，哪些是用于控制数据流的，哪些是为了完成界面渲染的，哪些是为了完成用户交互的等等。而这些思考，用一种思想来概括就是“分层思想”或者叫“Layered Architecture”。有了分层思想之后，开发者才不会认为抽象出业务模型是一件麻烦的事。分层开发，势在必行。 前端业务模型分为两类：一类是用于展示的模型，一类是用于数据提交（表单）的模型。后者在复杂度上会比前者高出一个等级。 你可能会有疑问，不都是业务模型么，怎么还区分用于展示的和提交的？这可能是前端的特殊之处。后端应用，提交数据到数据库时，具有特定的约束，但是在输出到前端时却没有约束，因此，后端把大部分工作都投入在对数据库有写入动作的业务逻辑上，而丢给前端的数据，基本上不需要按照视图层的逻辑建模，只要一股脑把数据丢给前端即可。但是前端则不同，视图层具有复杂的交互逻辑，而这些交互逻辑依赖业务对象的特征，比如当这个业务对象处于什么样的一个状态时，才能点击某个按钮触发一个流转业务。因此，在展示&#x2F;交互这个层面，前端也需要建模。而提交数据就更不用说了，前端业务表单本身就是极为复杂的一种场景，不建立模型，根本无法对一个表单所要表达的业务对象完成清晰的创建或更新处理。 如何建模？讲了那么多，那么到底应该如何实施前端建模呢？作为工程师，我们必须掌握一定的方法论，在理论上对我们的设计有一定的自信，才能确保我们的建模方式是对的。DDD为我们提供了建模的方法论，它提供了多个方案（Scheme），比如Entity, Value Object, Service, Modules, Aggregate, Factory, Repository等等，这些都是用来构造模型的方案。 这么多方案，实际上本质要解决两个问题： 核心 边界 我们要对业务进行建模，首先要抓住该业务的核心是什么。例如银行转账这个业务，它的核心是什么？是转账的金额，还是账号？它的边界又是什么？例如在转账这个业务中，我是否需要去把两边账号的消费记录拉出来看看？这些，都是我们要在建模的时候解决的问题。DDD告诉我们的方法论，是不要自己闭门造车，不要从开发人员的角度去设计一个系统，而是要找领域专家（对该业务的实操了如指掌的人）进行了解，建立自己对该业务的知识体系，并且和领域专家一起敲定有关这个业务各个细节的模型体系。 回到我们前端。我们实际上要找到这个业务中，存在那些对象，收集到所有对象之后，去一个一个的观察它们，如果它是业务逻辑中的关键对象，就要使用Entity的方案，对它进行细致的深入的描述，如果它是一个次要的或者说固定不变的或者一次性用完的对象，那么就可以使用Value Object的方案（也就是一个普通的对象）。有了这些对象之后，还需要有一个东西把它们聚合在一起，这时我们可以使用Aggreate的方案。在这些对象之间，还可能出现一些动作（动词，非静态的），此时我们可以使用Service和Factory的方案。我们还需要和服务端交互，拉取数据，填充到模型中，形成更丰富的细节，此时我们可以采用Repository的方案。 不要被这么多的名词吓到，本质上，放到前端的语境下，你就是需要去创建一些类，并处理好这些类在真实被使用时，它们之间的约束逻辑等等。 分层架构通过分层架构（Layered Architecture），我们的代码被以不同层的不同理念进行组织。有关模型的东西，全都且只在模型层处理，我们不需要考虑外部将会如何使用它，理论上可以表述为“内存实体不需要考虑外层环境”的Clean Architecture，因此，我们只需要考虑，我们的建模是否符合真实业务的需要。这样的代码组织，将颠覆我们传统前端开发的一些经验，然而，这种颠覆显得没有什么惊喜，它看上去复杂度增加了，我们反问一句自己，我们是为了分层而分层，还是为了这样分层写出的代码，将有助于我们区分代码块功能，以利于我们的项目在两年三年的持续迭代维护中，有比较清晰的代码组织，从而让我们的维护更加有效？ 提炼关系表关系表是指在某个业务逻辑中，涉及多个业务对象，它们之间的存在不同情况下的不同联系，所最终组成的一个Object对象。 参考&#x2F;出处： 维基百科 如何打造更稳健的前端业务模块代码组织形式 DDD hua.github.io&#x2F;ddd&#x2F;)","categories":[],"tags":[]},{"title":"d3","slug":"ddd/前端业务模块代码组织形式","date":"2022-07-11T06:16:56.000Z","updated":"2022-08-02T02:40:21.712Z","comments":true,"path":"/4288208203/","link":"","permalink":"http://didiorg.com/4288208203/","excerpt":"","text":"如何打造更稳健的前端业务模块代码组织形式文章出处：如何打造更稳健的前端业务模块代码组织形式业务系统和一般的应用有非常大的不同，一般的应用以提供给公司&#x2F;企业外的用户（消费者、普通玩家）提供服务，以完成2C的销售目的，而业务系统一般是2B或者自身消费的模式，完成的是自身业务的管理目标。所以，应用侧重服务，业务系统侧重管理。两者的不同，导致我们对项目开发中，代码的组织方式会有差别。2C应用要满足大量用户在使用时的舒适性，因此要提高项目中有关性能、用户体验、效果等方面的要求，以吸引用户付费。但业务系统则稍有差别，虽然系统的使用体验也很重要，但是不是占最重要的部分，业务系统最重要的部分，是必须保证用户看到的数据、流程等，必须与真实的业务、业务流程一致，否则会带来自身利益的损失，因此，在稳健性、安全性等方面要求更高。 本文主要站在稳健性这个角度，试图阐述，在业务系统中，如何去安排或组织我们的（前端）代码，才能保证符合业务系统特征要求，且有利于长期可持续维护下去。由于谈系统过大，那么，本文只立足于一个业务模块来进行阐述。 什么是业务模块？首先，什么是业务系统？在这之前，又必须回答什么是业务？业务（Business）专指商业活动，是实现企业生产到利益回收的一个环节，它的总和，构成了该企业盈利活动的整个流程。一般而言，我们所指的业务是企业商业活动中的一个部分，有的甚至小到一个环节，例如“结算”这个环节。业务系统则是辅助这些商业活动的计算机在线系统，以信息化的形式管理和决策企业的商业活动（理论上没有业务系统企业也能运转，但信息化社会没有业务系统会让企业寸步难行）。 大部分情况下，业务系统会尽可能多的囊括企业的业务环节，其目标是将企业的所有商业管理在线化，完成除必须在线下完成的实体业务之外的所有管理活动。而且，通过业务系统的数据积累，可以让企业基于已有数据进行深入决策，比只有线下管理的竞争对手高出多个维度。企业的管理者和员工使用业务系统，参与到企业的各个业务环节，参与形式各有不同，根据员工的角色来决定，比如有的员工不接触系统界面，只通过工卡完成各项流程的录入，有的员工则需要完成在线申请或审批，有的员工需要使用复杂的第三方工具完成系统录入等等。 业务模块，是以业务系统的建设者（领域专家、系统工程师等）的角度看待业务系统时，将庞大的业务系统，按照某个业务活动的边界，进行划分的某个单元。但是技术上，一般一个模块还是粒度比较大的单元。一般而言，业务模块囊括了系统关于该业务的所有内容，且和其他业务有明显的界限，理论上，可以在脱离了其他业务模块的情况下独立运行。 有了以上的认知，我们就知道，我们需要掌握企业在某个业务中，不同的参与者都是如何工作的。在该业务模块没有上线到业务系统中时，没人能明确的告诉你这个业务模块应该长什么样子，你需要走访业务的参与成员，了解他们实际是怎么工作的，然后再思考，如果要将这些工作迁移到线上，应该关注哪些方面，是用户的操作形式？是界面的友好风格？是信息的准确？但是应该注意一点，如果业务系统致使工作效率降低，那么说明设计该系统的人没有真正掌握企业商业活动的核心要点。 DDD领域驱动设计DDD（Domain-Driven Design）是帮助工程师，应对复杂业务系统设计和开发的思想武器和方法论。它指导了我们如何去和领域专家（熟悉业务的负责人）进行沟通，如何和他们找到一门共通语言，并基于该语言构建一套关于领域知识的图谱，并且是按照我们做系统设计的思路构建这套图谱。 建模是DDD的核心方法论，你需要去区分一个业务中的各个概念，为不同的概念建立不同类型的模型，并且找到它们之间的关系，通过建模，建立起我们编程的基础工程，后续所有的开发，都是在这些模型的基础上完成的。 前后端有别自从前后端分离流行之后，DDD从某些技术层面上已经过时了。在传统系统开发中，系统大部分技术分布在后端即底层的基础建设上，用于人机交互的表现层所占份额很小，甚至只是后端系统中输出的那么末梢节点，是花费时间最少的部分。而现代系统开发前后端分离之后，一套系统需要依赖前后端两个团队完成，这导致原本可以在排除其他业务模块之后可以独立运行的业务模块，现在不可能存在，因为现在的架构模式，导致前端代码一次性囊括所有模块，而后端代码模块间也具有较高的耦合，已经不可能回到以前一个模块的代码可以完全自治的模式下了。 基于新的架构，前端和后端对待一个业务模块的态度有了很大的不同。对于后端而言，模块相对来说还比较清晰，沿用旧的设计思路，模块的各个功能也能保持一定的高内聚。甚至，由于将视图层丢出去，后端甚至不需要考虑视图层的问题，只需要保证业务的数据准确和业务的流转准确即可。对于视图层，后端只需要一股脑将每一个功能所需要的数据（VO）以JSON的形式提供Restful接口即可。 对于前端而言，其实经历了多个阶段。起初，前端作为页面的处理方，主要是提供js脚本，完成一些特定的后端无法完成的交互效果，例如一些建议的滑动下拉效果，一些悬浮效果等，由于这些效果需要js编写，而后端开发人员不熟悉，就不得不由前端人员完成。之后，随着ajax技术兴起，前端路由技术的出现，页面交互效果开始变得丰富，无刷新的效果成为web应用的主流形式，使得后端人员参与前端工作的可能性越来越低，前端逐渐从作为后端末梢环节的地位独立出来，通过ajax或其他http交互方式，完成与后端的分离。 现在，我们的核心问题是：前端怎么对待业务模块？ 一种成熟的方式是将业务模块组件化，这里的组件是具有高内聚设计的业务组件。2017年我在Morningstar工作的时候，就已经在采用这种方案。和现在的react、vue组件不同，当时我们基于backbone作为框架开发组件，一个组件基于一些数据点完成一个具体的业务（基金数据分析）。这个组件在交付时，需要同时交付前端和后端代码到不同的平台中，作为对应产品的一部分。组件的形式是一种不错的形式，包括我后面要推荐的方案，本质上也是交付组件。 但是，组件不是唯一的业务模块交付形式。我在业务中还使用angularjs作为框架开发应用，一般情况下，我们会根据路由来划分模块，一个模块拥有相同的路由根地址，模块内的各个功能或处理节点都是该路由的子路由。但是，它的模板、controller、service、样式文件被放在不同的目录下管理，虽然在前端的运行效率变高了，但是对于业务模块而言却变得高耦合低内聚。可能angular的开发团队意识到这个问题，angular2之后，也就是新的基于typescript的angular框架不在以这种模式对待业务模块，新的框架下，一个module的相关代码被聚合在一起，并且形式上以组件的形式导出，可以说实现了业务的高内聚，业务间的低耦合。 稳健的前端业务模块形式Angular的module组织形式，我认为是比较优秀的组织形式。除了代码本身的组织形式之外，我们还要去看业务模块在设计上的特征，是否有利于为我们提供一定的灵活性，可为将来实现长期可持续迭代更新创造条件。 那么，怎么样设计业务模块呢？我提倡一种分层的理念。将业务模块分为数据层、表现层和逻辑层。这也是angular尝试践行的，它首先提供了可在编译时实现抽象的模板；其次提供了依赖注入的服务层为模块提供视图之外的其他能力，我们可以在服务层做很多事情，比如建立模型，但是它没有提供这方面的指导（，所以在其他文章中，我们不认为angular是完整的MVC框架，因为它在M层无所作为）；最后，它内置了基于rxjs的流式数据（状态）管理，基于管道的处理方式，可以让交互和状态的流动可以自由组合，使用起来非常灵活。但是，正如我提到的，它没有提供有关分层理念的更深入的指导，它提供了各种工具，让你自己选择是否使用，以及如何使用这些工具来编写出可长期维护的代码，完全由你的设计或架构能力决定。 而我则希望提供用于编写出明确分层概念的范式，就像多年前我们写后端服务时，需要进行分层管理一样，我希望在前端践行DDD的理念。但同时又有别于后端的DDD，前端不需要永久存储数据，每一次刷新浏览器，我们都可以通过api接口拿到需要的数据，而且从api请求数据和从数据库查询数据也有一定的差别。我们要构建具有DDD通行理念的，带有前端特色的建模体系。 前端建模如果你使用vue组件，你会有一种为视图撰写模型的感觉，即ViewModel，它一定指向视图层（界面与用户交互）。但如我在多个场合提到的一样，vue组件是纯视图层的要件，如果你把有关业务的代码，写在vue组件中，你的代码将会是业务逻辑和视图逻辑混杂在一起的代码，你将无法在后来的维护中区分和把握到底要改业务逻辑还是改交互逻辑。实际上，这种操作是很多初级前端的惯用手法，因为大部分初级前端的编程习惯，都是随着意识流，按线性的思维写代码。而真正有经验的工程师，一定会在开始写代码之前先思考将要写作的代码，哪些是用于定义业务对象的，哪些是用于控制数据流的，哪些是为了完成界面渲染的，哪些是为了完成用户交互的等等。而这些思考，用一种思想来概括就是“分层思想”或者叫“Layered Architecture”。 有了分层思想之后，开发者才不会认为抽象出业务模型是一件麻烦的事。是的，很多初级前端觉得自己写的代码非常舒服，并且认为前端建模或把一些不属于视图层的东西提炼出去，是一件增加复杂度，使代码难读难维护的事。而实际上，由于他们只关注当下快速实现，而不用考虑可持续维护的问题，所以认为自己的实现是最优解。但往往有些系统，根本不应该让一个经验并不丰富且自以为是的初级前端来写，而应该由经验丰富的工程师来完成。两者之间的差距，会使得系统后续的发展呈现截然不同的效果。但讽刺的是，经验不足的开发者进入这样的项目组之后，反而认为自己写的粗糙的代码应该推广开替代已经成熟的体系，因为他觉得自己的代码可以一口气读完，是好代码。然而，现实是，当他们2个月之后回头看自己的代码，发现根本无法改动，或者要实现新功能非常困难，因为之前写的代码是线性的过程式代码，稍有调整，就需要把这条线重新切断再想办法连起来。所有的一切，都会在实践中被检验出来。分层开发，势在必行。 前端业务模型分为两类：一类是用于展示的模型，一类是用于数据提交（表单）的模型。后者在复杂度上会比前者高出一个等级。 你可能会有疑问，不都是业务模型么，怎么还区分用于展示的和提交的？这可能是前端的特殊之处。后端应用，提交数据到数据库时，具有特定的约束，但是在输出到前端时却没有约束，因此，后端把大部分工作都投入在对数据库有写入动作的业务逻辑上，而丢给前端的数据，基本上不需要按照视图层的逻辑建模，只要一股脑把数据丢给前端即可。但是前端则不同，视图层具有复杂的交互逻辑，而这些交互逻辑依赖业务对象的特征，比如当这个业务对象处于什么样的一个状态时，才能点击某个按钮触发一个流转业务。因此，在展示&#x2F;交互这个层面，前端也需要建模。而提交数据就更不用说了，前端业务表单本身就是极为复杂的一种场景，不建立模型，根本无法对一个表单所要表达的业务对象完成清晰的创建或更新处理。 如何建模？讲了那么多，那么到底应该如何实施前端建模呢？作为工程师，我们必须掌握一定的方法论，在理论上对我们的设计有一定的自信，才能确保我们的建模方式是对的。DDD为我们提供了建模的方法论，它提供了多个方案（Scheme），比如Entity, Value Object, Service, Modules, Aggregate, Factory, Repository等等，这些都是用来构造模型的方案。 这么多方案，实际上本质要解决两个问题： 核心 边界 我们要对业务进行建模，首先要抓住该业务的核心是什么。例如银行转账这个业务，它的核心是什么？是转账的金额，还是账号？它的边界又是什么？例如在转账这个业务中，我是否需要去把两边账号的消费记录拉出来看看？这些，都是我们要在建模的时候解决的问题。DDD告诉我们的方法论，是不要自己闭门造车，不要从开发人员的角度去设计一个系统，而是要找领域专家（对该业务的实操了如指掌的人）进行了解，建立自己对该业务的知识体系，并且和领域专家一起敲定有关这个业务各个细节的模型体系。 回到我们前端。我们实际上要找到这个业务中，存在那些对象，收集到所有对象之后，去一个一个的观察它们，如果它是业务逻辑中的关键对象，就要使用Entity的方案，对它进行细致的深入的描述，如果它是一个次要的或者说固定不变的或者一次性用完的对象，那么就可以使用Value Object的方案（也就是一个普通的对象）。有了这些对象之后，还需要有一个东西把它们聚合在一起，这时我们可以使用Aggreate的方案。在这些对象之间，还可能出现一些动作（动词，非静态的），此时我们可以使用Service和Factory的方案。我们还需要和服务端交互，拉取数据，填充到模型中，形成更丰富的细节，此时我们可以采用Repository的方案。 不要被这么多的名词吓到，本质上，放到前端的语境下，你就是需要去创建一些类，并处理好这些类在真实被使用时，它们之间的约束逻辑等等。 建模实践既然本质上 是去建立类，那么接下来我们就来看一看如何利用前端的工具js来完成模型的建立。在这之前，我们不得不承认，js不是一门能像java一样写出健壮的系统的语言。它有自己的语法特征，而这些语法特征导致我们在完成建模时，需要采取一些非常手段。比如我，就是利用class的static属性来完成模型上元数据的定义。 12345678910111213141516class Account &#123; static default = &#x27;&#x27; static type = &#x27;numeric&#x27;&#125;class Amount &#123; static default = 0 static type = &#x27;number&#x27;&#125;class TransferModel &#123; id = &#x27;&#x27; static from = Account static to = Account static amount = Amount&#125; 上面这段代码仅仅是我用来说明建模的一个思路，我没有在生产环境用过这样的代码。首先，我们定义了两个类：Account账户, Amount金额。这两个类具有类似的结构，因为它们是用来描述这个对象应该具备的一些特征，比如Account这个对象应该是一个数字字符串，而Amount应该是一个数字。其次，Transfer是一个包含了三个字段的对象，每个字段都对应一个建好模的对象。我们在使用时，主要是去使用Transfer实例化出来的对象，这个对象应该具备3个字段，且每个字段应该具备哪些规则（约束）都是提前规定好的。 上面是我们对转账这个业务中的对象进行建模。实际上，我们并没有完成转账这个业务，我们需要把数据发送给api，以真正完成转账。所以，我们要在对象之外，建立一个服务，用于完成这个业务。 12345678class TransferService &#123; submitTransfer(id, data) &#123; ... &#125; getTransfer(id) &#123; ... &#125;&#125; 这也非常容易理解，我们通过两个方法来完成和API接口的交互，从而使得这个业务完成前后端对接，使它在整个系统层面生效。同时，我们还提供了一个接口getTransfer，它将用于在用户查看自己的转账记录的时候，还原数据。 但上面这些还不够，我们需要有一个东西，把它们串联起来，它们才能真正工作。 1234567891011121314class TransferController &#123; static model = TransferModel static service = TransferService async init(id) &#123; const data = await this.service.getTransfer(id) this.model.setData(id, data) &#125; async submit() &#123; const data = this.model.getData() await this.service.submitTransfer(this.model.id, data) &#125;&#125; 这样，我们就模型和服务串起来了。我们可以从这三块代码中，大致看出关于转账这个业务的实际逻辑。但是，我们忽略了另外一个东西，就是我们现在还没有界面，我们还没有提供给用户怎么进行操作后完成这个转账。因此，我们还需要补全这个部分。 123456789101112class TransferView extends React.Component &#123; controller = new TransferController() componentDidMount() &#123; const &#123; id &#125; = this.props this.controller.init(id) &#125; render() &#123; return ( &lt;button onClick=&#123;() =&gt; this.controller.submit()&#125;&gt;transfer&lt;/button&gt; ) &#125;&#125; 这样，我们就将视图和模型最终串了起来。也实现了我们最初关于分层的想法。通过分层架构（Layered Architecture），我们的代码被以不同层的不同理念进行组织。有关模型的东西，全都且只在模型层处理，我们不需要考虑外部将会如何使用它，理论上可以表述为“内存实体不需要考虑外层环境”的Clean Architecture，因此，我们只需要考虑，我们的建模是否符合真实业务的需要。这样的代码组织，将颠覆我们传统前端开发的一些经验，然而，这种颠覆显得没有什么惊喜，它看上去复杂度增加了，我们反问一句自己，我们是为了分层而分层，还是为了这样分层写出的代码，将有助于我们区分代码块功能，以利于我们的项目在两年三年的持续迭代维护中，有比较清晰的代码组织，从而让我们的维护更加有效？ 提炼关系表关系表是指在某个业务逻辑中，涉及多个业务对象，它们之间的存在不同情况下的不同联系，所最终组成的一个Object对象。这样说过于抽象，我们用实际的案例来说明问题。 在上述转账系统中，存在着这样的内在逻辑，当用户X信用等级为1时，他不能向客户类型为A类的用户转账，因为可能存在信用风险。此时，实际上，我们要构建一张用于表达信用、客户类型和转账权限之间的关系表，在我的设计里，转账权限是结果，因此，它是值，而信用、客户类型是条件，因此，产生的表可以按如下写： 12345678910&#123; 1: &#123; A: false, B: true, &#125;, 2: &#123; A: true, B: true, &#125;,&#125; 上面的关系表表示了如下关系：信用为1级的用户，不能向A类用户转账，但可以向B类用户转账；信用为2级的用户，可以向A和B类用户转账。 一般来讲，关系表会非常繁琐，因为它要枚举大部分可能性（一个技巧是，不需要列出false的情况，只需要列出true的情况的关系即可），所以感觉节点会很多。但是，它的用处却非常大，你可以使用它避免一大堆的if…else。比如上面这个场景。我们有两种选择，一种是将这个关系写在模型中，另外一种是写在控制器中。例如： 12345678910111213141516171819202122232425262728293031323334class Credit &#123; static default = 1 static type = enumerate([1, 2])&#125;class Stratum &#123; static default = &#x27;A&#x27; static type = enumerate([&#x27;A&#x27;, &#x27;B&#x27;])&#125;class AccountModel &#123; static credit = Credit static stratum = Stratum canTransfer(toAccount) &#123; if (this.credit === 1) &#123; return [&#x27;B&#x27;].includes(toAccount.stratum) &#125; else &#123; return true &#125; &#125;&#125;class TransferModel &#123; static from = AccountModel static to = AccountModel transfer() &#123; if (this.from.canTrasfer(this.to)) &#123; ... &#125; &#125;&#125; 你看，我们在canTransfer方法中通过if…else来进行判断，看上去也是可以的，但是，这里有一个问题是，这段代码无法让我们洞悉业务的详细细节，它像是一段无法被看透的程序，而不是一段业务的描述。接下来我们用关系表来改造它： 123canTransfer(toAccount) &#123; return relationship[this.credit]?.[toAccount.stratum]&#125; 多么简单的一句话，而这里的relationship就是我们上面我们列举的关系表。关系表是静态的，不仅程序的运行性能会更好，同时，我们阅读关系表（需要增加对键的含义注释）来掌握业务中都有哪些情况，我们熟知了业务，才能在将来的调整时，将关系表中的true改为false即可。 基于React的DDD框架但以上仅仅是一个思路，要让它工作起来，还有非常多的工作要做。幸运的是，我已经帮你做了这项工作，我发布了开源的 tyshemo（https://github.com/tangshuang/tyshemo）模式库和 nautil（https://nautil.js.org/）框架，tyshemo 帮助你完成核心的模型层，nautil 则是基于 tyshemo 提供了完整的 service 和 controller 建模，以及提炼了业务交互的相关编程范式，你可以使用它完成DDD思路的整个链路的实践，同时，又不失去基于react进行开发的乐趣。你可以在这里（https://github.com/tangshuang/nautil-cli/tree/master/lib/templates/src/app/modules/home）看到一份完整的代码示例。 面对一个业务模块，我们会把和它相关的所有代码文件放在一个目录下进行管理（除一些需要公用的资源除外）。我们首先要对业务进行建模，如果是简单的一两个模型，我们只需要建立一个.model.js来完成，而如果是一个比较复杂的体系，我们可以创建一个.model文件夹，放置所有相关模型文件，比如上图示例中，我们可以创建home.model文件夹来管理。建模的同时，我们就会在必要的时候，为模块创建service，规则也是一样。完成建模之后，我们需要撰写控制器controller，在一个controller内部，你需要引入model和service，nautil的Controller会自动帮你实例化它们，并且做好观察。 除了把model和service串联起来，controller还有什么用呢？你还可以在controller内建立基于模型的交互，我称之为“无视图的交互模型”。因为对于前端应用来讲，业务除了数据逻辑之外，往往还有交互逻辑，比如“点击这个按钮之后，弹出一个对话框询问用户是否确认转账，如果用户点确认，那么执行转账”，这段交互描述里面，没有确切的告诉你弹出框应该长什么样子，用什么颜色，字体多大等等，它只描述了有关业务的交互部分，这个部分与布局和样式无关，是纯粹的描述和业务相关的交互效果。得益于react的抽象能力，我们可以直接在controller中，使用jsx完成纯交互的部分，并以组件的形式作为controller的接口提供给外部使用。这样，有关业务的一切逻辑，我们就通过controller串联model和service，在一个模块内，脱离布局，完成了。完成controller之后，我们才开始布局开发，布局开发也就是react组件的日常开发，由于我们在controller中导出了交互组件，而这些交互组件已经涵盖了大部分业务逻辑，所以，我们可以做到布局组件和业务无关，是纯粹的布局和样式。 基于这样的设计，我们在后续的开发中，还可以加入一些特殊的逻辑，例如，我们一个业务模块，可能在PC端也可能在手机端使用，那么，此时，我们只需要重写布局组件，而无需再写业务逻辑相关的代码。更多的思想，需要你更深入的了解nautil，以及尝试使用它作为主力开发工具之后，慢慢体会。 结语本文虽然标题是谈如何打造前端的模块代码，但本质上，详细的阐述了我关于DDD的思想的理解，以及自己在DDD的思想基础上构建的一套代码管理范式，并且以前端框架的形式组织起来。我相信，如果你也是在编写复杂的业务系统，并且遇到一些瓶颈的话，一定能从本文中有所收获。当然，由于前端的特殊性，我们不能照搬DDD，需要有所变通。我写框架，也只是一种探索，并不代表它是唯一的一种形态。随着产业互联网时代的到来，前端逐渐从大众型交互应用，转向企业型业务系统应用，这是大势所趋，也是所谓“互联网下半场”前端立足之本。本文抛砖引玉，相信站在前端的角度去看待复杂业务（专有领域）的研究会越来越多。究会越来越多。","categories":[],"tags":[]},{"title":"学习计划","slug":"xie/doc","date":"2021-08-22T11:46:41.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/1579271507/","link":"","permalink":"http://didiorg.com/1579271507/","excerpt":"xie","text":"xie 8.22 JS第七章 Vue（一期）： 第十五章项目实战-页面骨架开发（60min） 8.23 第十六章 -head组件开发 1-2（20min） 3-8（70min） 9-16（90min） 8.24 第十七章 -goods商品列表开发 1-5（50min） 6-8（40min） 9-14（70min）15-17（35min） 8.25 第十七章 -goods商品列表开发 18-20（30min） 21-24（50min） 第十八章 -food商品详情页实现 1-5（60min） 6-11（70min） 8.26 第十八章 -food商品详情页实现 12-17（50min） 12-17（50min） 第十九章 -ratings评价列表页实现 1-3（35min） 4-6（40min） 8.27 第二十章 -seller商家详情页实现 1-4（35min） 5-7（30min） 8-11（45min） 第二十一章 项目编译打包（15min） 第二十二章 课程总结（5min） 第二十三章 Vue.js1.0向2.0升级（30min） 第一章 课程导学（10min） 第二章 项目准备工作（25min） 8.28 第三章 头部组件开发（30min） 第四章 Tab组件开发（30min） 第五章 项目准备工作 1-3（25min） 4-5（35min） 6-7（40min） 8.29 第五章 项目准备工作 8-9（30min） 第六章 商品详情页开发（50min） 第七章 评价和商家页面开发（45min） 第八章 create-api原理分析（40min） 8.30 第九章 打包构建和项目部署（55min） 第十章 课程总结（10min）","categories":[],"tags":[]},{"title":"798","slug":"photo/niu","date":"2021-08-17T07:30:51.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/4175634211/","link":"","permalink":"http://didiorg.com/4175634211/","excerpt":"798","text":"798","categories":[],"tags":[]},{"title":"iig","slug":"photo/iqiyi","date":"2021-08-17T02:43:50.000Z","updated":"2022-08-02T02:39:10.648Z","comments":true,"path":"/3752725928/","link":"","permalink":"http://didiorg.com/3752725928/","excerpt":"IIG","text":"IIG 2021年8月16年中总结","categories":[],"tags":[]},{"title":"vue常见API原理分析","slug":"vue常见API原理分析","date":"2020-07-04T02:14:41.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/3258801602/","link":"","permalink":"http://didiorg.com/3258801602/","excerpt":"数据绑定","text":"数据绑定 oberserverObject.defineProperty() depdep.notify() watcheruser-watcher render-watcher computed-watcher nextTick nextTick 会在DOM更新完毕之后执行一个回调，确保我们操作的是更新之后的DOM vue用异步队列的方式来控制DOM更新和nextTick回调先后执行microtask因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕因为兼容性问题，vue不得不做了microtask向macrotask的降级方案 (Promise，MutationObserver，setTimeout) MutationObserver 用于监听DOM修改事件，能够监听到节点的属性，文本内容，子节点等的改动 Event Loop MutationObserver 每次监听到变更的时候会往 microtask 添加一个事件 降级方案 Promise &#x3D;&gt; MutationObserver &#x3D;&gt; setTimeout 参考文档&gt;&gt;&gt; computed12345678initData()initCompunted()defineComputed()Object.defineProperty()get: createCompuntedGetter()watcher()watcher.evaluate()watcher.depend() 这里的变量watcher就是之前computed对应的computed-watcher实例，接下来会执行Watcher类专门为计算属性定义的两个方法，在执行evaluate方法进行求值的过程中又会触发computed内可以访问到的响应式数据的get，它们会将当前的computed-watcher作为依赖收集到自己的dep里，计算完毕之后将dirty置为false，表示已经计算过了。 然后执行depend让计算属性内的响应式数据订阅当前的render-watcher，所以computed内的响应式数据会收集computed-watcher和render-watcher两个watcher，当computed内的状态发生变更触发set后，首先通知computed需要进行重新计算，然后通知到视图执行渲染，再渲染中会访问到computed计算后的值，最后渲染到页面。 为什么计算属性有缓存功能？ 因为当计算属性经过计算后，内部的标志位会表明已经计算过了，再次访问时会直接读取计算后的值 为什么计算属性内的响应式数据发生变更后，计算属性会重新计算？ 因为内部的响应式数据会收集computed-watcher，变更后通知计算属性要进行计算，也会通知页面重新渲，渲染染时会读取到重新计算后的值。 watcher123456789101112131415161718192021222324watch监听属性收集依赖过程root =&gt; _init() 根组件初始化...root =&gt; vm._update(vm._render()) 根组件渲染，没状态不用收集依赖 app =&gt; initData() 初始化App组件的data app =&gt; oberserver(name) 将name转为响应式 app =&gt; initWatch(watch) 初始化watch app =&gt; this.$watch(&#x27;name&#x27;) 主要就是这里： 触发name的get， 让dep收集user-watcher app =&gt; Sub.$mont() 子组件挂载 app =&gt; new Watcher(vm, geeter) 实例化 render-watcher app =&gt; vm._render() 触发name的get， 让dep收集render-watcher ... watch监听属性派发更新 app =&gt; name = &#x27;www&#x27; 响应式数据被贱赋值，触发set app =&gt; dep.nofity() dep通知收集到的watcher app =&gt; user-watcher user-watcher派发新值跟旧值给回调函数 app =&gt; render-watcher redner-wachter改变视图 watch和this.$watch的实现是一致的，以及简单解释它的原理就是为需要观察的数据创建并收集·，当数据改变时通知到·将新值和旧值传递给用户自己定义的回调函数。 定义watch时会被使用到的三个参数：sync、immediate、deep 简单说明它们的实现原理就是：sync是不将watcher加入到nextTick队列而同步的更新、immediate是立即以得到的值执行一次回调函数、deep是递归的对它的子值进行依赖收集。 虚拟DOM生成真实DOM的过程 元素节点生成Dom 里向外的挨个创建出真实的Dom，然后插入到它的父节点内，最后将创建好的Dom插入到body内，完成创建的过程 组件VNode生成Dom 无论是嵌套多么深的组件，遇到组件的后就执行init，在init的__patch__过程中又遇到嵌套组件，那就再执行嵌套组件的init，嵌套组件完成__patch__后将真实的Dom插入到它的父节点内，接着执行完外层组件的__patch__又插入到它的父节点内，最后插入到body内，完成嵌套组件的创建过程，总之还是一个由里及外的过程 extend和$mount这两个都是vue提供的API，不过在平时的业务开发中使用并不多。在vue的内部也有使用过这一对API。遇到嵌套组件时，首先将子组件转为组件形式的VNode时，会将引入的组件对象使用extend转为子组件的构造函数，作为VNode的一个属性Ctor；然后在将VNode转为真实的Dom的时候实例化这个构造函数；最后实例化完成后手动调用$mount进行挂载，将真实Dom插入到父节点内完成渲染。 extend 接受的是一个组件对象，再执行extend时将继承基类构造器上的一些属性、原型方法、静态方法等，最后返回Sub这么一个构造好的子组件构造函数。拥有和vue基类一样的能力，并在实例化时会执行继承来的_init方法完成子组件的初始化。 实例化Sub 执行_init组件初始化的一系列操作，初始化事件、生命周期、状态等等。将data或props内定义的变量挂载到当前this实例下，最后返回一个实例化后的对象。 $mount 在得到初始化后的对象后，开始组件的挂载。首先将当前render函数转为VNode，然后将VNode转为真实Dom插入到页面完成渲染。再完成挂载之后，会在当前组件实例this下挂载$el属性，它就是完成挂载后对应的真实Dom，我们就需要使用这个属性。 常见问题 请问runtime-compiler和runtime-only这两个版本的区别？ runtime-compiler 经历的是一个 template -&gt; ast -&gt; render -&gt; vdom -&gt; UI 的过程，runtime-only直接使用了render函数，所以经历的是一个 render -&gt; vdom -&gt; UI 的过程。 runtime-only 会省去一个 template -&gt; ast -&gt; render 的过程，也不再需要相关的loader插件，从而这种方法搭建的项目性能更高，代码也更少，项目大小也更小。最明显的就是大小的区别，带编译器会比不带的版本大6kb。 请问可以在beforeCreate钩子内通过this访问到data中定义的变量么，为什么以及请问这个钩子可以做什么？ 是不可以访问的，因为在vue初始化阶段，这个时候data中的变量还没有被挂载到this上，这个时候访问值会是undefined。beforeCreate这个钩子在平时业务开发中用的比较少，而像插件内部的instanll方法通过Vue.use方法安装时一般会选在beforeCreate这个钩子内执行，vue-router和vuex就是这么干的。 请问methods内的方法可以使用箭头函数么，会造成什么样的结果？ 是不可以使用箭头函数的，因为箭头函数的this是定义时就绑定的。在vue的内部，methods内每个方法的上下文是当前的vm组件实例，methods[key].bind(vm)，而如果使用使用箭头函数，函数的上下文就变成了父级的上下文，也就是undefined了，结果就是通过undefined访问任何变量都会报错。 请问vue@2为什么要引入虚拟Dom，谈谈对虚拟Dom的理解？ 随着现代应用对页面的功能要求越复杂，管理的状态越多，如果还是使用之前的JavaScript线程去频繁操作GUI线程的硕大Dom，对性能会有很大的损耗，而且也会造成状态难以管理，逻辑混乱等情况。引入虚拟Dom后，在框架的内部就将虚拟Dom树形结构与真实Dom做了映射，让我们不用在命令式的去操作Dom，可以将重心转为去维护这棵树形结构内的状态即可，状态的变化就会驱动Dom发生改变，具体的Dom操作vue帮我们完成，而且这些大部分可以在JavaScript线程完成，性能更高虚拟Dom只是一种数据结构，可以让它不仅仅使用在浏览器环境，还可以用与SSR以及Weex等场景。 父子两个组件同时定义了beforeCreate、created、beforeMounte、mounted四个钩子，它们的执行顺序是怎么样的？ 首先会执行父组件的初始化过程，所以会依次执行beforeCreate、created、在执行挂载前又会执行beforeMounte钩子，不过在生成真实dom的__patch__过程中遇到嵌套子组件后又会转为去执行子组件的初始化钩子beforeCreate、created，子组件在挂载前会执行beforeMounte，再完成子组件的Dom创建后执行mounted。这个父组件的__patch__过程才算完成，最后执行父组件的mounted钩子，这就是它们的执行顺序。执行顺序如下： 12345678parent beforeCreateparent createdparent beforeMounte child beforeCreate child created child beforeMounte child mountedparent mounted 当前组件模板中用到的变量一定要定义在data里么？ data中的变量都会被代理到当前this下，所以我们也可以在this下挂载属性，只要不重名即可。而且定义在data中的变量在vue的内部会将它包装成响应式的数据，让它拥有变更即可驱动视图变化的能力。但是如果这个数据不需要驱动视图，定义在created或mounted钩子内也是可以的，因为不会执行响应式的包装方法，对性能也是一种提升。 请简单描述下vue响应式系统？ 简单来说就是使用Object.defineProperty这个API为数据设置get和set。 当读取到某个属性时，触发get将读取它的组件对应的render watcher收集起来；当重置赋值时，触发set通知组件重新渲染页面。如果数据的类型是数组的话，还做了单独的处理，对可以改变数组自身的方法进行重写，因为这些方法不是通过重新赋值改变的数组，不会触发set，所以要单独处理。响应系统也有自身的不足，所以官方给出了$set和$delete来弥补。 为什么v-for里建议为每一项绑定key，而且最好具有唯一性，而不建议使用index？ diff比对内部做更新子节点时，会根据oldVnode内没有处理的节点得到一个key值和下标对应的对象集合，为的就是当处理vnode每一个节点时，能快速查找该节点是否是已有的节点，从而提高整个diff比对的性能。如果是一个动态列表，key值最好能保持唯一性，但像轮播图那种不会变更的列表，使用index也是没问题的。 说下自定义事件的机制。 子组件使用this.$emit触发事件时，会在当前实例的事件中心去查找对应的事件，然后执行它。不过这个事件回调是在父组件的作用域里定义的，所以$emit里的参数会传递给父组件的回调函数，从而完成父子组件通信。 请说明下组件库中命令式弹窗组件的原理？ 使用extend将组件转为构造函数，在实例化这个这个构造函数后，就会得到$el属性，也就是组件的真实Dom，这个时候我们就可以操作得到的真实的Dom去任意挂载，使用命令式也可以调用。 请说明下transition组件的实现原理？ transition组件是一个抽象组件，不会渲染出任何的Dom，它主要是帮助我们更加方便的写出动画。以插槽的形式对内部单一的子节点进行动画的管理，在渲染阶段就会往子节点的虚拟Dom上挂载一个transition属性，表示它的一个被transition组件包裹的节点，在path阶段就会执行transition组件内部钩子，钩子里分为enter和leave状态，在这个被包裹的子节点上使用v-if或v-show进行状态的切换。你可以使用Css也可以使用JavaScript钩子，使用Css方式时会在enter/leave状态内进行class类名的添加和删除，用户只需要写出对应类名的动画即可。如果使用JavaScript钩子，则也是按照顺序的执行指定的函数，而这些函数也是需要用户自己定义，组件只是控制这个的流程而已。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://didiorg.com/tags/vue/"}]},{"title":"面试记录","slug":"面试记录","date":"2020-07-04T01:49:04.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/148981014/","link":"","permalink":"http://didiorg.com/148981014/","excerpt":"浏览器多进程+多线程DNS寻址方式，DNS 缓存， dns-prefetch建立 tcp&#x2F;ip 链接，三次握手，四次挥手，滑动窗口，接收窗口，收发帧的策略，为什么关闭要等待 2MSL，get post 区别，并发限制传输数据，展开计算机网络 5 层&#x2F;7 层模型，五层：http -&gt; tcp&#x2F;ip -&gt; ip -&gt; data frames -&gt; 物理介质服务器收到请求，负载均衡，tomcat 容器，后端统一拦截过滤展开 http 报文，实体，http 1.0, 1,1 2之间的区别，gzip，长连接&#x2F;短连接，展开 cookie 及优化，多子域名拆分等展开 https 中 SSL&#x2F;TLS 链接步骤展开 http 缓存，强缓存，协商缓存，from memory&#x2F;disk cache等DOM 树的构建过程，bytes -&gt; characters -&gt; tokens -&gt; nodes -&gt; DOMcss rule tree: bytes -&gt; characters -&gt; tokens -&gt; nodes -&gt; CSSOMrenderTree 的构建，不可见元素，特殊元素等。渲染：compute css -&gt; construct frames -&gt; layout -&gt; paint展开 reflow , repaint 已经对应优化方法绘制中的简单图层与复合图层，开启硬件加速就是把对应节点丢到复合图层css 盒模型，BFC，IFC静态资源外链 css，js(defer, async)，img展开 loaded 和 domContentLoadedJS 解释阶段: token -&gt; AST -&gt; bytecode -&gt; machine code 然后扯到 JITJS 预处理阶段，变量提升，分号补全等。JS 执行阶段，EC stack，EC，VO，AO，作用域链， this，原型，继承（组合寄生式继承，es6 继承），JS 事件循环，micortask，marcortask等JS GC -&gt; v8 GC https://github.com/Advanced-Frontend/Daily-Interview-Questionhttps://muyiy.cn/question/https://blog.csdn.net/liudianjia/article/details/104805503https://blog.colafornia.me/post/2020/2020-interviews/ 猿辅导","text":"浏览器多进程+多线程DNS寻址方式，DNS 缓存， dns-prefetch建立 tcp&#x2F;ip 链接，三次握手，四次挥手，滑动窗口，接收窗口，收发帧的策略，为什么关闭要等待 2MSL，get post 区别，并发限制传输数据，展开计算机网络 5 层&#x2F;7 层模型，五层：http -&gt; tcp&#x2F;ip -&gt; ip -&gt; data frames -&gt; 物理介质服务器收到请求，负载均衡，tomcat 容器，后端统一拦截过滤展开 http 报文，实体，http 1.0, 1,1 2之间的区别，gzip，长连接&#x2F;短连接，展开 cookie 及优化，多子域名拆分等展开 https 中 SSL&#x2F;TLS 链接步骤展开 http 缓存，强缓存，协商缓存，from memory&#x2F;disk cache等DOM 树的构建过程，bytes -&gt; characters -&gt; tokens -&gt; nodes -&gt; DOMcss rule tree: bytes -&gt; characters -&gt; tokens -&gt; nodes -&gt; CSSOMrenderTree 的构建，不可见元素，特殊元素等。渲染：compute css -&gt; construct frames -&gt; layout -&gt; paint展开 reflow , repaint 已经对应优化方法绘制中的简单图层与复合图层，开启硬件加速就是把对应节点丢到复合图层css 盒模型，BFC，IFC静态资源外链 css，js(defer, async)，img展开 loaded 和 domContentLoadedJS 解释阶段: token -&gt; AST -&gt; bytecode -&gt; machine code 然后扯到 JITJS 预处理阶段，变量提升，分号补全等。JS 执行阶段，EC stack，EC，VO，AO，作用域链， this，原型，继承（组合寄生式继承，es6 继承），JS 事件循环，micortask，marcortask等JS GC -&gt; v8 GC https://github.com/Advanced-Frontend/Daily-Interview-Questionhttps://muyiy.cn/question/https://blog.csdn.net/liudianjia/article/details/104805503https://blog.colafornia.me/post/2020/2020-interviews/ 猿辅导 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849JS：Promise const p = fetch(/*…*/);p.then(f1).catch(f2).then(f3); // p failed() =&gt; &#123;&#125; vs function () &#123;&#125;const obj = &#123;‏‎ ‎ f1:‏‎ ‎() =&gt; console.log(this), f2‏‎ ‎() &#123; console.log(this) &#125;,&#125;;obj.f1() // &#123;&#125;obj.f2() // objnew obj.f1() // 报错new obj.f2() // f1&lt;A&gt; &lt;B /&gt;&lt;/A&gt;a.createdb.createda.mountedb.mountedNode &#123; value: number; children: Node[] &#125;2 =&gt; 26, 3, 5 =&gt; 6+3+5=141; 2, 3, 4; 7, 8 =&gt; 1+2+3+4+7+8=25// 告诉我多叉树每一层的和 [2, 14, 25]function layerSum(root：Node) &#123;&#125; Vue vue双向绑定原理 -&gt; angular与vue双向绑定的区别 -&gt; 性能对比 讲讲虚拟Dom -&gt; patch v-for key 数组或者对象变化检测问题与原因，一般要聊vue对数组做了劫持 组件生命周期，父子组件生命周期 路由实现原理，以及路由钩子相关内容 计算属性和方法，计算属性和watch区别 nextTick原理 mixin的钩子顺序 3.0有哪些变化 Js es6用过哪些？ -&gt; let&#x2F;const promise await class module 很常问 继承的实现方法 -&gt; es5继承和class区别 判断一个变量是不是数组有几种方法？isArray， toString，还有通过原型的构造函数等方法 什么是闭包，闭包的应用 event loop for &gt; forEach &gt; map 区别，性能，注意参数 this的考察，一般是给一段代码看输出然后让你详细讲讲this webpack webpack原理 loader，plugin作用，原理，区别，你有没有写过？ 多页应用怎么配 你知道哪些loader&#x2F;plugin，然后会问你他的作用是什么？例如css-loader，url-loader，我遇到一个变态问我postcss-loader，css-loader，style-loader，url-loader分别具体做了什么…… publicPath 和 path的区别 热更新原理 webpack优化&#x2F;懒加载&#x2F;分包设计 浏览器与网络 跨域问题 浏览器缓存，Cache-Control与expires区别，Cache-Control有哪些属性， 如何利用浏览器缓存？ 输入一个url发生了什么，准备的详细一点，这里还会引出js的三种加载方式，还可能问每个阶段的优化 http状态码 https与http区别，https的混合加密，非对称加密与对称加密的过程， 非对称加密与对称加密算法性能 cookie，session的区别，cookie有哪些属性，这里可以聊聊sameSite，httpOnly防xss攻击 http请求有哪些头部信息？响应有哪些头部信息？Content-Type有哪些类型？ xss,csrf是什么？怎么预防？ http2.0 与 1.x的区别？ CDN的特点， 分布式节点，回源， 缓存，cdn静态资源定期推送 css flex布局 水平垂直居中的几种方法 三栏&#x2F;两栏布局 层叠上下文 em, rem, vw 和vh， 移动端响应式布局方案 盒子模型 css权重 实现三角形，梯形 动画 代码 二分查找 乱序算法 实现new， instanceOf，promise ，promise all啥的 两个有序数组合并 两数之和等于n 数组最大和 最大子串长度 reduce用法， 用reduce实现map 排序 不太直接让你写排序算法，而是会做个结合题，给表格排序之类的，会和dom，css结合 实现深拷贝 实现new， instanceOf 实现并发限制，异步最多4个并发 实现延迟n秒重试，最大重试次数t， attempt(fn, times, delay) 实现LazyMan &#x2F;&#x2F; LazyMan(“Hank”);&#x2F;&#x2F; &#x3D;&gt; Hi! This is Hank! &#x2F;&#x2F; LazyMan(“Hank”).sleep(2).eat(‘dinner’);&#x2F;&#x2F; &#x3D;&gt; Hi! This is Hank!&#x2F;&#x2F; 等待10秒&#x2F;&#x2F; &#x3D;&gt; Wake up after 10&#x2F;&#x2F; &#x3D;&gt; Eat dinner. &#x2F;&#x2F; LazyMan(“Hank”).eat(‘dinner’).eat(‘supper’);&#x2F;&#x2F; &#x3D;&gt; Hi! This is Hank!&#x2F;&#x2F; &#x3D;&gt; Eat dinner.&#x2F;&#x2F; &#x3D;&gt; Eat supper. &#x2F;&#x2F; LazyMan(“Hank”).sleepFirst(2).eat(‘supper’);&#x2F;&#x2F; 等待5秒&#x2F;&#x2F; &#x3D;&gt; Hi! This is Hank!&#x2F;&#x2F; &#x3D;&gt; Eat supper.","categories":[],"tags":[]},{"title":"vue 父子组件的生命周期顺序","slug":"vue-父子组件的生命周期顺序","date":"2020-07-03T16:18:42.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/677899705/","link":"","permalink":"http://didiorg.com/677899705/","excerpt":"加载渲染过程","text":"加载渲染过程 同步加载父组件 beforeCreate, created, beforMount子组件 beforeCreate, created, beforMount孙子组件 beforeCreate, created, beforMount孙子组件 mounted子组件 mounted父组件 mounted 异步加载父组件 beforeCreate, created, beforMount, mounted子组件 beforeCreate, created, beforMount, mounted 更新过程父组件 beforeUpdate子组件 beforeUpdate子组件 updated父组件 updated 销毁过程父组件 beforeDestroy子组件 beforeDestroy子组件 destroyed父组件 destroyed","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://didiorg.com/tags/vue/"},{"name":"vue 原理","slug":"vue-原理","permalink":"http://didiorg.com/tags/vue-%E5%8E%9F%E7%90%86/"}]},{"title":"JS 普通函数跟箭头函数的区别","slug":"JS-普通函数跟箭头函数的区别","date":"2020-07-03T15:31:38.000Z","updated":"2022-08-02T02:39:10.648Z","comments":true,"path":"/3671102502/","link":"","permalink":"http://didiorg.com/3671102502/","excerpt":"","text":"箭头函数不会产生this, 会捕捉当前的执行上下文中的this当做自己的this 箭头函数不能做为构造函数 箭头函数不能绑定 arguments call&#x2F;apply&#x2F;bind 对箭头函数不起作用 箭头函数没有原型属性 箭头函数不能当作 Generator 函数，不能使用 yield 关键字","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://didiorg.com/tags/js/"},{"name":"js 基础","slug":"js-基础","permalink":"http://didiorg.com/tags/js-%E5%9F%BA%E7%A1%80/"}]},{"title":"JS 常见手撕代码题","slug":"JS-常见手撕代码题","date":"2020-06-17T14:18:36.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/979881800/","link":"","permalink":"http://didiorg.com/979881800/","excerpt":"这种题目，除了多练，没别的方法","text":"这种题目，除了多练，没别的方法 1. 实现一个类似 emiter 的类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class EventEmiter &#123; constructor() &#123; this.emiterMap = &#123;&#125; &#125; on(event, callback) &#123; if (this.emiterMap[event]) &#123; this.emiterMap[event].push(callback) &#125; else &#123; this.emiterMap[event] = [callback] &#125; &#125; emit() &#123; let [event, ...args] = [...arguments] this.emiterMap[event] &amp;&amp; this.emiterMap[event].forEach((callback) =&gt; callback(...args)) &#125; off(event, callback) &#123; this.emiterMap[event] = this.emiterMap[event].filter((cb) =&gt; cb != callback) &#125; once(event, callback) &#123; let fn = (...args) =&gt; &#123; callback(args) this.off(event, fn) &#125; this.on(event, fn) &#125;&#125;let em = new EventEmiter()var work1 = function () &#123; console.log(&#x27;work1&#x27;)&#125;var work2 = function () &#123; console.log(&#x27;work2&#x27;)&#125;var once1 = function () &#123; console.log(&#x27;once1&#x27;)&#125;em.on(&#x27;work1&#x27;, work1)em.on(&#x27;work2&#x27;, work2)em.emit(&#x27;work1&#x27;)em.emit(&#x27;work1&#x27;)em.emit(&#x27;work2&#x27;)em.emit(&#x27;work2&#x27;)em.once(&#x27;once&#x27;, once1)em.emit(&#x27;once&#x27;)em.emit(&#x27;once&#x27;)em.emit(&#x27;once&#x27;)em.emit(&#x27;once&#x27;)em.emit(&#x27;once&#x27;)em.emit(&#x27;once&#x27;)var day = 18em.on(&#x27;addday&#x27;, function () &#123; let [...args] = [...arguments] console.log(&#x27;in add arg: &#x27;, args[0], args[1]) day = day + Number(args[0]) + Number(args[1]) console.log(&#x27;add day: &#x27;, day)&#125;)em.on(&#x27;subday&#x27;, function () &#123; day = day - 5&#125;)em.on(&#x27;logday&#x27;, function () &#123; console.log(day)&#125;)em.emit(&#x27;addday&#x27;, 10, 20)em.emit(&#x27;subday&#x27;)em.emit(&#x27;logday&#x27;) 2. 函数柯里化12345678910111213141516function add() &#123; var _args = Array.prototype.slice.call(arguments) // 利用闭包不会释放函数里边的变量特性，把新的参数再push到原来的参数里边 var _addr = function () &#123; _args.push(...arguments) return _addr &#125; // 利用每次输出值的时候， 会自动调toString的方法， 在这里重写一下toString _addr.toString = () =&gt; _args.reduce((total, num) =&gt; total + num) return _addr&#125;console.log(add(1, 2, 3)(4)(5)) 3. 快速排序123456789101112131415161718192021222324function quickSort(arr) &#123; if (arr.length &lt;= 1) &#123; return arr &#125; var pivotIdx = Math.floor(arr.length / 2) var pivot = arr.splice(pivotIdx, 1)[0] var left = [] var right = [] for (let index = 0; index &lt; arr.length; index++) &#123; const element = arr[index] if (element &lt; pivot) &#123; left.push(element) &#125; else &#123; right.push(element) &#125; &#125; return quickSort(left).concat([pivot], quickSort(right))&#125;console.log(quickSort([2, 4, 1, 7, 3, 5])) 4. 实现一个 calc 方法可以将输入的数拆解为尽可能多的乘数，所有数相乘等于输入数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * @param &#123;number&#125; num 乘积 * @return &#123;Array&#125; 拆解后的乘数 */// function calc(num) &#123;// function calc(num) &#123;// const arr = [];// var i = 2;// while (i &lt;= num) &#123;// if (num % i === 0) &#123;// arr.push(i);// num = num / i;// &#125; else &#123;// i++;// &#125;// &#125;// return arr;// &#125;// &#125;function isPrime(num) &#123; for (let i = 2; i &lt;= Math.sqrt(num); i++) &#123; if (num % i == 0) &#123; return false &#125; &#125; return true&#125;function calc(n) &#123; let list = [] while (n &gt; 1) &#123; for (let i = 2; i &lt;= n; i++) &#123; if (isPrime(i) &amp;&amp; n % i === 0) &#123; list.push(i) n /= i &#125; &#125; &#125; return list&#125;console.log(calc(2))// [2]console.log(calc(8))// [2, 2, 2]console.log(calc(24))// [2, 2, 2, 3]console.log(calc(30))// [2, 3, 5] 5. 多维数组扁平化12345678function flatDeep(arr) &#123; return arr.reduce( (acc, curr) =&gt; (Array.isArray(curr) ? acc.concat(flatDeep(curr)) : acc.concat(curr)), [] )&#125;let a = [1, 2, 3, [4, 5, 6, [7, 8], 9], 10]console.log(flatDeep(a)) 6. 击鼓传花1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859let players = [ &#x27;n1&#x27;, &#x27;n2&#x27;, &#x27;n3&#x27;, &#x27;n4&#x27;, &#x27;n5&#x27;, &#x27;n6&#x27;, &#x27;n7&#x27;, &#x27;n8&#x27;, &#x27;n9&#x27;, &#x27;n10&#x27;, &#x27;n11&#x27;, &#x27;n12&#x27;, &#x27;n13&#x27;, &#x27;n14&#x27;, &#x27;n15&#x27;,]class Queue &#123; constructor() &#123; this.queueList = [] &#125; addItem(item) &#123; this.queueList.push(item) &#125; delItem(item) &#123; return this.queueList.shift() &#125; size() &#123; return this.queueList.length &#125;&#125;function findPepole(arr, num) &#123; let myQueue = new Queue() for (let i = 0; i &lt; arr.length; i++) &#123; const element = arr[i] myQueue.addItem(element) &#125; let eliminated = &#x27;&#x27; while (myQueue.size() &gt; 1) &#123; // 这里相当于把你设定的长度减去一个放到了这个队列的后边 for (let i = 0; i &lt; num; i++) &#123; myQueue.addItem(myQueue.delItem()) //数组出队然后入队 &#125; // 这里就是把设定长度的那个位置的那一个删除了 eliminated = myQueue.delItem() console.log(eliminated + &#x27; 在击鼓传花游戏中被淘汰。&#x27;) &#125; return myQueue.queueList&#125;let victor = findPepole(players, 3)[0]console.log(`胜利者是： $&#123;victor&#125;`) 主要思路就是， 一个一个删，如果删除的那一个不是指定位置的那一个，就放到最后边，如果是， 就直接删除，直到数组只有一个了 7. 两个数组求交集12345678910111213141516171819let list1 = [1, 2, 3, 4, 4, 5]let list2 = [4, 4, 5, 6, 7, 8]function intersection(arr1, arr2) &#123; let tempList = [] for (let i = 0; i &lt; arr1.length; i++) &#123; const element = arr1[i] if (arr2.includes(element)) &#123; tempList.push(element) &#125; &#125; return tempList // return arr1.filter(item =&gt; arr2.includes(item)); // return arr1.filter(item =&gt; new Set(arr2).has(item));&#125;console.log(intersection(list1, list2)) 8. 求字符串数组的最长公共前缀比如输入: [“flower”,”flow”,”flight”]，输出: “fl” 123456789101112131415161718let longestCommonPrefix = function (strs) &#123; if (strs.length === 0) return &#x27;&#x27; if (strs.length === 1) return strs[0] let tempStr = strs[0] for (let i = 0; i &lt; strs.length; i++) &#123; let j = 0 for (; j &lt; strs.length &amp;&amp; j &lt; tempStr.length; j++) &#123; if (tempStr.charAt(j) !== strs[i].charAt(j)) &#123; break &#125; &#125; tempStr = tempStr.substring(0, j) &#125; return tempStr&#125;let commonStr = longestCommonPrefix([&#x27;flower&#x27;, &#x27;flow&#x27;, &#x27;flight&#x27;])console.log(commonStr) 9. 合并两个数组12345678910111213141516171819202122// 合并两个数组let a = [1, 2, 3]let b = [4, 5, 6]// concatlet c = a.concat(b)console.log(c, a, b)// // apply// Array.prototype.push.apply(a, b)// console.log(a)// for// for (let i = 0; i &lt; b.length; i++) &#123;// a.push(b[i])// &#125;// console.log(a);// // ...// c =[...a, ...b]// console.log(c); 10. 实现一个 PromiseLinit根据 urls 数组内的 url 地址进行并发网络请求，最大并发数 maxNumber,当所有请求完毕后调用 callback 函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function fetch(url) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;ok &#x27; + url) &#125;, Math.floor(Math.random() * 1000) + 600) &#125;)&#125;function PromiseLinit(urls, limit, callback) &#123; let result = [] let urlsLen = urls.length let i = 0 while (i &lt; limit) &#123; next() &#125; function next() &#123; let current = i++ if (current &gt;= urlsLen) &#123; result.length === urlsLen &amp;&amp; callback(result) return &#125; console.log(`$&#123;current + 1&#125;开始`) fetch(urls[current]) .then((res) =&gt; &#123; console.log(`$&#123;current + 1&#125;成功结束`) result.push(res) if (current &lt; urlsLen) &#123; next() &#125; &#125;) .catch((err) =&gt; &#123; console.log(`$&#123;current + 1&#125;失败结束`) result.push(res) if (current &lt; urlsLen) &#123; next() &#125; &#125;) &#125;&#125;let urls = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]PromiseLinit(urls, 4, (res) =&gt; &#123; console.log(&#x27;success: &#x27;, res)&#125;) 11. 求 left， right 最终宽度11.1 算收缩1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .container &#123; width: 600px; height: 300px; display: flex; &#125; .left &#123; flex: 1 2 500px; background: red; &#125; .right &#123; flex: 2 1 400px; background: blue; &#125; &lt;/style&gt;&lt;/html&gt; 子项的收缩宽度 &#x3D; 子项收缩比例 X 溢出宽度子项收缩比例 &#x3D; 子项宽度 X 子项收缩系数 &#x2F; 所有子项的(宽度 X 系数)之和 对应题目： 子项溢出空间的宽度为 $500 + 400 - 600 &#x3D; 300$left 收缩比例：$(500 × 2) ÷ (500 × 2 + 400 × 1) ≈ 0.7143$right 收缩比例：$(400 × 1) ÷ (500 × 2 + 400 × 1) ≈ 0.2857$对应的： left 收缩宽度：$0.7143 × 300 &#x3D; 214.29$right 收缩宽度：$0.2857 × 300 &#x3D; 85.71$所以： left 最终宽度：$500 - 214.29 &#x3D; 285.71$right 最终宽度：$400 - 85.71 &#x3D; 314.29$ 11.2 算扩展123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .container &#123; width: 600px; height: 300px; display: flex; &#125; .left &#123; flex: 1 2 300px; background: red; &#125; .right &#123; flex: 2 1 200px; background: blue; &#125; &lt;/style&gt;&lt;/html&gt; left 最终宽度：300 + (1&#x2F;3) _ (600 - (300 + 200)) &#x3D; 333.33right 最终宽度：200 + (2&#x2F;3) _ (600 - (300 + 200)) &#x3D; 266.66 12. 实现一个 promise.all123456789101112131415161718192021222324252627282930313233343536373839404142// 1. 参数： 数组， 数项是promise返回执行结果， 如果不是， 直接返回// 2. 返回值： Promise 对象// 3. 如果数组里边有一个 Promise rejected 了， 直接返回 rejected// 4. 当全部执行成功后， 返回一个有所有执行结果的数组function isPromise(obj) &#123; return ( obj &amp;&amp; (typeof obj === &#x27;object&#x27; || typeof obj === &#x27;function&#x27;) &amp;&amp; typeof obj.then === &#x27;function&#x27; )&#125;function myPromiseAll(arr) &#123; let requests = [] return new Promise((resolve, reject) =&gt; &#123; arr.map((item, idx) =&gt; &#123; if (isPromise(item)) &#123; item .then((result) =&gt; &#123; requests[idx] = result if (requests.length === arr.length) &#123; resolve(requests) &#125; &#125;) .catch((err) =&gt; &#123; reject(err) &#125;) &#125; else &#123; requests[idx] = item &#125; &#125;) &#125;)&#125;let p1 = Promise.resolve(3)let p2 = 1337let p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 100, &#x27;foo&#x27;)&#125;)myPromiseAll([p1, p2, p3]).then((values) =&gt; &#123; console.log(values) // [3, 1337, &quot;foo&quot;]&#125;) 13. 字符串排序在一个字符串数组中有红、黄、蓝三种颜色的球，且个数不相等、顺序不一致，请为该数组排序。使得排序后数组中球的顺序为:黄、红、蓝。 例如：红蓝蓝黄红黄蓝红红黄红，排序后为：黄黄黄红红红红红蓝蓝蓝。 123456789101112let str1 = &#x27;红蓝蓝黄红黄蓝红红黄红&#x27;let obj = &#123;红: 1, 蓝: 2, 黄: 3&#125;let str2 = st1 .split(&#x27;&#x27;) .sort((a, b) =&gt; &#123; return obj[a] - obj[b] &#125;) .join(&#x27;&#x27;)console.log(str2) 14. 数组转树，并去重如何将 [{id: 1}, {id: 2, pId: 1}, …] 的重复数组（有重复数据）转成树形结构的数组 [{id: 1, child: [{id: 2, pId: 1}]}, …] （需要去重） 123456789101112131415161718192021222324252627const arr = [&#123;id: 1&#125;, &#123;id: 2, pId: 1&#125;, &#123;id: 3, pId: 2&#125;, &#123;id: 4&#125;, &#123;id: 3, pId: 2&#125;, &#123;id: 5, pId: 4&#125;]const map = arr.reduce((res, item, curIdx) =&gt; ((res[item.id] = Object.assign(&#123;&#125;, item)), res), &#123;&#125;)let res = []for (const item of Object.values(map)) &#123; if (item.pId) &#123; const parent = map[item.pId] parent.child = parent.child || [] parent.child.push(item) &#125; else &#123; res.push(item) &#125;&#125;console.log(&#x27;res: &#x27;, JSON.stringify(res))// [&#123;&quot;id&quot;:1,&quot;child&quot;:[&#123;&quot;id&quot;:2,&quot;pId&quot;:1,&quot;child&quot;:[&#123;&quot;id&quot;:3,&quot;pId&quot;:2&#125;]&#125;]&#125;,&#123;&quot;id&quot;:4,&quot;child&quot;:[&#123;&quot;id&quot;:5,&quot;pId&quot;:4&#125;]&#125;]// 不去重// function arrayToTree(tree, pid = 0) &#123;// return tree.filter(item =&gt; item.pid === pid).map(listItem =&gt; (&#123;// ...listItem,// child: arrayToTree(tree, listItem.id)// &#125;))// &#125;// console.log(arrayToTree(data)); 15. 树转数组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const data = [ &#123; id: 1, pid: 0, name: &#x27;no.1&#x27;, children: [ &#123; id: 2, pid: 1, name: &#x27;no.2&#x27;, children: [ &#123;id: 6, pid: 2, name: &#x27;no.6&#x27;&#125;, &#123;id: 7, pid: 2, name: &#x27;no.7&#x27;&#125;, &#123;id: 8, pid: 2, name: &#x27;no.8&#x27;&#125;, ], &#125;, &#123; id: 3, pid: 1, name: &#x27;no.3&#x27;, children: [ &#123;id: 9, pid: 3, name: &#x27;no.9&#x27;&#125;, &#123;id: 10, pid: 3, name: &#x27;no.10&#x27;&#125;, &#123;id: 11, pid: 3, name: &#x27;no.11&#x27;&#125;, ], &#125;, &#123; id: 4, pid: 1, name: &#x27;no.4&#x27;, children: [ &#123;id: 12, pid: 4, name: &#x27;no.12&#x27;&#125;, &#123; id: 13, pid: 4, name: &#x27;no.13&#x27;, children: [&#123;id: 14, pid: 13, name: &#x27;no.14&#x27;&#125;], &#125;, ], &#125;, &#123;id: 5, pid: 1, name: &#x27;no.5&#x27;&#125;, ], &#125;,]function treeToArray(list, newArray = []) &#123; list.forEach((item) =&gt; &#123; if (item.children) &#123; const tempItem = item.children delete item.children newArray.push(item) if (tempItem.length &gt; 0) &#123; return treeToArray(tempItem, newArray) &#125; &#125; newArray.push(item) &#125;) return newArray&#125;console.log(&#x27;newArray: &#x27;, treeToArray(data)) 16. 斐波那契数列给一个 n 得到一个斐波那契数列数组 12345678910111213141516171819202122232425262728let fibonacci = (function (n) &#123; var cache = &#123;&#125; return function (n) &#123; if (n === 1 || n === 2) return 1 if (cache[n]) return cache[n] return (cache[n] = fibonacci(n - 1) + fibonacci(n - 2)) &#125;&#125;)()function getFibArray(n) &#123; let res = [] for (let i = 1; i &lt;= n; i++) &#123; res.push(fibonacci(i)) &#125; return res&#125;let t1 = new Date().getTime()console.log(getFibArray(33))let t2 = new Date().getTime()console.log(t2 - t1)// 这里的时间是方便对比加上cache跟没加cache里的区别// 加 catch 1// 不加catch 2048 17. 深拷贝123456789101112131415161718192021222324252627282930313233343536373839404142function deepClone(obj) &#123; if (typeof obj === &#x27;object&#x27;) &#123; const temp = Array.isArray(obj) ? [] : &#123;&#125; for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; if (typeof obj[key] === &#x27;object&#x27;) &#123; temp[key] = deepClone(obj[key]) &#125; else &#123; temp[key] = obj[key] &#125; &#125; &#125; return temp &#125; return obj&#125;let ahui = &#123; name: &#x27;ahui&#x27;, age: &#x27;18&#x27;, city: [&#x27;泰国&#x27;, &#x27;新加坡&#x27;, &#x27;印度尼西亚&#x27;], sayname: function () &#123; return this.name &#125;, saycity: function () &#123; return this.city &#125;,&#125;let angeli = deepClone(ahui)angeli.name = &#x27;angeli&#x27;console.log(ahui.sayname())console.log(angeli.sayname())angeli.city = [&#x27;深圳&#x27;, &#x27;娄底&#x27;]console.log(ahui.saycity())console.log(angeli.saycity()) 数组求子集[1, 2, 3] 的所有子集是： [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] 123456789101112131415161718let arr = [1, 2, 3]function allSubsets(a) &#123; let res = [[]] for (let i = 0; i &lt; a.length; i++) &#123; const tempRes = res.map(subset =&gt; &#123; const item = subset.concat([]) item.push(a[i]) return item &#125;) res = res.concat(tempRes) &#125; return res&#125;console.log(allSubsets(arr)); 二分法查数","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://didiorg.com/tags/js/"},{"name":"js 算法","slug":"js-算法","permalink":"http://didiorg.com/tags/js-%E7%AE%97%E6%B3%95/"}]},{"title":"JS 执行过程题","slug":"JS 执行过程题","date":"2020-06-16T10:22:47.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/1491244432/","link":"","permalink":"http://didiorg.com/1491244432/","excerpt":"执行过程，就是要理解js的执行上下文","text":"执行过程，就是要理解js的执行上下文 构造函数12345678910111213141516171819202122function Person1(name) &#123; this.name = name;&#125;function Person2(name) &#123; if (name) &#123; this.name = name; &#125;&#125;function Person3(name) &#123; this.name = name || &#x27;jack&#x27;; return &#123; name: &#x27;lilei&#x27;, &#125;;&#125;Person1.prototype.name = &#x27;Tom&#x27;;Person2.prototype.name = &#x27;Tom&#x27;;Person3.prototype.name = &#x27;Tom&#x27;;console.log(new Person1().name, new Person2().name, new Person3().name); 第一个：当构造函数里边有 name 属性的时候， 就不会去原型上找了第二个：当构造函数里边没有 name 属性的时候，就会去原型上找第三个：当构造函数有返回值的时候，new 操作的时候就会返回 return 里边的内容 执行上下文，this123456789101112131415161718192021222324var name = &#x27;global&#x27;;function outer(name) &#123; console.log(1, name); // outer12121 console.log(&#x27;arg1&#x27;, arguments[0]); // outer12121 var name = &#x27;outer&#x27;; console.log(&#x27;arg2&#x27;, arguments[0]); // outer console.log(2, name); // outer inner(); console.log(3, this.name); // global if (name) &#123; console.log(4, name); // error let name = &#x27;if-name&#x27;; &#125;&#125;function inner() &#123; console.log(5, name); // glboal&#125;outer(&#x27;outer12121&#x27;); 这里注意一个 log(4)那里， 会报错， 因为在 if{}这个上下文中提前使用了 let 定义的 name，let 定义的变量是没有变量提升的当函数里边有跟参数同名的变量时， 会改变原来参数的值，同时也会改变 arguments, 因为 arguments 其实就是一个引用 this 指向的问题123456789101112var name = &#x27;global&#x27;;function sayName() &#123; console.log(this.name);&#125;var obj = &#123; name: &#x27;obj&#x27;, sayName: function (fn) &#123; fn &amp;&amp; fn(); &#125;,&#125;;obj.sayName(sayName); // global 12345678var a = 1;var obj = &#123; a: 2, getA: () =&gt; &#123; return this.a; &#125;,&#125;;console.log(obj.getA()); // 1 箭头函数不会改变环境的 this， 所以这里的 this 不是 obj 对象里边的， 这个 obj.getA()就是一个方法，在全局下执行的一个方法，所以这里是 1 JS 执行机制的问题12345678910111213141516171819202122new Promise((resolve, reject) =&gt; &#123; console.log(1); setTimeout(() =&gt; &#123; console.log(2); &#125;); resolve();&#125;) .then(() =&gt; &#123; console.log(3); &#125;) .then(() =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; console.log(4); &#125;).then(() =&gt; &#123; console.log(5); &#125;); &#125;) .then(() =&gt; &#123; console.log(6); &#125;);console.log(7);// 1 7 3 4 2 这是一个很有意思的题目考了 js 事件轮循， js 执行机制，promiselog(5) 跟 log(6) 的时候， 这里因为上 log(4)那个 promise 并没有完成(resolve 跟 reject 都没有被调用)， 所以 5， 6 是不会打印出来的js 执行的时候，是单线程的，通过事件轮循实现异步，每一次轮循都会把异步事件添加到队列中，这里的事件分为微任务(promise)跟宏任务(script, setTimeout, setInterval)，一个轮循结束之后，先执行微任务，再执行宏任务 12345678910111213141516171819new Promise((resolve, reject) =&gt; &#123; console.log(1) reject()&#125;) .then(() =&gt; &#123; console.log(2) &#125;, () =&gt; &#123; console.log(3) &#125;) .catch(() =&gt; &#123; console.log(4); return Promise.reject() &#125;) .then(() =&gt; &#123; console.log(5); &#125;) .catch(() =&gt; &#123; console.log(6); &#125;) 异步任务分析123456789console.log(1);setTimeout(function () &#123; console.log(2);&#125;, 1000);setTimeout(function () &#123; console.log(3);&#125;, 0);console.log(4);// 1 4 3 2 异步任务，当读取到异步任务的时候，将异步任务放置到Event table（事件表格）中，当满足某种条件或者说指定事情完成了（这里的是时间分别是达到了0ms和1000ms）当指定事件完成了才从Event table中注册到Event Queue（事件队列），当同步事件完成了，便从Event Queue中读取事件执。（因为3的事情先完成了，所以先从Event table中注册到Event Queue中，所以先执行的是3而不是在前面的2） forEach VS for &amp; for of123456789101112131415161718const list = [1, 2, 3]const square = num =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(num * num) &#125;, 1000) &#125;)&#125;function test() &#123; list.forEach(async x=&gt; &#123; const res = await square(x) console.log(res) &#125;)&#125;test()// 一秒后一次打印出 1， 4， 9 forEach 是不能阻塞的，默认是请求并行发起 123456789101112131415161718192021const list = [1, 2, 3]const square = (num) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(num * num) &#125;, 1000) &#125;)&#125;async function test() &#123;// for (let i = 0; i &lt; list.length; i++) &#123;// const res = await square(list[i])// console.log(res)// &#125; for(let i of list) &#123; const res = await square(i) console.log(&quot;res: &quot;, res); &#125;&#125;test()// 一秒之后打印1， 再过一秒打印4， 再过一秒打印9 for 跟 for of 是会阻塞的 普通函数跟箭头函数的区别定义好的obj， 分别执行 obj.f1() obj.f2() new obj.f1() new obj.f2() 会发生什么 123456789101112const obj = &#123; f1: function() &#123; console.log(this); &#125;, f2: () =&gt; &#123; console.log(this); &#125;&#125;obj.f1()obj.f2()new obj.f1()new obj.f2() 这是一个很能考察基本功的题目 分析一下， 这里f1跟f2的区别就是，一个普通函数跟一个箭头函数的区别， 如果真的很了解头函数跟普通函数的区别， 这里还是很简单的 123456obj.f1() 这个简单， 就是打印 objobj.f2() 这里，this 肯定不是打印 obj， 但是也不是 window ！！！ 而是一个空对象new obj.f1() 这里 . 的执行优先级高于 new , 所以就是把 f1 这个函数当作一个构造函数， 去实例化了 f1, 所以， 这里的 this， 就是实例化之后的 f1 这个实例从上边就知道了，new obj.f2() 这个操作同样是去实例 f2 ，你是 f2 是一个箭头函数，他是不能当做构造函数的，所以这里就会报错","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://didiorg.com/tags/js/"},{"name":"js算法","slug":"js算法","permalink":"http://didiorg.com/tags/js%E7%AE%97%E6%B3%95/"}]},{"title":"js 多维数组(数独)扁平化","slug":"js-多维数组-数独-扁平化","date":"2020-06-07T04:25:27.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/1909019848/","link":"","permalink":"http://didiorg.com/1909019848/","excerpt":"[1, 2, 3, [4, 5, 6, [7, 8], 9], 10] &#x3D;&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]","text":"[1, 2, 3, [4, 5, 6, [7, 8], 9], 10] &#x3D;&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] reduce + concat123456function flattenDeep(arr) &#123; return arr.reduce((acc, curr) =&gt; Array.isArray(curr) ? acc.concat(flattenDeep(curr)) : acc.concat(curr), [])&#125;let a = [1, 2, 3, [4, 5, 6, [7, 8], 9], 10]console.log(flattenDeep(a)) toString123456function flattenDeep(arr) &#123; return arr.toString().split(&quot;,&quot;).map(item =&gt; Number(item))&#125;let a = [1, 2, 3, [4, 5, 6, [7, 8], 9], 10]console.log(flattenDeep(a)) 这是什么高级方法 ！！！ forEach1234567891011121314function flattenDeep(arr) &#123; let res = [] arr.forEach(item =&gt; &#123; if (Array.isArray(item)) &#123; res = res.concat(flattenDeep((item))) &#125; else &#123; res.push(item) &#125; &#125;) return res&#125;let a = [1, 2, 3, [4, 5, 6, [7, 8], 9], 10]console.log(flattenDeep(a)) 原理跟reduce的一样， 应该说 reduce 的原理跟这个一样","categories":[],"tags":[]},{"title":"JS 原型链继承问题拓展","slug":"JS-原型链继承问题拓展","date":"2020-03-13T14:35:34.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/3012898819/","link":"","permalink":"http://didiorg.com/3012898819/","excerpt":"原型链继承存在的问题： 包含引用类型的原型属性会被所有实例共享，这会导致对一个实例的修改会影响到另一个实例。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。原先的实例属性就变成了现在的原型属性 在创建了类型的实例时，不能向超类型的构造函数中传递参数","text":"原型链继承存在的问题： 包含引用类型的原型属性会被所有实例共享，这会导致对一个实例的修改会影响到另一个实例。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。原先的实例属性就变成了现在的原型属性 在创建了类型的实例时，不能向超类型的构造函数中传递参数 12345678910111213141516171819function SuperType () &#123; this.citys = [&#x27;北京&#x27;, &#x27;上海&#x27;, &#x27;深圳&#x27;];&#125;function SubType () &#123; this.name = &#x27;sub&#x27;;&#125;SubType.prototype = new SuperType();var instance1 = new SubType();instance1.citys.push(&#x27;阿斯加德&#x27;); console.log(instance1.citys) // [&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;, &quot;阿斯加德&quot;]var instance2 = new SubType();console.log(instance2.citys) // [&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;, &quot;阿斯加德&quot;] 上面的代码完美的解释了原型链继承的时候包含引用类型的原型属性会被所有实例共享，这会导致对一个实例的修改会影响到另一个实例 把代码稍微改一下 12345678910111213141516171819function SuperType () &#123; this.citys = [&#x27;北京&#x27;, &#x27;上海&#x27;, &#x27;深圳&#x27;];&#125;function SubType () &#123; this.name = &#x27;sub&#x27;;&#125;SubType.prototype = new SuperType();var instance1 = new SubType();instance1.citys = [&#x27;阿斯加德&#x27;];console.log(instance1.citys) // [&quot;阿斯加德&quot;]var instance2 = new SubType();console.log(instance2.citys) // [&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;] 这里会的发现 instance1.citys 是 [“阿斯加德”]， 这个完全没毛病，但是 instance2.citys为啥是 [“北京”, “上海”, “深圳”] 呢？ 而不是 [“阿斯加德”] ？ 难道是我们上边说的 包含引用类型的原型属性会被所有实例共享，这会导致对一个实例的修改会影响到另一个实例 有问题 ？ 如果你也像我这样， 对这个不清楚， 那么下边跟我一起分析一下吧。 不管怎样， 碰到这种问题， 我们先去看一下 instance1 跟 instance2 到底是个啥。。。。 12345678910111213141516171819function SuperType () &#123; this.citys = [&#x27;北京&#x27;, &#x27;上海&#x27;, &#x27;深圳&#x27;];&#125;function SubType () &#123; this.name = &#x27;sub&#x27;;&#125;SubType.prototype = new SuperType();var instance1 = new SubType();instance1.citys = [&#x27;阿斯加德&#x27;];console.log(instance1)var instance2 = new SubType();console.log(instance2) 于是我们就会看到如下结果 12console.log(instance1); // SubType &#123;name: &quot;sub&quot;, citys: Array(1)&#125;console.log(instance2); // SubType &#123;name: &quot;sub&quot;&#125; 很明显的发现，只有instance1才有 citys 这个属性， 而 instance2 是没有 citys 这个属性的。这是为啥呢？ 在原型链里有一句我们经常说到的话：当自身没有这个属性的时候，就会去它的原型链上找。 这里很明显，我们给 instance1 添加了一个 citys 的属性，所以能够找到 citys ， 而 instance2 的话， 自身没有 citys 但是在它的原型链上， SuperType 是有 citys 属性的， 所以也能访问得到。也可以通过下边的结果看出来 12console.log(instance1.hasOwnProperty(&#x27;citys&#x27;)) // true 说明这个citys属性是自身的属性，而不是继承而来的console.log(instance2.hasOwnProperty(&#x27;citys&#x27;)) // false 说明这个citys属性是通过继承得到的 通过上边的分析， 我们不难理解为何当 instance1.citys = [&#39;阿斯加德&#39;] 的时候， instance2.citys输出的是 [“北京”, “上海”, “深圳”] 了 原因就是 instace1 上的 citys 是赋值操作的时候给这个实例新增的一个属性，而 instance2 上的 citys 属性是从 SuperType 上继承过来的，所以对 instance1 进行赋值时，对 instance2 没有影响。 这里不要跟 instance1.citys.push([&#39;阿斯加德&#39;]) 这个操作混淆了，很明显， 这里 instance1.citys.push() 的操作， 是对 instance1 从 SuperType 里边继承过来的 citys 属性进行的操作，这个属性是共享的，在一个实例里修改过会影响其它实例，所以会对 instance2.citys 有影响。 如果还没有理解，那就再看一下下边代码，加深一下理解 123456789101112131415161718192021function SuperType () &#123; this.citys = [&#x27;北京&#x27;, &#x27;上海&#x27;, &#x27;深圳&#x27;];&#125;function SubType () &#123; this.name = &#x27;sub&#x27;;&#125;SubType.prototype = new SuperType();var instance1 = new SubType();instance1.citys = [&#x27;阿斯加德&#x27;];console.log(instance1.citys) // [&quot;阿斯加德&quot;]var instance2 = new SubType();console.log(instance1.citys) // [&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;]delete instance1.citysconsole.log(instance2.citys) // [&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;]","categories":[],"tags":[]},{"title":"前端进阶 精选20道面试题","slug":"前端进阶-精选20道面试题","date":"2020-03-07T06:43:51.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/2410320999/","link":"","permalink":"http://didiorg.com/2410320999/","excerpt":"1. new 的实现原理","text":"1. new 的实现原理 新建一个空对象 let newObj &#x3D; {} 修改对象的原型: 把新对象的 __proto__ 指向构造函数的 prototype 属性 改变 this 指向，并执行 返回对象里边的内容原来构造函数里边的内容12345678function _new () &#123; let obj = &#123;&#125;; // 取第一个参数，第一参娄就是构造函数 let [Constructor, ...args] = [...arguments]; obj.__proto__ = Constructor.prototype; let result = Constructor.apply(obj, args); return result === &#x27;object&#x27; ? result : obj;&#125; 2. 如何正确判断一 this 指向分析好上下文：谁调用指向谁 分四种情况：new, 显示，隐式，默认 参考这里： this指向 3. 深拷贝和浅拷贝的区别是什么？ 实现一个深拷贝浅拷贝一般指用来拷贝栈内存上的东西，而深拷贝一般是指用来拷贝堆内存上的东西 这是我个人的理解， 为啥这么说呢 ？ 浅拷贝：创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。 深拷贝：将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象 之前有文章介绍过基本类型是存在栈内存上的，而引用类型来说，对象的属性是保存在栈内存中的，属性对应的值是保存在堆内存中的, 同时，栈内存上也保存着该属性的值所在的堆内存的地址。 所以我们可以这样去理解，浅拷贝是栈内存上的拷贝，而深拷贝是堆内存上的拷贝. 首先我们要明月一个前提： 只有对象里嵌套对象的情况下,才会根据需求讨论,我们要深拷贝还是浅拷贝。 浅拷贝实现： Oject.assign()123456789101112131415161718192021222324let ahui = &#123; name: &quot;ahui&quot;, age: &quot;18&quot;, city: [&quot;泰国&quot;,&quot;新加坡&quot;,&quot;印度尼西亚&quot;], sayname: function () &#123; return this.name &#125;, saycity: function () &#123; return this.city &#125;&#125;// let angeli = Object.assign(&#123;&#125;, ahui) // 这样实现深拷贝let angeli = Object.assign(ahui, &#123;&#125;) // 这样实现浅拷贝angeli.name = &quot;angeli&quot;console.log(ahui.sayname()) // angeliconsole.log(angeli.sayname()) // angeliangeli.city = [&quot;深圳&quot;,&quot;娄底&quot;]console.log(ahui.saycity()) // [&quot;深圳&quot;,&quot;娄底&quot;]console.log(angeli.saycity()) // [&quot;深圳&quot;,&quot;娄底&quot;] Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 关于 Object.assign()这个方法是深拷贝还是浅拷贝的时候，是分情况的。 假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。也就是说，如果对象的属性值为简单类型（如string， number），通过Object.assign(&#123;&#125;,srcObj);得到的新对象为深拷贝；如果属性值为对象或其它引用类型，那对于这个对象而言其实是浅拷贝的。 深拷贝实现 可以使用各种第三方的库， 我常用 lodash 的 cloneDeep 通过判断加递归实现深拷贝 1234567891011121314151617181920212223242526272829303132333435363738394041424344function cloneDeep(obj) &#123; if (typeof obj === &#x27;object&#x27;) &#123; let tempObj = Array.isArray(obj) ? [] : &#123;&#125; for (key in obj) &#123; // 意思就是__proto__上面的属性,我不拷贝 if (obj.hasOwnProperty(key)) &#123; if (typeof obj[key] === &#x27;object&#x27;) &#123; tempObj[key] = cloneDeep(obj[key]) &#125; else &#123; tempObj[key] = obj[key] &#125; &#125; &#125; return tempObj; &#125; return obj&#125;let ahui = &#123; name: &quot;ahui&quot;, age: &quot;18&quot;, city: [&quot;泰国&quot;,&quot;新加坡&quot;,&quot;印度尼西亚&quot;], sayname: function () &#123; return this.name &#125;, saycity: function () &#123; return this.city &#125;&#125;let angeli = cloneDeep(ahui) // 这样实现深拷贝angeli.name = &quot;angeli&quot;console.log(ahui.sayname()) // ahuiconsole.log(angeli.sayname()) // angeliangeli.city = [&quot;深圳&quot;,&quot;娄底&quot;]console.log(ahui.saycity()) // [&quot;泰国&quot;,&quot;新加坡&quot;,&quot;印度尼西亚&quot;]console.log(angeli.saycity()) // [&quot;深圳&quot;,&quot;娄底&quot;] 4. call&#x2F;apply的实现原理是什么？call 跟 apply 的功能是相同的，都是 改变 this 的执行，并立马执行函数。区别在于传参方式不同： func.call(thisArg,arg1,arg2,...)：第一个参数是 this 指向的对象，其它参数依次传入。func.apply(thisArg,[argsArray])：第一个参数是 this 指向的对象，第二个参数是数组或类数组。 call 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 先使用call 试一下let person = &#123; name: &quot;person&quot;, sayname: function () &#123; return this.name &#125;&#125;console.log(person.sayname()) // personlet ahui = &#123; name: &quot;ahui&quot; &#125;;console.log(person.sayname.call(ahui)) // ahui// 下边我们自己实现一个 callFunction.prototype.imitateCall = function(context = window) &#123; // 这里的 this， 是指原来对象里的方法， 比如下边的 person.sayname context.fn = this // slice(start, end) 方法可从已有的数组中返回选定的元素。 let args = [...arguments].slice(1) // 执行调用的函数， 比如下边的 sayname let result = context.fn(...args) // 删除函数调用，要不然会改变 context delete context.fn // 返回执行结果 return result&#125;console.log(person.sayname.imitateCall(ahui)) // ahui// 再试一下有参数的例子let Boy = function (name, age) &#123; this.name = name this.age = age this.sayInfo = function(name, age) &#123; return `my name is: $&#123;name&#125;, my age: $&#123;age&#125;` &#125;&#125;angeli = new Boy(&quot;angeli&quot;, 18)console.log(angeli.sayInfo(&quot;angeli&quot;, 18)) // 1 my name is: angeli, my age: 18let huihui = &#123;&#125;console.log(angeli.sayInfo.call(huihui, &quot;huihui&quot;, 28)) // 2 my name is: huihui, my age: 28console.log(angeli.sayInfo.imitateCall(huihui, &quot;pengpeng&quot;, 38)) // 3 &quot;my name is: pengpeng, my age: 38&quot; 5. 柯里化函数实现函数柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。 1234567891011121314151617function add() &#123; var _args = Array.prototype.slice.call(arguments) // 这个东西的作用就是利用闭包函数的特性把每次执行之后的参数者保存好，再依次放入数组中 var _adder = function () &#123; _args.push(...arguments); return _adder; &#125; // 在 js 中，每次打印的时候，都会调用 toString 函数，所以，重写这里的 toSting 等函数执行完就会进行打印的时候， 就会调用里边的求和函数 // reduce 方法的参数为函数，且不可以少； array.reduce(function(total, currentValue, currentIndex, arr), initialValue) _adder.toString = () =&gt; _args.reduce((total, num) =&gt; total + num) // 这个 add 函数返回的是一个函数，这点很重要，因为 add() 后面还其它的(), 这个意思就是执行函数的意思 return _adder;&#125;add(1, 2, 3)(4)(5) 6. 如何让 (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) 的值为 true&#x3D;&#x3D; 运算符会进行隐式转换 Object &#x3D;&#x3D;操作符会尝试通过方法valueOf和toString将对象转换为其原始值（一个字符串或数字类型的值）。 123456const a = &#123; i: 1, // toString: () =&gt; a.i ++, valueOf: () =&gt; a.i ++,&#125;a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 // true Array对于数组对象，toString 方法返回一个字符串，该字符串由数组中的每个元素的 toString() 返回值调用 join() 方法连接（由逗号隔开）组成。 123const a = [1, 2, 3]a.join = a.shifta == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 // true SymbolSymbol对象被转为原始类型的值时，会调用 toPrimitive 方法，返回该对象对应的原始类型值 1234let a = &#123; [Symbol.toPrimitive]: (i =&gt; () =&gt; i++)(1)&#125;a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 // true Proxy利用数据支持 Proxy&#x2F;Object.definedProperty 1234567let a = new Proxy(&#123;&#125;, &#123; i: 1, get: function() &#123; return () =&gt; this.i++ &#125;&#125;)a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 // true 7. 什么是 BFC ？ BFC 的布局规则是什么？如何创建 BFC ？Box 是 CSS 布局的对象和基本单位，页面是由若干个Box组成的。 元素的类型 和 display 属性，决定了这个 Box 的类型。不同类型的 Box 会参与不同的 Formatting Context。 Formatting Context 是页面的一块渲染区域，并且有一套渲染规则，决定了其子元素将如何定位，以及和其它元素的关系和相互作用。 Formatting Context 有 BFC (Block formatting context)，IFC (Inline formatting context)，FFC (Flex formatting context) 和 GFC (Grid formatting context)。FFC 和 GFC 为 CC3 中新增。 BFC 布局规则 BFC内，盒子依次垂直排列。 BFC内，两个盒子的垂直距离由 margin 属性决定。属于同一个BFC的两个相邻Box的margin会发生重叠【符合合并原则的margin合并后是使用大的margin】 BFC内，每个盒子的左外边缘接触内部盒子的左边缘（对于从右到左的格式，右边缘接触）。即使在存在浮动的情况下也是如此。除非创建新的BFC。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算。 怎样建仓 BFC 根元素 浮动元素（float 属性不为 none） position 为 absolute 或 fixed overflow 不为 visible 的块元素 display 为 inline-block, table-cell, table-caption BFC 的应用 防止 margin 重叠 (同一个BFC内的两个两个相邻Box的 margin 会发生重叠，触发生成两个BFC，即不会重叠) 清除内部浮动 (创建一个新的 BFC，因为根据 BFC 的规则，计算 BFC 的高度时，浮动元素也参与计算) 自适应多栏布局 (BFC的区域不会与float box重叠。因此，可以触发生成一个新的BFC) 8. 异步加载JS脚本的方式有哪些 &lt;script&gt; 标签中增加 async(html5) 或者 defer(html4) 属性,脚本就会异步加载 defer 和 async 的区别： defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），在window.onload 之前执行； async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。 如果有多个 defer 脚本，会按照它们在页面出现的顺序加载 多个 async 脚本不能保证加载顺序 动态创建 script 标签 动态创建的 script ，设置 src 并不会开始下载，而是要添加到文档中，JS文件才会开始下载。 XHR 异步加载JS 9. ES5有几种方式可以实现继承？分别有哪些优缺点？1. 原型链继承 原型链实现继承的思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。 原型链的基本概念：当一个原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个指向另一个原型的指针。同时，另一个原型中也包含着一个指向另一个构造函数的指针。如果另一个原型是另一个类型的实例，此时实例和原型就构成了原型链 123456789101112131415161718192021function SuperType () &#123; this.citys = [&#x27;北京&#x27;, &#x27;上海&#x27;, &#x27;深圳&#x27;];&#125;function SubType () &#123; this.name = &#x27;sub&#x27;;&#125;SubType.prototype = new SuperType();var instance1 = new SubType();instance1.citys.push(&#x27;阿斯加德&#x27;); // instance1.citys = [&#x27;阿斯加德&#x27;];console.log(instance1.citys) // [&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;, &quot;阿斯加德&quot;]var instance2 = new SubType();console.log(instance2.citys) // [&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;, &quot;阿斯加德&quot;] 原型链继承存在的问题： 包含引用类型的原型属性会被所有实例共享，这会导致对一个实例的修改会影响到另一个实例。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。原先的实例属性就变成了现在的原型属性 在创建了类型的实例时，不能向超类型的构造函数中传递参数 上边代码中， 当 instance1.citys = [&#39;阿斯加德&#39;]; 时会有一个完全不同的效果， 查看详情： js 原型链继承问题拓展 2. 借用构造函数继承 在子类型构造函数的内容调用超类型构造函数。 函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法可以在新创建的对象上执行构造函数 123456789101112function SuperType(name) &#123; this.name = name;&#125;function SubType() &#123; SuperType.call(this, &#x27;ahui&#x27;); this.age = 18;&#125;var instance = new SubType()console.log(instance.name, instance.age); // ahui 18 优点： 可以向超类传递参数 解决了原型中包含引用类型值被所有实例共享的问题 缺点： 方法都在构造函数中定义，函数复用无从谈起，另外超类型原型中定义的方法对于子类型而言都是不可见的。 3. 组合继承（原型链 + 借用构造函数） 使用原型链实现对原型属性的方法的继承，通过借用构造函数来实现对实例属性的继承，既通过在原型上定义方法来实现了函数复用，又保证了每个实例都有自己的属性。 面向对象实例属性和原型属性判别方法 hasOwnProperty(); 如果为true就是原型属性 否则就是实例属性。 123456789101112131415161718192021222324252627282930313233function SuperType(name) &#123; this.name = name; this.colors = [&#x27;pink&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];&#125;// 给超类型添加一个实例属性SuperType.prototype.sayName = function () &#123; console.log(this.name)&#125;// 通过借用构造函数继承实例属性function SubType(name, age) &#123; SuperType.call(this, name); this.age = age&#125;// 通过原型链继承原型属性SubType.prototype = new SuperType();SubType.prototype.sayAge = function () &#123; console.log(this.age)&#125;var instance1 = new SubType(&quot;ahui&quot;, 18)instance1.colors.push(&#x27;yellow&#x27;)instance1.sayAge() // 18console.log(instance1.colors) // [&quot;pink&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;]var instance2 = new SubType(&quot;angelee&quot;, 28)instance2.sayAge() // 28console.log(instance2.colors) // [&quot;pink&quot;, &quot;blue&quot;, &quot;green&quot;]// colors 是实例属性，通过借用构造函数实现的继承， 所以instance2不会受影响 缺点： 无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。 优点： 可以向超类传递参数 每个实例都有自己的属性 实现函数复用 原型式继承 非常简单的一种继承方式：通过Object.create()方法实现原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象(可以覆盖原型对象上的同名属性)，在传入一个参数的情况下， Object.create() 和 object() 方法的行为相同。 12345678910111213var person = &#123; name: &quot;ahui&quot;, citys: [&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;]&#125;var person1 = Object.create(person);person1.name = &quot;angeli&quot;;person1.citys.push(&#x27;阿斯加德&#x27;)console.log(person1.citys) // [&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;, &quot;阿斯加德&quot;]var person2 = Object.create(person);person2.name = &quot;penghui&quot;console.log(person2.citys) // [&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;, &quot;阿斯加德&quot;] 在没有必要创建构造函数，仅让一个对象与另一个对象保持相似的情况下，原型式继承是可以胜任的。 缺点： 同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。 寄生式继承 寄生式继承是与原型式继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部已某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。 123456789101112131415function createAnotherObject(original) &#123; var clone = Object.create(original); clone.sayHi = function () &#123; console.log(&quot;hello&quot;); &#125; return clone;&#125;var person = &#123; name: &quot;ahui&quot;&#125;var person2 = createAnotherObject(person)person2.sayHi() // hello 寄生组合式继承 所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。基本思路： 不必为了指定子类型的原型而调用超类型的构造函数，我们需要的仅是超类型原型的一个副本，本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型 寄生组合式继承的基本模式如下所示： 123456789101112131415161718function inheritPrototype(subType, superType) &#123; var prototype = Object.create(subperType.prototype); // 创建对象 prototype.constructor = subType; // 增强对象 subType.prototype = prototype;&#125;function SuperType(name) &#123; this.name = name; this.citys = [&quot;北京&quot;];&#125;function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;SubType.prototype = new SuperType();inheritPrototype(SubType, SuperType) 只调用了一次超类构造函数，效率更高。避免在 SuberType.prototype 上面创建不必要的、多余的属性，与其同时，原型链还能保持不变。 因此寄生组合继承是引用类型最理性的继承范式。 10. 隐藏页面中的某个元素的方法有哪些？完全隐藏： 元素从渲染树中消失，不占据空间。视觉上的隐藏：屏幕中不可见，占据空间。语义上的隐藏：读屏软件不可见，但正常占据空间。 完全隐藏： display: none; hidden: &lt;div hidden&gt;&lt;/div&gt; 视觉上的隐藏： postion transform width, height opacity visibility z-index clip-path: clip-path: polygon(0 0, 0 0, 0 0, 0 0） 语义上的隐藏aria-hidden: &lt;div aria-hidden = &quot;true&quot;&gt;&lt;/div&gt; 11. let、const、var 的区别有哪些？ 声明方式 变量提升 暂时性死区 重复声明 块作用域有效 var 会 不存在 允许 不是 let 不会 存在 不允许 是 Const 不会 存在 不允许 是 这里有一个非常重要的点即是：在JS中，复杂数据类型，存储在栈中的是堆内存的地址，存在栈中的这个地址是不变的，但是存在堆中的值是可以变得。 12. 说一说你对JS执行上下文栈和作用域链的理解执行上下文 执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。分为全局执行上下文 跟 函数执行上下文 作用域 作用域负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。 作用域有两种工作模型：词法作用域和动态作用域，JS采用的是词法作用域工作模型，词法作用域意味着作用域是由书写代码时变量和函数声明的位置决定的。 作用域分为： 全局作用域 函数作用域 块级作用域 JS执行上下文栈（执行栈） 执行栈，也叫做调用栈，具有 LIFO (后进先出) 结构，用于存储在代码执行期间创建的所有执行上下文。 规则： 首次运行JavaScript代码的时候,会创建一个全局执行的上下文并Push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push当前执行栈的栈顶。当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文的控制权将移动到当前执行栈的下一个执行上下文。 作用域链 作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。 13. 防抖函数的作用是什么？请实现一个防抖函数 防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次(理论上不会被调用，因为触了间隔一直小于wait， 这里的一次应该是触发停止的时候)，而节流的 情况会每隔一定时间（参数wait）调用函数。 函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时，事件处理函数不执行。 12345678910111213141516// 防抖function debounce(fn, wait) &#123; var timeout = null; return function() &#123; if(timeout !== null)&#123; clearTimeout(timeout); &#125; timeout = setTimeout(fn, wait); &#125;&#125;// 处理函数function handle() &#123; console.log(Math.random());&#125;// 滚动事件window.addEventListener(&#x27;scroll&#x27;, debounce(handle, 1000)); 这里的现象是如果你鼠标一直在滚动，那么处理函数就一直不执行，滚动停止1秒后执行。当持续触发scroll事件时，事件处理函数handle只在停止滚动1000毫秒之后才会调用一次，也就是说在持续触发scroll事件的过程中，事件处理函数handle一直没有执行。 14. 节流函数的作用是什么？有哪些应用场景，请实现一个节流函数函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。 节流函数的作用是规定一个单位时间，在这个单位时间内最多只能触发一次函数执行，如果这个单位时间内多次触发函数，只能有一次生效。 123456789101112131415161718// 节流throttle代码（定时器）：var throttle = function(func, delay) &#123; var timer = null; return function() &#123; var context = this; var args = arguments; if (!timer) &#123; timer = setTimeout(function() &#123; func.apply(context, args); timer = null; &#125;, delay); &#125; &#125;&#125;function handle() &#123; console.log(Math.random());&#125;window.addEventListener(&#x27;scroll&#x27;, throttle(handle, 1000)); 区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。 15. 什么是闭包？闭包的作用是什么？16. 实现 Promise.all 方法闭包的定义 《JavaScript高级程序设计》: 闭包是指有权访问另一个函数作用域中的变量的函数 《JavaScript权威指南》： 从技术的角度讲，所有的JavaScript函数都是闭包：它们都是对象，它们都关联到作用域链。 《你不知道的JavaScript》 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 17. 请实现一个 flattenDeep 函数，把嵌套的数组扁平化18. 请实现一个 uniq 函数，实现数组去重19. 可迭代对象有哪些特点20. JSONP 的原理是什么？参考地址： 原文地址 js 基本类型与引用类型的区别 一篇文章彻底说清JS的深拷贝&#x2F;浅拷贝 Object.assign 是浅拷贝还是深拷贝 详解JS函数柯里化 如何让 (a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3) 的值为true？ 关于 Proxy","categories":[{"name":"前端进阶","slug":"前端进阶","permalink":"http://didiorg.com/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"web","slug":"web","permalink":"http://didiorg.com/tags/web/"}]},{"title":"js Promise / Generator / await async","slug":"js-promise-await-async","date":"2020-03-03T15:02:31.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/464566509/","link":"","permalink":"http://didiorg.com/464566509/","excerpt":"Promise 是用来解决函数回调嵌套的， async、await 是用来解决逻辑上的函数依赖的。","text":"Promise 是用来解决函数回调嵌套的， async、await 是用来解决逻辑上的函数依赖的。 Promise是一个有状态的对象，用来规范回调函数，内容是一个function(function Promise() &#123; [native code] &#125;)，内部接收一个function，参数为resolve，reject，用于处理耗时操作的等待。 12345678910111213let promise = new Promise(function(resolve,reject)&#123; if (condition)&#123; resolve(...); &#125; else &#123; reject(...); &#125;&#125;);promise.then((result) =&gt; &#123;&#125;).catch((err) =&gt;&#123;&#125;) 三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败） 处理成功，调用resolve方法，状态会从 pending 变成 fulfilled处理失败，调用reject方法，状态会从 pending 变成 rejected一旦状态改变，就不会再变，任何时候都可以得到这个结果 一般注意几点 .then 可以无限链, 因为每一个 .then 都是返回一个 promise 对象 当 .then 有第二个参数的时候，就算遇到报错，后边 .catch 里边的内容不会再执行 .then 里边如果有 return 一个新 Promise 的话，后面的 .then 是新 Promise 的返回结果， 看一下下边代码 123456789101112131415161718192021222324new Promise((resolve, reject) =&gt; &#123; console.log(1); setTimeout(() =&gt; &#123; console.log(2); &#125;); resolve(2);&#125;) .then((res) =&gt; &#123; console.log(3, res); // 2 return 3; &#125;) .then((res) =&gt; &#123; console.log(4, res); // 3 return new Promise((resolve, reject) =&gt; &#123; console.log(4); resolve(4); &#125;).then((res) =&gt; &#123; console.log(5, res); // 4 return 5; &#125;); &#125;) .then((res) =&gt; &#123; console.log(6, res); // 5 &#125;); Generator 函数 Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。 1234567function* helloWorldGenerator() &#123; yield &#x27;hello&#x27;; yield &#x27;world&#x27;; return &#x27;ending&#x27;;&#125;var hw = helloWorldGenerator(); 然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。 下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。 1234567891011hw.next()// &#123; value: &#x27;hello&#x27;, done: false &#125;hw.next()// &#123; value: &#x27;world&#x27;, done: false &#125;hw.next()// &#123; value: &#x27;ending&#x27;, done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已 比 Generator 的好处 内置执行器 更好的语义 更广的适用性 返回值是 Promise 123456789async function getStockPriceByName(name) &#123; const symbol = await getStockSymbol(name); const stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName(&#x27;goog&#x27;).then(function (result) &#123; console.log(result);&#125;);","categories":[],"tags":[]},{"title":"nginx 常用配置","slug":"nginx-常用配置","date":"2020-03-03T06:40:00.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/1508208186/","link":"","permalink":"http://didiorg.com/1508208186/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"浏览器 地址栏回车 性能优化","slug":"浏览器-地址栏回车+性能优化","date":"2020-03-02T11:31:18.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/3152193188/","link":"","permalink":"http://didiorg.com/3152193188/","excerpt":"Enter1. 输入地址比如： didiorg.com&#x2F;","text":"Enter1. 输入地址比如： didiorg.com&#x2F; 2. DNS（Domain Name System，）解析：浏览器查找域名的 IP 地址本地 hosts 文件 &#x3D;&gt; 本地 DNS 服务器 &#x3D;&gt; DNS 根服务器本地 DNS 服务器 &#x3D;&gt; com 域服务器本地 DNS 服务器 &#x3D;&gt; 域名解析服务器 这个过程很有意思，本地 DNS 服务器访问根服务器，当根胳没有的时候，并不是根服务器去访问 com 域服务器，这个时候，DNS 根服务器只会告诉 本地 DNS 服务器他没有， 叫他再去访问 com 域服务器。 更有意思的是， 当本地 DNS 服务器访问 com 域服务器的时候，com 域服务器也不会直接给 本地 DNS 服务器 一个 IP 地址， 而是告诉本地 DNS 服务器想要查找的那个域名的域名解析服务器的地址 然后， 本地 DNS 服务器通过刚才拿到的址， 再去访问域名解析服务器，从那里拿到 IP 地址。 3. 浏览器向服务器发 http 请求拿到 ip 后，浏览器会向服务器80端口发起 TCP 连接请求 TCP 连接： tcp连接全过程各种状态详解 第一次握手：客户端的应用进程主动打开，并向服务端发出请求报文段。其首部中：SYN&#x3D;1,seq&#x3D;x。第二次握手：服务器应用进程被动打开。若同意客户端的请求，则发回确认报文，其首部中：SYN&#x3D;1,ACK&#x3D;1,ack&#x3D;x+1,seq&#x3D;y。第三次握手：客户端收到确认报文之后，通知上层应用进程连接已建立，并向服务器发出确认报文，其首部：ACK&#x3D;1,ack&#x3D;y+1。当服务器收到客户端的确认报文之后，也通知其上层应用进程连接已建立。 连接成功之后, 浏览器就会发起请求: 请求方式一般可以分为 get 请求、post 请求， 可参考get&#x2F;post 请求的区别 一个请求一般包括三部分： 1. 请求方法URI协议&#x2F;版本 2. 请求头(Ruquest Header) 3. 请求正文： （比如: username&#x3D;ahui&amp;parsword&#x3D;ahui123456） 常见的请求头一般会能下边这些， 我们很常用的 浏览器缓存 也在这个里边可以设置 123456789Accept: Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Connection: keep-aliveHost: didiorg.comIf-Modified-Since: Mon, 02 Mar 2020 02:22:54 GMTIf-None-Match: W/&quot;5e5c6dfe-4377&quot;Referer: http://didiorg.com/web.htmlUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36 4. 服务器处理请求建立好联接之后，浏览器就会发请求，服务器就会开始处理浏览器发过来的请求 这里有一个很厉害的角色： nginx 参考：nginx 常用配置 一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。 此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。 通过Nginx的反向代理，我们到达了web服务器，服务端脚本处理我们的请求，访问我们的数据库，获取需要获取的内容等等 5. 服务器返回 http 响应 一个 http 响应也由3个部分组成： 状态行: 由协议版本(HTTP-Verson)、数字形式的状态代码(Status-Code)、相应的状态描述(Reason-Phrase CRLF) 例如： HTTP&#x2F;1.2 200 OK 响应头: 由关键字&#x2F;值对组成，每行一对，关键字和值用英文冒号”:”分隔 响应正文: 包含着我们需要的一些具体信息，比如cookie，html,image，后端返回的请求数据等等 状态码： 1xx：信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。 100 Continue 101 Switching Protocols 2xx：成功状态码，表示服务器已成功接收到请求并进行处理。 200 OK 表示客户端请求成功 204 No Content 成功，但不返回任何实体的主体部分 206 Partial Content 成功执行了一个范围（Range）请求 3xx：重定向状态码，表示服务器要求客户端重定向。 301 Moved Permanently 永久性重定向，响应报文的Location首部应该有该资源的新URL 302 Found 临时性重定向，响应报文的Location首部给出的URL用来临时定位资源 303 See Other 请求的资源存在着另一个URI，客户端应使用GET方法定向获取请求的资源 304 Not Modified 服务器内容没有更新，可以直接读取浏览器缓存 307 Temporary Redirect 临时重定向。与302 Found含义一样。302禁止POST变换为GET，但实际使用时并不一定，307则更多浏览器可能 循这一标准，但也依赖于浏览器具体实现 4xx：客户端错误状态码，表示客户端的请求有非法内容。 400 Bad Request 表示客户端请求有语法错误，不能被服务器所理解 401 Unauthonzed 表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用 403 Forbidden 表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因 404 Not Found 请求的资源不存在，例如，输入了错误的URL 5xx：服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。 500 Internel Server Error 表示服务器发生不可预期的错误，导致无法完成客户端的请求 503 Service Unavailable 表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常 6. 浏览器收到服务器返回的资源后开始渲染 HTML解析html以构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树 浏览器在解析html文件时，会”自上而下“加载，并在加载过程中进行解析渲染。在解析过程中，如果遇到请求外部资源时，如图片、外链的CSS、iconfont等，请求过程是异步的，并不会影响html文档进行加载。 解析过程中，浏览器首先会解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。 DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。 当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。因为JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。所以我明平时的代码中，js是放在html文档末尾的。 JS的解析是由浏览器中的JS解析引擎完成的，比如谷歌的是V8。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。 JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。 7. 浏览器发送请求获取嵌入在 html 中的资源，如果图片，音频，css， js 等上边我们看了浏览器所干的事情， 然后我们再看一下对他的一些优化： 性能优化一般网站优化都是优化后台，如接口的响应时间、SQL优化、后台代码性能优化、服务器优化等。高并发情况下，对前端web优化也是非常重要的。下面说说几种常见的优化措施。 1、HTML CSS JS位置 一般需要将CSS放页面最上面，即HEAD部分，而将JS代码放页面底部。因为页面需要加载为CSS才进行渲染，而JS如果不是在页面加载之前就要执行就要放到页面最底部，以免在页面展示之前因JS过多加载而影响页面渲染速度。 2、引用文件位置 有一些插件需要引用到远程的图片、CSS、JS、图标等，如果远程的资源连接网速不佳，如国外的某些资源，会造成网页阻塞，同样也会造成页面展示问题，尽量能把引用远程的资源能本地化。 3、减少后台请求 每个请求都是耗费资源影响系统性能的，所以，能减少后台请求就减少。如，尽量的将同一个资源（图片、JS、CSS等）合并成一个文件，页面只要请求一次即可，这样就节省了很多http连接的开销及往返的时间损耗。 另外一方面，如果是关于抽奖、摇一摇、秒杀等功能，可以限制发往后台的频率，如前端操作10次才往后端发一次请求，这样从前端就做到了后台的流量控制，把流量控制到访问的最外层是最好的，尽量不要让请求落到底层。 4、压缩传输 http压缩可以对纯文本可以压缩至原内容的40%, 从而节省了60%的数据传输，GZIP是一种常用的压缩编码。因此，对文本类型的资源如CSS、JS、HTML启用GZIP压缩加速http传输速度。 5、减少cookie传输 cookie会包含在每次请求和响应中，如果cookie过多会影响http响应速度，所以高并发情况下尽量控制cookie的传输量，nginx对cookie传输默认是做了限制的。另外，像CSS、JS、图片等静态资源可以启用单独域名，禁用cookie对静态资源的传输，这样就能大大提高效率。 6、浏览器缓存 高并发情况下，可以将一些不怎么变动的东西缓存到浏览器cache中，或者一些活动内容可以提前将内容在客户端缓存起来，以免活动开始大量请求涌入服务器。 7、CDN 是一个静态内容分发网络，本质就是静态资源的缓存，可以将静态资源放到CDN上，这样，用户就能离自己最近的地方获取到资源，大大提高了用户访问速度。 8、反向代理 常用的反向代理nginx除了负载均衡功能，它也可以通过配置缓存功能来加速请求响应速度，当用户第一次访问的时候静态资源就可以被缓存到反向代理服务器上，这样其他用户的请求就能直接从反向代理服务器直接获取返回，这样也就直到了静态资源缓存的作用。","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://didiorg.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js","slug":"js","permalink":"http://didiorg.com/tags/js/"},{"name":"浏览器","slug":"浏览器","permalink":"http://didiorg.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"性能优化","slug":"性能优化","permalink":"http://didiorg.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"JS this","slug":"JS-this","date":"2020-03-01T13:18:26.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/3915840815/","link":"","permalink":"http://didiorg.com/3915840815/","excerpt":"有关于this ，我们说得最多的一句话就是谁调用，指向谁；也就是 this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象","text":"有关于this ，我们说得最多的一句话就是谁调用，指向谁；也就是 this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象 其实， 在我们 JS 里边，要想真的理解 this ，只知道上边这一句话是完全不行的，我们可以从以下几个方面学习跟理解 this ： 从 this 绑定层面去理解：默认绑定，隐式绑定，显式绑定，new 绑定 从函数的运行环境层面去理解: this， 内存， 函数，环境变量 能过实际代码的上下文去理解 默认绑定先看一个例子： 12345678var name = &quot;global&quot;function foo () &#123; var name = &quot;foo&quot; console.log(this.name);&#125;foo(); // global 很显然， foo 函数执行的时候，所在的环境是 window, 所以 this.name 就是 window 的 name 属性 再看一个稍微复杂点的例子： 12345678910111213const name = &quot;global&quot;;function foo() &#123; console.log(this.name); // global foo.name = &quot;foo&quot; function sayname() &#123; console.log(this.name); // global &#125; sayname()&#125;foo() 上边第一个 this 很好理解，是 foo 在全局环境下被调用，所以是 global 而第二个 this，表面上看上去是在 foo 函数内部被执行，而且 foo.name 赋了新值 &#39;foo&#39;, 所以很容易就会认为第二个 this 会打印 foo， 其实不然； sayname 虽是在 foo 函数里边被执行，但并非是被 foo 函数调用，所以，调用 sayname 的还是 window; 可以参考下边代码进行理解: 12345678910111213const name = &quot;global&quot;;function foo() &#123; console.log(this.name); // global foo.name = &quot;foo&quot; foo.sayname = function () &#123; console.log(this.name); // foo &#125; foo.sayname(); // 这里的 sayname 函数才是被 foo 调用的，所以才会打印 foo&#125;foo() 这就是默认绑定规则,它是 javascript 中最常见的一种函数调用模式，this 的绑定规则也是四种绑定规则中最简单的一种，就是绑定在全局作用域上。 隐式绑定先看例子： 1234567891011121314151617function sayname() &#123; console.log(this.name);&#125;const ahui = &#123; name: &quot;ahui&quot;, sayname: sayname,&#125;const angeli = &#123; name: &quot;angeli&quot;, sayname: sayname,&#125;ahui.sayname(); // ahuiangeli.sayname(); // angeli 这就是隐式绑定，不难理解; 回到我们文章的第一句话，谁调用，指向谁，这里就分别是 ahui angeli 调用了 sayname 专业一点的说法就是上下文对象，当给函数指定了这个上下文对象时，函数内部的 this 自然指向了这个上下文对象 在上边例子的基础上，我们再看一个稍微复杂点的例子： 123456789101112131415function sayname() &#123; console.log(this.name);&#125;const name = &quot;global&quot;;const ahui = &#123; name: &quot;ahui&quot;, sayname: sayname,&#125;ahui.sayname(); // ahuiconst ahuisayname = ahui.sayname;ahuisayname(); // global 这里的 ahui.sayname() 很好理解，肯定会打印 ahui ， 但是，当我们把 ahui.sayname 赋给一个新的变量之后， 为啥就变了呢 ？ 这就是常见的隐式绑定时丢失上下文 让我们来分析一下上边这个赋值语句：由于在 javascript 中，函数是对象，对象之间是引用传递，而不是值传递。 所以这个赋值语句可以理解为 ahuisayname = ahui.sayname = sayname, 也就是 ahuisayname = sayname , ahui.sayname 只起了一个桥梁的作用, ahuisayname 最终引用的就是 sayname 函数的地址，而与 ahui 这个对象没有关系了。最终执行 ahuisayname 这个函数，中不过是简单的执行 sayname 这个函数，输出 &#39;global&#39;。 这里的详细分析，可以看一下这篇文章： JavaScript 的 this 原理 显示绑定js中提示显示绑定的方法有3个 call apply bind call apply 用法基本相似，就是给函数绑定一个执行上下文，且是显式绑定的。因此，函数内的this自然而然的绑定在了 call 或者 apply 所调用的对象上面。 apply(obj,[arg1,arg2,arg3,...] 被调用函数的参数以数组的形式给出call(obj,arg1,arg2,arg3,...) 被调用函数的参数依次给出 1234567891011121314151617// 带参数function count(num1, num2) &#123; console.log(this.a * num1 + num2)&#125;var obj1 = &#123; a: 2&#125;var obj2 = &#123; a: 3&#125;count.call(obj1, 1, 2) // 4count.apply(obj1, [1, 2]) // 4count.call(obj2, 1, 2) // 5count.apply(obj2, [1, 2]) // 5 bind 方法只是返回了一个新的函数，这个函数内的 this 指定了执行上下文，而返回这个新函数可以接受参数 1234567891011121314151617181920// 带参数function count(num1, num2) &#123; console.log(this.a * num1 + num2)&#125;var obj1 = &#123; a: 2&#125;var bound1 = count.bind(obj1) // 未指定参数bound1(1, 2) // 4var bound2 = count.bind(obj1, 1) // 指定了一个参数bound2(2) // 4 var bound3 = count.bind(obj1, 1, 2) // 指定了两个参数bound3() //4var bound4 = count.bind(obj1, 1, 2, 3) // 指定了多余的参数,多余的参数会被忽略bound4() // 4 new 绑定最后要讲的一种 this 绑定规则，是指通过 new 操作符调用构造函数时发生的 this 绑定。首先要明确一点的是，在 javascript 中并没有其他语言那样的类的概念。构造函数也仅仅是普通的函数而已，只不过构造函数的函数名以大写字母开头，也只不过它可以通过 new 操作符调用而已. 123456789101112function Person(name,age) &#123; this.name = name this.age = age console.log(&quot;我也只不过是个普通函数&quot;)&#125;Person(&quot;ahui&quot;,18) // &quot;我也只不过是个普通函数&quot;console.log(name) // &quot;ahui&quot;console.log(age) // 18var zxt = new Person(&quot;angeli&quot;,22) // &quot;我也只不过是个普通函数&quot;console.log(zxt.name) // &quot;angeli&quot;console.log(zxt.age) // 22 上面这个例子中，首先定义了一个 Person 函数，既可以普通调用，也可以以构造函数的形式的调用。 当普通调用时，则按照正常的函数执行，输出一个字符串。 如果是通过一个 new 操作符,则构造了一个新的对象。 那么，接下来我们再看看两种调用方式， this 分别绑定在了何处首先普通调用时，前面已经介绍过，此时应用默认绑定规则，this 绑定在了全局对象上，此时全局对象上会分别增加 name 和 age 两个属性。当通过 new 操作符调用时，函数会返回一个对象，从输出结果上来看 this 对象绑定在了这个返回的对象上。 因此，所谓的 new 绑定是指通过 new 操作符来调用函数时，会产生一个新对象，并且会把构造函数内的 this 绑定到这个对象上。 事实上，在javascript中，使用 new 来调用函数，会自动执行下面的操作。详情可看这里： new 一个对象的过程 创建一个全新的对象 这个新对象会被执行原型连接 这个新对象会绑定到函数调用的this 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象 四种绑定的优先级上面讲述了javascript中四种this绑定规则，这四种绑定规则基本上涵盖了所有函数调用情况。但是如果同时应用了这四种规则中的两种甚至更多，又该是怎么样的一个情况，或者说这四种绑定的优先级顺序又是怎么样的。 首先，很容易理解，默认绑定的优先级是最低的。这是因为只有在无法应用其他this绑定规则的情况下，才会调用默认绑定。那隐式绑定和显式绑定呢？还是上代码吧，代码可从来不会说谎。 1234567891011121314function speak() &#123; console.log(this.name)&#125;var obj1 = &#123; name: &#x27;obj1&#x27;, speak: speak&#125;var obj2 = &#123; name: &#x27;obj2&#x27;&#125;obj1.speak() // obj1 (1)obj1.speak.call(obj2) // obj2 (2) 所以在上面代码中，执行了obj1.speak(),speak函数内部的this指向了obj1，因此(1)处代码输出的当然就是obj1，但是当显式绑定了speak函数内的this到obj2上，输出结果就变成了obj2，所有从这个结果可以看出显式绑定的优先级是要高于隐式绑定的。 事实上我们可以这么理解obj1.speak.call(obj2)这行代码，obj1.speak只是间接获得了speak函数的引用，这就有点像前面所说的隐式绑定丢失了上下文。 好，既然显式绑定的优先级要高于隐式绑定，那么接下来再来比较一下new 绑定和显式绑定。 1234567891011121314function foo(something) &#123; this.a = something&#125;var obj1 = &#123;&#125;var bar = foo.bind(obj1) // 返回一个新函数bar，这个新函数内的this指向了obj1 (1)bar(2) // this绑定在了Obj1上，所以obj1.a === 2console.log(obj1.a)var baz = new bar(3) // 调用new 操作符后，bar函数的this指向了返回的新实例baz (2)console.log(obj1.a)console.log(baz.a) 我们可以看到，在(1)处，bar函数内部的this原本指向的是obj1，但是在(2)处，由于经过了new操作符调用，bar函数内部的this却重新指向了返回的实例，这就可以说明new 绑定的优先级是要高于显式绑定的。 至此，四种绑定规则的优先级排序就已经得出了,分别是 new 绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定 箭头函数中的this绑定箭头函数是ES6里一个重要的特性。 箭头函数的 this 是根据外层的（函数或者全局）作用域来决定的。函数体内的 this 对象指的是定义时所在的对象，而不是之前介绍的调用时绑定的对象。举一个例子 12345678910var a = 1var foo = () =&gt; &#123; console.log(this.a) // 定义在全局对象中，因此this绑定在全局作用域&#125;var obj = &#123; a: 2&#125;foo() // 1 ,在全局对象中调用foo.call(obj) // 1,显示绑定，由obj对象来调用，但根本不影响结果 从上面这个例子看出，箭头函数的 this 强制性的绑定在了箭头函数定义时所在的作用域，而且无法通过显示绑定，如 apply,call 方法来修改。 再来看下面这个例子 1234567891011121314151617181920212223242526272829303132// 定义一个构造函数function Person(name,age) &#123; this.name = name this.age = age this.speak = function ()&#123; console.log(this.name) // 普通函数（非箭头函数),this绑定在调用时的作用域 &#125; this.bornYear = () =&gt; &#123; // 本文写于2020年，因此new Date().getFullYear()得到的是2020 // 箭头函数，this绑定在实例内部 console.log(new Date().getFullYear() - this.age) &#125;&#125;var ahui = new Person(&quot;ahui&quot;,28)ahui.speak() // &quot;ahui&quot;ahui.bornYear() // 1992// 到这里应该大家应该都没什么问题var angeli = &#123; name: &quot;angeli&quot;, age: 18 // 永远18岁&#125;ahui.speak.call(angeli)// &quot;angeli&quot; this绑定的是angeli这个对象ahui.bornYear.call(angeli)// 1992 而不是 2002,这是因为this永远绑定的是ahui这个实例 因此 ES6 的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this ，具体来说就是，箭头函数会继承 外层函数调用的 this 绑定 ，而无论外层函数的 this 绑定到哪里。 小结以上就是javascript中所有this绑定的情况，在es6之前，前面所说的四种绑定规则可以涵盖任何的函数调用情况，es6标准实施以后，对于函数的扩展新增了箭头函数，与之前不同的是，箭头函数的作用域位于箭头函数定义时所在的作用域。 而对于之前的四种绑定规则来说，掌握每种规则的调用条件就能很好的理解this到底是绑定在了哪个作用域。 原文地址： JavaScript中this绑定详解","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://didiorg.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js","slug":"js","permalink":"http://didiorg.com/tags/js/"},{"name":"web","slug":"web","permalink":"http://didiorg.com/tags/web/"},{"name":"this","slug":"this","permalink":"http://didiorg.com/tags/this/"}]},{"title":"JS typeof instanceof 你应该知道这么多","slug":"JS-typeof-instanceof-底层原理实现","date":"2020-03-01T05:05:34.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/3369490582/","link":"","permalink":"http://didiorg.com/3369490582/","excerpt":"typeof主要是用来判断一个变量的类型","text":"typeof主要是用来判断一个变量的类型 几个特殊的情况记一下： 123456typeof null // objecttypeof &#123;&#125; // objecttypeof [] // objecttypeof Object // functiontypeof Function // functiontypeof undefined // undefined 看到上边 typeof Object 的结果是 function 这里其实因为 Object 是一个构造函数， 而不是一个真正的对象， 只有实例化之后才会给出 object的结果 可以看一下下边代码： 1234console.log(typeof Object); // functionlet ahui = new Object();console.log(typeof ahui); // object 再看到上边： typeof null typeof &#123;&#125; typeof [] 结果都是 object， 很显然， 我们是不能通过 typeof 来判断一个对象的具体类型的，通常我们会通过 Object.prototype.toString的方法来实现 1234567891011121314151617Object.prototype.toString.call(1) // &quot;[object Number]&quot;Object.prototype.toString.call(&#x27;hi&#x27;) // &quot;[object String]&quot;Object.prototype.toString.call(&#123;a:&#x27;hi&#x27;&#125;) // &quot;[object Object]&quot;Object.prototype.toString.call([1,&#x27;a&#x27;]) // &quot;[object Array]&quot;Object.prototype.toString.call(true) // &quot;[object Boolean]&quot;Object.prototype.toString.call(() =&gt; &#123;&#125;) // &quot;[object Function]&quot;Object.prototype.toString.call(null) // &quot;[object Null]&quot;Object.prototype.toString.call(undefined) // &quot;[object Undefined]&quot;Object.prototype.toString.call(Symbol(1)) // &quot;[object Symbol]&quot; 到这里， 好像还没说到 typeof 的实现原理，其实很简单，通常情况下，我们只需要知道他的用法以及一些注意点就行： JS 要底层存储变量的时候， 会在变量的机器码的低位 1 ~ 3 位存储其类型信息 instanceof表示指定对象是否为某个构造函数的实例。比如下边代码： 12345678910111213141516const Person = function (name) &#123; this.name = name;&#125;const ahui = new Person(&#x27;ahui&#x27;);const angeli = &#123; name: &#x27;angele&#x27;&#125;// ahui 是通过 Person 实例出来的console.log(ahui instanceof Person); // true// 这个时候突然想起， 一个对象的__proto__ 指向该对象的构造函数的原型，如下：console.log(ahui.__proto__ === Person.prototype); // trueconsole.log(angeli instanceof Person); // false 当然，instanceof 也可以判断一个实例是否是其父类型或者祖先类型的实例 12345678const Person = function () &#123;&#125;const Programmer = function () &#123;&#125;Programmer.prototype = new Person()const ahui = new Programmer();console.log(ahui instanceof Programmer); // trueconsole.log(ahui instanceof Person); // true 再看几个有意思的例子： 123456789101112function Foo() &#123;&#125;console.log(Object instanceof Object) // trueconsole.log(Function instanceof Function) // trueconsole.log(Number instanceof Number); // false console.log(String instanceof String); // false console.log(Function instanceof Object) // trueconsole.log(Object instanceof Function) // trueconsole.log(Foo instanceof Foo) // falseconsole.log(Foo instanceof Object) // trueconsole.log(Foo instanceof Function) // true 看到上边的 instanceof 有没有感觉很有意思，下边让我们来讲一下为什么会这样： 先看一张图片 如果看这个图片表示看不懂的， 可以先看一下这篇文章： js 中__proto__和 prototype 的区别和关系 如果有同学对这张图表示怀疑的，就像我，可以先在控制台试一下下边的代码： 1234Object.__proto__ === Function.prototype; // trueFunction.__proto__ === Function.prototype; // trueFunction.prototype.__proto__ === Object.prototype; // trueconsole.log(Object.prototype.__proto__); // null 下边我们再来理解 Object instanceof Object 为 true 123456789101112// 为了方便表述， 首先区分左侧表达式跟右侧表达式ObjectL = Object, ObjectR = Object; // 下面根据规范逐步推演O = ObjectR.prototype = Object.prototype L = ObjectL.__proto__ = Function.prototype // 第一次判断O != L // 循环查找 L 是否还有 __proto__ L = Function.prototype.__proto__ = Object.prototype // 第二次判断O == L // 返回 true 同理， 我们可以通过上边那张 js 原型的关系图推算出 其它所有的 instanceof 自己手动实现 instanceof现在， 我们知道 instanceof 的原理了， 那么，自己手动去实现一个 instanceof 是很简单的 1234567891011121314151617181920212223function instanceof_myself(L, R) &#123; const O = R.prototype; L = L.__proto__; while(true) &#123; if (L === null) &#123; return false; &#125; if (L === O) &#123; return true; &#125; L = L.__proto__; &#125;&#125;// 测试一下const Person = function () &#123;&#125;const ahui = new Person();console.log(ahui instanceof Person) // trueconsole.log(instanceof_myself(ahui, Person)); //true 参考地址：浅谈 instanceof 和 typeof 的实现原理JavaScript instanceof 运算符深入剖析","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://didiorg.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js","slug":"js","permalink":"http://didiorg.com/tags/js/"},{"name":"web","slug":"web","permalink":"http://didiorg.com/tags/web/"},{"name":"浏览器","slug":"浏览器","permalink":"http://didiorg.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"JS 函数实参转换为数组","slug":"JS-函数实参转换为数组","date":"2020-02-29T12:49:38.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/1882318475/","link":"","permalink":"http://didiorg.com/1882318475/","excerpt":"实际参数在函数中我们可以使用 arguments 对象获得 （注：形参可通过 arguments.callee 获得），虽然 arguments 对象与数组形似，但仍不是真正意义上的数组。","text":"实际参数在函数中我们可以使用 arguments 对象获得 （注：形参可通过 arguments.callee 获得），虽然 arguments 对象与数组形似，但仍不是真正意义上的数组。 0: […arguments]这个方法其实是用来代替下边方法一的 一：通过 Array.prototype属性调用 slice 方法1const args = Array.prototype.slice.call(arguments) Array 本身是没有 slice 方法，它的方法在 Array.prototype中，而我们在调用 slice 方法的时候，如果在 Array 本身没有找到 slice 方法的话，会通过它的原型链往上查找。 二. 通过调用[]的slice方法1const args = [].sclice.call(arguments, 0) 注意这里是[]， 不是 Array,为什么呢？ 先看下边 12345typeof []; // objecttypeof Array; // Funcion[].__proto__ === Array.prototype; // true 从上面很清楚的知识 Array 是一个构造函数，而 [] 是 Array 的实例， 等价于 new Array(),因为实例的__proto__ 指向该实例的构造函数的prototype; 但是这里 [] === new Array // false 是 false， 因为对象是不能直接比较的 三. 通过遍历arguments,返回数组1234567function toArray()&#123; var args = []; for (var i = 1; i &lt; arguments.length; i++) &#123; args.push(arguments[i]); &#125; return args;&#125;","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://didiorg.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js","slug":"js","permalink":"http://didiorg.com/tags/js/"},{"name":"web","slug":"web","permalink":"http://didiorg.com/tags/web/"},{"name":"浏览器","slug":"浏览器","permalink":"http://didiorg.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"array","slug":"array","permalink":"http://didiorg.com/tags/array/"}]},{"title":"JS new 一个对象的过程","slug":"JS-new-一个对象的过程","date":"2020-02-29T11:36:50.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/3315289936/","link":"","permalink":"http://didiorg.com/3315289936/","excerpt":"首先让我回忆一下创建对象的三种方法","text":"首先让我回忆一下创建对象的三种方法 单休模式 1234567891011const Person = &#123; name: &quot;angelee&quot;, sayname: function() &#123; return this.name; &#125;&#125;let ahui = Object.create(Person);ahui.name = &quot;ahui&quot;console.log(ahui.sayname()) // ahui 构造函数 123456789const Person = function (name) &#123; this.name = name;&#125;Person.prototype.sayname = function () &#123; return this.name;&#125;let ahui = new Person(&quot;ahui&quot;);console.log(ahui.sayname()); // ahui ES6 class 123456789101112131415161718192021222324252627class Person &#123; constructor (name) &#123; this.name = name; &#125; sayname () &#123; return this.name; &#125;&#125;let ahui = new Person(&#x27;ahui&#x27;);console.log(ahui.sayname()); // ahui// 这里再回忆一下 class 的继承class Boy extends Person &#123; constructor (name, age) &#123; super(name) this.age = age &#125; sayage() &#123; return this.age &#125;&#125;let angelee = new Boy(&#x27;angelee&#x27;, 18);console.log(angelee.sayname()); // angeleeconsole.log(angelee.sayage()); // 18 我们发现， 创建对象的时候，除了单例是通过 Object.create()创建对象，其它都是通过 new 操作实现的。 那new 到底做了什么呢 ？ 让我们以下边这个为例详细分析一下 12345const Person = function (name) &#123; this.name = name;&#125;const ahui = new Person(&#x27;ahui&#x27;)console.log(ahui.name); // ahui 让我们试一下其它方法实现 console.log(ahui.name)也能正常输出 ahui 先创建一个空对象 1const ahui = new Object() 设置原型链，把 ahui 的__proto__成员指向 Person 函数对象的prototype成员对象 1ahui.__proto__ = Person.prototype 把Person中的this指向ahui 1const result = Person.call(ahui) 将初始化完毕的新对象地址，保存到等号左边的变量中。判断Person的返回值类型，如果是值类型，返回obj。如果是引用类型，就返回这个引用类型的对象 自己实现一个 new 方法第一种方法 123456789101112131415161718192021222324252627282930313233const Person = function (name) &#123; this.name = name;&#125;// 自己实现一个 new 方法function myNew() &#123; // 1. 新建一个空对象 var obj = new Object(); // shift() 方法从数组中删除第一个元素，并返回该元素的值 var Constructor = [].shift.call(arguments); // 2. 建立继承关系(二者之间的关系)也就是把新对象的__proto__指向构造函数的 prototype obj.__proto__ = Constructor.prototype; // 3. 改变 this 指向，并开始执行这个构造函数的内容 var ret = Constructor.apply(obj, arguments); // 4. 返回创建的对象： 看一下构造函数的返回值，是对象还是一个基本数据类型? return typeof ret === &#x27;object&#x27; ? ret : obj;&#125;const ahui = new Person(&#x27;ahui&#x27;);console.log(ahui.name); // ahuiconst angeli = myNew(Person, &#x27;angeli&#x27;)console.log(angeli); // angeliangeli.name = &#x27;angeli new&#x27;console.log(angeli.name); // angeli new 第二种方法 123456789101112131415161718192021222324// 通过分析原生的new方法可以看出，在new一个函数的时候，// 会返回一个func同时在这个func里面会返回一个对象Object，// 这个对象包含父类func的属性以及隐藏的__proto__function New(f) &#123; //返回一个func return function () &#123; console.log(arguments) // 新建一个对象， 并且把新对象的 __proto__ 指向构造函数的 prototype 属性 var o = &#123;&quot;__proto__&quot;: f.prototype&#125;; // 改变 this 指向, 并执行原来构造函数里边的内容 f.apply(o, arguments); // 继承父类的属性 return o; //返回一个Object &#125;&#125;const Person = function (name) &#123; this.name = name;&#125;const ahui = New(Person)(&#x27;ahui&#x27;)console.log(ahui.name) // ahui 自测一下 1234567891011121314151617181920212223function New(f) &#123; return function () &#123; let o = &#123; &quot;__proto__&quot;: f.prototype &#125; f.apply(o, arguments) return typeof o === &quot;object&quot; ? o : f &#125;&#125;const Person = function (name) &#123; this.name = name&#125;Person.prototype.sayname = function() &#123; return this.name&#125;const ahui = New(Person)(&#x27;ahui&#x27;)console.log(ahui.name) // ahuiahui.sayname() // ahui 关于 arguments 可以参考这篇文章： JS 函数实参转换为数组","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://didiorg.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js","slug":"js","permalink":"http://didiorg.com/tags/js/"},{"name":"web","slug":"web","permalink":"http://didiorg.com/tags/web/"},{"name":"浏览器","slug":"浏览器","permalink":"http://didiorg.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"JS prototype","slug":"JS-prototype","date":"2020-02-28T17:59:58.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/prototype/","link":"","permalink":"http://didiorg.com/prototype/","excerpt":"在典型的面向对象的语言中，如java，都存在类（class）的概念，类就是对象的模板，对象就是类的实例。但是在Javascript语言体系中，是不存在类（Class）的概念的，javascript中不是基于‘类的’，而是通过构造函数（constructor）和原型链（prototype chains）实现的。","text":"在典型的面向对象的语言中，如java，都存在类（class）的概念，类就是对象的模板，对象就是类的实例。但是在Javascript语言体系中，是不存在类（Class）的概念的，javascript中不是基于‘类的’，而是通过构造函数（constructor）和原型链（prototype chains）实现的。 在ES6中提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让原型对象的写法更加清晰、更像面向对象编程的语法而已。 构造函数(constructor)的简单介绍 所谓构造函数，就是提供了一个生成对象的模板并描述对象的基本结构的函数。一个构造函数，可以生成多个对象，每个对象都有相同的结构。总的来说，构造函数就是对象的模板，对象就是构造函数的实例。构造函数的特点有： a：构造函数的函数名首字母必须大写。 b：内部使用this对象，来指向将要生成的对象实例。 c：使用new操作符来调用构造函数，并返回对象实例。 看一个最简单的一个例子。 123456function Person(name) &#123; this.name = name;&#125;var boy = new Person(&#x27;Ahui&#x27;)console.log(boy.name); // Ahui 构造函数的缺点 所有的实例对象都可以继承构造函数中的属性和方法。但是，同一个对象实例之间，无法共享属性。 12345678910111213function Person(name, height) &#123; this.name = name; this.height = height; this.hobby = function() &#123; return &#x27;watching movies&#x27;; &#125;&#125;var boy = new Person(&#x27;keith&#x27;,180);var girl = new Person(&#x27;rascal&#x27;,168);console.log(boy.name); //&#x27;keith&#x27;console.log(girl.name); //&#x27;rascal&#x27;console.log(boy.hobby === girl.hobby); //false 上面代码中，一个构造函数Person生成了两个对象实例boy和girl，并且有两个属性和一个方法。但是，它们的hobby方法是不一样的。也就是说，每当你使用new来调用构造函数放回一个对象实例的时候，都会创建一个hobby方法。这既没有必要，又浪费资源，因为所有hobby方法都是统一的行为，完全可以被两个对象实例共享。 所以，构造函数的缺点就是： 同一个构造函数的对象实例之间无法共享属性或方法 prototype属性的作用 为了解决构造函数的对象实例之间无法共享属性的缺点，js提供了prototype属性。 js中每个数据类型都是对象（除了null和undefined），而每个对象都继承自另外一个对象，后者称为“原型”（prototype）对象，只有null除外，它没有自己的原型对象。 原型对象上的所有属性和方法，都会被对象实例所共享。 通过构造函数生成对象实例时，会将对象实例的原型指向构造函数的prototype属性。每一个构造函数都有一个prototype属性，这个属性就是对象实例的原型对象。 123456789101112131415function Person(name, height) &#123; this.name = name; this.height = height;&#125;Person.prototype.sayname = function() &#123; return this.name;&#125;var boy = new Person(&#x27;Ahui&#x27;, 183);var girl = new Person(&#x27;Ajiao&#x27;, 168);console.log(boy.sayname()); // Ahuiconsole.log(girl.sayname()); // Ajiaoconsole.log(boy.sayname === girl.sayname); // true 上面代码中，如果将hobby方法放在原型对象上，那么两个实例对象都共享着同一个方法。我希望大家都能理解的是，对于构造函数来说，prototype是作为构造函数的属性；对于对象实例来说，prototype是对象实例的原型对象。所以prototype即是属性，又是对象。 原型对象的属性不是对象实例的属性。对象实例的属性是继承自构造函数定义的属性，因为构造函数内部有一个this关键字来指向将要生成的对象实例。对象实例的属性，其实就是构造函数内部定义的属性。只要修改原型对象上的属性和方法，变动就会立刻体现在所有对象实例上。 上面代码中，当修改了原型对象的hobby方法之后，两个对象实例都发生了变化。这是因为对象实例其实是没有hobby方法，都是读取原型对象的hobby方法。也就是说，当某个对象实例没有该属性和方法时，就会到原型对象上去查找。如果实例对象自身有某个属性或方法，就不会去原型对象上查找。 12345678910111213141516function Person(name, height) &#123; this.name = name; this.height = height;&#125;Person.prototype.hobby = function() &#123; return &#x27;swimming&#x27;;&#125;var boy = new Person(&#x27;Ahui&#x27;, 183);var girl = new Person(&#x27;Ajiao&#x27;, 168);boy.hobby = function()&#123; return &#x27;play basketball&#x27;;&#125;console.log(boy.hobby()); //&#x27;play basketball&#x27;console.log(girl.hobby()); //&#x27;swimming&#x27;console.log(boy.hobby === girl.hobby); // false 上面代码中，boy对象实例的hobby方法修改时，就不会在继承原型对象上的hobby方法了。不过girl仍然会继承原型对象的方法。这个时候boy.hobby与girl.hobby就不相等了 总结一下： a：原型对象的作用，就是定义所有对象实例所共享的属性和方法。 b：prototype，对于构造函数来说，它是一个属性；对于对象实例来说，它是一个原型对象。 原型链（prototype chains） 对象的属性和方法，有可能是定义在自身，也有可能是定义在它的原型对象。由于原型对象本身对于对象实例来说也是对象，它也有自己的原型，所以形成了一条原型链（prototype chain）。比如，a对象是b对象的原型，b对象是c对象的原型，以此类推。所有一切的对象的原型顶端，都是Object.prototype，即Object构造函数的prototype属性指向的那个对象。 当然，Object.prototype对象也有自己的原型对象，那就是没有任何属性和方法的null对象，而null对象没有自己的原型。 123console.log(Object.getPrototypeOf(Object.prototype)); //nullconsole.log(Person.prototype.isPrototypeOf(boy)) //true 原型链（prototype chain）的特点有： a：读取对象的某个属性时，JavaScript引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，则返回undefined。 b：如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overiding）。 c：一级级向上在原型链寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。 看概念可能比较晦涩，我们来看一个例子。但是理解了概念真的很重要。 1234var arr = []console.log(arr.length; // 0console.log(arr.join()); //console.log(arr.valueOf()); // [] 上面代码中，定了一个数组arr，数组里面有三个元素。我们并没有给数组添加任何属性和方法，可是却在调用length，join()，valueOf()时，却不会报错。 length属性是继承自Array.prototype的，属于原型对象上的一个属性。join方法也是继承自Array.prototype的，属于原型对象上的一个方法。这两个方法是所有数组所共享的。当实例对象上没有这个length属性时，就会去原型对象查找。 valueOf方法是继承自Object.prototype的。首先，arr数组是没有valueOf方法的，所以就到原型对象Array.prototype查找。然后，发现Array.prototype对象上没有valueOf方法。最后，再到它的原型对象Object.prototype查找。 来看看Array.prototype对象和Object.prototype对象分别有什么属性和方法。 1234console.log(Object.getOwnPropertyNames(Array.prototype))//[&quot;length&quot;, &quot;toSource&quot;, &quot;toString&quot;, &quot;toLocaleString&quot;, &quot;join&quot;, &quot;reverse&quot;, &quot;sort&quot;, &quot;push&quot;, &quot;pop&quot;, &quot;shift&quot;, &quot;unshift&quot;, &quot;splice&quot;, &quot;concat&quot;, &quot;slice&quot;, &quot;lastIndexOf&quot;, &quot;indexOf&quot;, &quot;forEach&quot;, &quot;map&quot;, &quot;filter&quot;, &quot;reduce&quot;, &quot;reduceRight&quot;, &quot;some&quot;, &quot;every&quot;, &quot;find&quot;, &quot;findIndex&quot;, &quot;copyWithin&quot;, &quot;fill&quot;, &quot;entries&quot;, &quot;keys&quot;, &quot;values&quot;, &quot;includes&quot;, &quot;constructor&quot;, &quot;$set&quot;, &quot;$remove&quot;] console.log(Object.getOwnPropertyNames(Object.prototype)) // [&quot;toSource&quot;, &quot;toString&quot;, &quot;toLocaleString&quot;, &quot;valueOf&quot;, &quot;watch&quot;, &quot;unwatch&quot;, &quot;hasOwnProperty&quot;, &quot;isPrototypeOf&quot;, &quot;propertyIsEnumerable&quot;, &quot;__defineGetter__&quot;, &quot;__defineSetter__&quot;, &quot;__lookupGetter__&quot;, &quot;__lookupSetter__&quot;, &quot;__proto__&quot;, &quot;constructor&quot;] 我相信，大家看到这里，对prototype还是似懂非懂的。这很正常，毕竟是js中比较重要又比较抽象的概念,不可能那么快就掌握，再啃多几篇，说不定掌握其精髓。在某乎上，有一个活生生的实例，可能也是大家会遇到的问题。可以看看 js构造函数和原型对象。 constructor属性 prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。 要注意的是，prototype是构造函数的属性，而constructor则是构造函数的prototype属性所指向的那个对象，也就是原型对象的属性。注意不要混淆。 由于constructor属性是定义在原型（prototype）对象上面，意味着可以被所有实例对象继承。 1234function A() &#123;&#125;;var a = new A();console.log(a.constructor); //A()console.log(a.constructor === A.prototype.constructor);//true 上面代码中，a是构造函数A的实例对象，但是a自身没有contructor属性，该属性其实是读取原型链上面的A.prototype.constructor属性。 constructor属性的作用 a：分辨原型对象到底属于哪个构造函数 1234function A()&#123;&#125;;var a = new A();console.log(a.constructor === A) //trueconsole.log(a.constructor === Array) //false 上面代码表示，使用constructor属性，确定实例对象a的构造函数是A，而不是Array。 b：从实例新建另一个实例 1234function A() &#123;&#125;; var a = new A();var b = new a.constructor();console.log(b instanceof A); //true 上面代码中，a是构造函数A的实例对象，可以从a.constructor间接调用构造函数。 c：调用自身的构造函数成为可能 123A.prototype.hello = function() &#123;return new this.constructor();&#125; d：提供了一种从构造函数继承另外一种构造函数的模式 12345function Father() &#123;&#125;function Son() &#123; Son.height.constructor.call(this);&#125;Son.height = new Father(); 上面代码中，Father和Son都是构造函数，在Son内部的this上调用Father，就会形成Son继承Father的效果。 e：由于constructor属性是一种原型对象和构造函数的关系，所以在修改原型对象的时候，一定要注意constructor的指向问题。 解决方法有两种，要么将constructor属性指向原来的构造函数，要么只在原型对象上添加属性和方法，避免instanceof失真。 instanceof运算符 instanceof运算符返回一个布尔值，表示指定对象是否为某个构造函数的实例。 因为instanceof对整个原型链上的对象都有效，所以同一个实例对象，可能会对多个构造函数都返回true。 注意，instanceof对象只能用于复杂数据类型（数组，对象等），不能用于简单数据类型（布尔值，数字，字符串等）。 此外，null和undefined都不是对象，所以instanceof 总是返回false。 利用instanceof运算符，还可以巧妙地解决，调用构造函数时，忘了加new命令的问题。 上面代码中，使用了instanceof运算符来判断函数体内的this关键字是否指向构造函数Keith的实例，如果不是，就表明忘记加new命令，此时构造函数会返回一个对象实例，避免出现意想不到的结果。 原文出处&gt;&gt;&gt;","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://didiorg.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js","slug":"js","permalink":"http://didiorg.com/tags/js/"},{"name":"web","slug":"web","permalink":"http://didiorg.com/tags/web/"},{"name":"浏览器","slug":"浏览器","permalink":"http://didiorg.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"JS 数据类型你应该知道的可不止这些","slug":"JS-数据类型","date":"2020-02-28T10:26:44.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/1405041715/","link":"","permalink":"http://didiorg.com/1405041715/","excerpt":"基本数据类型string, number, boolean, null, undefined","text":"基本数据类型string, number, boolean, null, undefined 基本数据类型的变量是保存在栈内存中的，基本数据类型的值直接在栈内存中存储，值与值之间是独立存在的，修改一个变量不会影响其他的变量 当比较两个基本数据类型的值时，本质上是比较值 引用类型object 对象是保存在堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间，而变量保存的是对象的内存地址(对象的引用)，如果两个变量保存的是同一个对象引用，当修改其中一个变量修改属性时，另一个也会受到影响 当比较两个引用数据类型时，本质上是比较的对象的内存地址，如果两个对象的属性是一模一样的，但是地址不同，也会返回false。 数据结构中的栈和堆 栈 ：这是一种连续存储的数据结构，具有先进后出的性质。通常具有的操作有出栈、入栈（压栈）和取栈顶元素。想要读取栈中的某个元素，就必须将其之前所有的元素出栈才能完成。 堆：这是一种非连续的树形存储数据结构，每个节点都有一个值，整棵树是经过排序的。特点是根节点的值最小（或最大），且根节点的两个子树也是一个堆。常用来实现优先队列，存取随意。 内存中的栈区和堆区 栈内存：由程序自动向操作系统申请分配以及回收，速度快，使用方便，但程序员无法控制。若分配失败，则提示栈溢出错误。注意，const局部变量也储存在栈区内，栈区向地址减小的方向增长。 堆内存：程序员向操作系统申请一块内存，当系统收到程序的申请时，会遍历一个记录空闲内存地址的链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。分配的速度较慢，地址不连续，容易碎片化。此外，由程序员申请，同时也必须由程序员负责销毁，否则则导致内存泄露。 关于栈和堆的比喻 使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://didiorg.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js","slug":"js","permalink":"http://didiorg.com/tags/js/"},{"name":"web","slug":"web","permalink":"http://didiorg.com/tags/web/"},{"name":"浏览器","slug":"浏览器","permalink":"http://didiorg.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"JS dom元素位置相关的内容","slug":"JS-dom元素位置相关的内容","date":"2020-02-27T14:22:35.000Z","updated":"2022-08-02T02:39:10.648Z","comments":true,"path":"/880232555/","link":"","permalink":"http://didiorg.com/880232555/","excerpt":"offsetWidth: 返回元素的宽度（包括元素宽度 + 内边距 + 边框，不包括外边距）","text":"offsetWidth: 返回元素的宽度（包括元素宽度 + 内边距 + 边框，不包括外边距） offsetHeight: 返回元素的高度（包括元素高度 + 内边距 + 边框，不包括外边距） clientWidth: 返回元素的宽度（包括元素宽度 + 内边距，不包括边框和外边距） clientHeight: 返回元素的高度（包括元素高度 + 内边距，不包括边框和外边距） style.width: 返回元素的宽度（包括元素宽度，不包括内边距、边框和外边距） style.height: 返回元素的高度（包括元素高度，不包括内边距、边框和外边距） scrollWidth: 返回元素的宽度（包括元素宽度 + 内边距 + 溢出尺寸，不包括边框和外边距），无溢出的情况，与clientWidth相同 scrollHeigh: 返回元素的高度（包括元素高度 + 内边距 + 溢出尺寸，不包括边框和外边距），无溢出的情况，与clientHeight相同 style.width 返回的是字符串，如28px，offsetWidth返回的是数值28； style.width&#x2F;style.height与scrollWidth&#x2F;scrollHeight是可读写的属性，clientWidth&#x2F;clientHeight与offsetWidth&#x2F;offsetHeight是只读属性 style.width的值需要事先定义，否则取到的值为空。而且必须要定义在html里(内联样式)，如果定义在css里，style.height的值仍然为空，但元素偏移有效；而offsetWidth则仍能取到。 offsetTop: 返回元素的上外缘距离最近采用定位父元素内壁的距离，如果父元素中没有采用定位的，则是获取上外边缘距离文档内壁的距离。offsetLeft: 此属性和offsetTop的原理是一样的，只不过方位不同，这里就不多介绍了。 所谓的定位就是position属性值为relative、absolute或者fixed。返回值是一个整数，单位是像素。此属性是只读的。 scrollLeft: 此属性可以获取或者设置对象的最左边到对象在当前窗口显示的范围内的左边的距离，也就是元素被滚动条向左拉动的距离。scrollTop: 此属性可以获取或者设置对象的最顶部到对象在当前窗口显示的范围内的顶边的距离，也就是元素滚动条被向下拉动的距离。 返回值是一个整数，单位是像素。此属性是可读写的。 当鼠标事件发生时（不管是onclick，还是omousemove，onmouseover等） clientX: 鼠标相对于浏览器（这里说的是浏览器的有效区域）左上角x轴的坐标； 不随滚动条滚动而改变 clientY: 鼠标相对于浏览器（这里说的是浏览器的有效区域）左上角y轴的坐标； 不随滚动条滚动而改变 pageX: 鼠标相对于浏览器（这里说的是浏览器的有效区域）左上角x轴的坐标； 随滚动条滚动而改变 pageY: 鼠标相对于浏览器（这里说的是浏览器的有效区域）左上角y轴的坐标； 随滚动条滚动而改变 screenX: 鼠标相对于显示器屏幕左上角x轴的坐标 screenY: 鼠标相对于显示器屏幕左上角y轴的坐标 offsetX: 鼠标相对于事件源左上角X轴的坐标 offsetY: 鼠标相对于事件源左上角Y轴的坐标 相对于窗口的位置很多时候， 我们都要去获取一个元素相对于窗口的位置 12345678910111213141516//获取元素的纵坐标（相对于窗口）function getTop(e)&#123; var offset = e.offsetTop; if(e.offsetParent !== null) &#123; offset += getTop(e.offsetParent); &#125; return offset;&#125;//获取元素的横坐标（相对于窗口）function getLeft(e)&#123; var offset = e.offsetLeft; if(e.offsetParent != null)&#123; offset += getLeft(e.offsetParent); &#125; return offset;&#125;","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://didiorg.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js","slug":"js","permalink":"http://didiorg.com/tags/js/"},{"name":"web","slug":"web","permalink":"http://didiorg.com/tags/web/"},{"name":"浏览器","slug":"浏览器","permalink":"http://didiorg.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"dom","slug":"dom","permalink":"http://didiorg.com/tags/dom/"}]},{"title":"eslint 常用配置中文注释","slug":"eslint-常用配置中文注释","date":"2020-02-24T06:03:32.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/4069831407/","link":"","permalink":"http://didiorg.com/4069831407/","excerpt":"注意这里的数字：0表示不不处理，1表示警告，2表示错误并退出这里的 0，1，2 也可以用 off, warn, error, 表示: “off”或者0 &#x2F;&#x2F;关闭规则关闭“warn”或者1 &#x2F;&#x2F;在打开的规则作为警告（不影响退出代码）“error”或者2 &#x2F;&#x2F;把规则作为一个错误（退出代码触发时为1）","text":"注意这里的数字：0表示不不处理，1表示警告，2表示错误并退出这里的 0，1，2 也可以用 off, warn, error, 表示: “off”或者0 &#x2F;&#x2F;关闭规则关闭“warn”或者1 &#x2F;&#x2F;在打开的规则作为警告（不影响退出代码）“error”或者2 &#x2F;&#x2F;把规则作为一个错误（退出代码触发时为1） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236&#123;&quot;rules&quot; : &#123; // 定义对象的set存取器属性时，强制定义get &quot;accessor-pairs&quot;: 2, // 指定数组的元素之间要以空格隔开(,后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格 &quot;array-bracket-spacing&quot;: [2, &quot;never&quot;], // 在块级作用域外访问块内定义的变量是否报错提示 &quot;block-scoped-var&quot;: 0, // if while function 后面的&#123;必须与if在同一行，java风格。 &quot;brace-style&quot;: [2, &quot;1tbs&quot;, &#123; &quot;allowSingleLine&quot;: true &#125;], // 双峰驼命名格式 &quot;camelcase&quot;: 2, // 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号， // always-multiline：多行模式必须带逗号，单行模式不能带逗号 &quot;comma-dangle&quot;: [2, &quot;never&quot;], // 控制逗号前后的空格 &quot;comma-spacing&quot;: [2, &#123; &quot;before&quot;: false, &quot;after&quot;: true &#125;], // 控制逗号在行尾出现还是在行首出现 // http://eslint.org/docs/rules/comma-style &quot;comma-style&quot;: [2, &quot;last&quot;], // 圈复杂度 &quot;complexity&quot;: [2,9], // 以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always &quot;computed-property-spacing&quot;: [2,&quot;never&quot;], // 强制方法必须返回值，TypeScript强类型，不配置 &quot;consistent-return&quot;: 0, // 用于指统一在回调函数中指向this的变量名，箭头函数中的this已经可以指向外层调用者，应该没卵用了 // e.g [0,&quot;that&quot;] 指定只能 var that = this. that不能指向其他任何值，this也不能赋值给that以外的其他值 &quot;consistent-this&quot;: 0, // 强制在子类构造函数中用super()调用父类构造函数，TypeScrip的编译器也会提示 &quot;constructor-super&quot;: 0, // if else while for do后面的代码块是否需要&#123; &#125;包围，参数： // multi 只有块中有多行语句时才需要&#123; &#125;包围 // multi-line 只有块中有多行语句时才需要&#123; &#125;包围, 但是块中的执行语句只有一行时， // 块中的语句只能跟和if语句在同一行。if (foo) foo++; else doSomething(); // multi-or-nest 只有块中有多行语句时才需要&#123; &#125;包围, 如果块中的执行语句只有一行，执行语句可以零另起一行也可以跟在if语句后面 // [2, &quot;multi&quot;, &quot;consistent&quot;] 保持前后语句的&#123; &#125;一致 // default: [2, &quot;all&quot;] 全都需要&#123; &#125;包围 &quot;curly&quot;: [2, &quot;all&quot;], // switch语句强制default分支，也可添加 // no default 注释取消此次警告 &quot;default-case&quot;: 2, // 强制object.key 中 . 的位置，参数: // property，&#x27;.&#x27;号应与属性在同一行 // object, &#x27;.&#x27; 号应与对象名在同一行 &quot;dot-location&quot;: [2, &quot;property&quot;], // 强制使用.号取属性 // 参数： allowKeywords：true 使用保留字做属性名时，只能使用.方式取属性 // false 使用保留字做属性名时, 只能使用[]方式取属性 e.g [2, &#123;&quot;allowKeywords&quot;: false&#125;] // allowPattern: 当属性名匹配提供的正则表达式时，允许使用[]方式取值,否则只能用.号取值 e.g [2, &#123;&quot;allowPattern&quot;: &quot;^[a-z]+(_[a-z]+)+$&quot;&#125;] &quot;dot-notation&quot;: [2, &#123;&quot;allowKeywords&quot;: true&#125;], // 文件末尾强制换行 &quot;eol-last&quot;: 2, // 使用 === 替代 == &quot;eqeqeq&quot;: [2, &quot;allow-null&quot;], // 方法表达式是否需要命名 &quot;func-names&quot;: 0, // 方法定义风格，参数： // declaration: 强制使用方法声明的方式，function f()&#123;&#125; e.g [2, &quot;declaration&quot;] // expression：强制使用方法表达式的方式，var f = function() &#123;&#125; e.g [2, &quot;expression&quot;] // allowArrowFunctions: declaration风格中允许箭头函数。 e.g [2, &quot;declaration&quot;, &#123; &quot;allowArrowFunctions&quot;: true &#125;] &quot;func-style&quot;: 0, &quot;no-alert&quot;: 0,//禁止使用alert confirm prompt &quot;no-array-constructor&quot;: 2,//禁止使用数组构造器 &quot;no-bitwise&quot;: 0,//禁止使用按位运算符 &quot;no-caller&quot;: 1,//禁止使用arguments.caller或arguments.callee &quot;no-catch-shadow&quot;: 2,//禁止catch子句参数与外部作用域变量同名 &quot;no-class-assign&quot;: 2,//禁止给类赋值 &quot;no-cond-assign&quot;: 2,//禁止在条件表达式中使用赋值语句 &quot;no-console&quot;: 2,//禁止使用console &quot;no-const-assign&quot;: 2,//禁止修改const声明的变量 &quot;no-constant-condition&quot;: 2,//禁止在条件中使用常量表达式 if(true) if(1) &quot;no-continue&quot;: 0,//禁止使用continue &quot;no-control-regex&quot;: 2,//禁止在正则表达式中使用控制字符 &quot;no-debugger&quot;: 2,//禁止使用debugger &quot;no-delete-var&quot;: 2,//不能对var声明的变量使用delete操作符 &quot;no-div-regex&quot;: 1,//不能使用看起来像除法的正则表达式/=foo/ &quot;no-dupe-keys&quot;: 2,//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125; &quot;no-dupe-args&quot;: 2,//函数参数不能重复 &quot;no-duplicate-case&quot;: 2,//switch中的case标签不能重复 &quot;no-else-return&quot;: 2,//如果if语句里面有return,后面不能跟else语句 &quot;no-empty&quot;: 2,//块语句中的内容不能为空 &quot;no-empty-character-class&quot;: 2,//正则表达式中的[]内容不能为空 &quot;no-empty-label&quot;: 2,//禁止使用空label &quot;no-eq-null&quot;: 2,//禁止对null使用==或!=运算符 &quot;no-eval&quot;: 1,//禁止使用eval &quot;no-ex-assign&quot;: 2,//禁止给catch语句中的异常参数赋值 &quot;no-extend-native&quot;: 2,//禁止扩展native对象 &quot;no-extra-bind&quot;: 2,//禁止不必要的函数绑定 &quot;no-extra-boolean-cast&quot;: 2,//禁止不必要的bool转换 &quot;no-extra-parens&quot;: 2,//禁止非必要的括号 &quot;no-extra-semi&quot;: 2,//禁止多余的冒号 &quot;no-fallthrough&quot;: 1,//禁止switch穿透 &quot;no-floating-decimal&quot;: 2,//禁止省略浮点数中的0 .5 3. &quot;no-func-assign&quot;: 2,//禁止重复的函数声明 &quot;no-implicit-coercion&quot;: 1,//禁止隐式转换 &quot;no-implied-eval&quot;: 2,//禁止使用隐式eval &quot;no-inline-comments&quot;: 0,//禁止行内备注 &quot;no-inner-declarations&quot;: [2, &quot;functions&quot;],//禁止在块语句中使用声明（变量或函数） &quot;no-invalid-regexp&quot;: 2,//禁止无效的正则表达式 &quot;no-invalid-this&quot;: 2,//禁止无效的this，只能用在构造器，类，对象字面量 &quot;no-irregular-whitespace&quot;: 2,//不能有不规则的空格 &quot;no-iterator&quot;: 2,//禁止使用__iterator__ 属性 &quot;no-label-var&quot;: 2,//label名不能与var声明的变量名相同 &quot;no-labels&quot;: 2,//禁止标签声明 &quot;no-lone-blocks&quot;: 2,//禁止不必要的嵌套块 &quot;no-lonely-if&quot;: 2,//禁止else语句内只有if语句 &quot;no-loop-func&quot;: 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以） &quot;no-mixed-requires&quot;: [0, false],//声明时不能混用声明类型 &quot;no-mixed-spaces-and-tabs&quot;: [2, false],//禁止混用tab和空格 &quot;linebreak-style&quot;: [0, &quot;windows&quot;],//换行风格 &quot;no-multi-spaces&quot;: 1,//不能用多余的空格 &quot;no-multi-str&quot;: 2,//字符串不能用\\换行 &quot;no-multiple-empty-lines&quot;: [1, &#123;&quot;max&quot;: 2&#125;],//空行最多不能超过2行 &quot;no-native-reassign&quot;: 2,//不能重写native对象 &quot;no-negated-in-lhs&quot;: 2,//in 操作符的左边不能有! &quot;no-nested-ternary&quot;: 0,//禁止使用嵌套的三目运算 &quot;no-new&quot;: 1,//禁止在使用new构造一个实例后不赋值 &quot;no-new-func&quot;: 1,//禁止使用new Function &quot;no-new-object&quot;: 2,//禁止使用new Object() &quot;no-new-require&quot;: 2,//禁止使用new require &quot;no-new-wrappers&quot;: 2,//禁止使用new创建包装实例，new String new Boolean new Number &quot;no-obj-calls&quot;: 2,//不能调用内置的全局对象，比如Math() JSON() &quot;no-octal&quot;: 2,//禁止使用八进制数字 &quot;no-octal-escape&quot;: 2,//禁止使用八进制转义序列 &quot;no-param-reassign&quot;: 2,//禁止给参数重新赋值 &quot;no-path-concat&quot;: 0,//node中不能使用__dirname或__filename做路径拼接 &quot;no-plusplus&quot;: 0,//禁止使用++，-- &quot;no-process-env&quot;: 0,//禁止使用process.env &quot;no-process-exit&quot;: 0,//禁止使用process.exit() &quot;no-proto&quot;: 2,//禁止使用__proto__属性 &quot;no-redeclare&quot;: 2,//禁止重复声明变量 &quot;no-regex-spaces&quot;: 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/ &quot;no-restricted-modules&quot;: 0,//如果禁用了指定模块，使用就会报错 &quot;no-return-assign&quot;: 1,//return 语句中不能有赋值表达式 &quot;no-script-url&quot;: 0,//禁止使用javascript:void(0) &quot;no-self-compare&quot;: 2,//不能比较自身 &quot;no-sequences&quot;: 0,//禁止使用逗号运算符 &quot;no-shadow&quot;: 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名 &quot;no-shadow-restricted-names&quot;: 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用 &quot;no-spaced-func&quot;: 2,//函数调用时 函数名与()之间不能有空格 &quot;no-sparse-arrays&quot;: 2,//禁止稀疏数组， [1,,2] &quot;no-sync&quot;: 0,//nodejs 禁止同步方法 &quot;no-ternary&quot;: 0,//禁止使用三目运算符 &quot;no-trailing-spaces&quot;: 1,//一行结束后面不要有空格 &quot;no-this-before-super&quot;: 0,//在调用super()之前不能使用this或super &quot;no-throw-literal&quot;: 2,//禁止抛出字面量错误 throw &quot;error&quot;; &quot;no-undef&quot;: 1,//不能有未定义的变量 &quot;no-undef-init&quot;: 2,//变量初始化时不能直接给它赋值为undefined &quot;no-undefined&quot;: 2,//不能使用undefined &quot;no-unexpected-multiline&quot;: 2,//避免多行表达式 &quot;no-underscore-dangle&quot;: 1,//标识符不能以_开头或结尾 &quot;no-unneeded-ternary&quot;: 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false; &quot;no-unreachable&quot;: 2,//不能有无法执行的代码 &quot;no-unused-expressions&quot;: 2,//禁止无用的表达式 &quot;no-unused-vars&quot;: [2, &#123;&quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;after-used&quot;&#125;],//不能有声明后未被使用的变量或参数 &quot;no-use-before-define&quot;: 2,//未定义前不能使用 &quot;no-useless-call&quot;: 2,//禁止不必要的call和apply &quot;no-void&quot;: 2,//禁用void操作符 &quot;no-var&quot;: 0,//禁用var，用let和const代替 &quot;no-warning-comments&quot;: [1, &#123; &quot;terms&quot;: [&quot;todo&quot;, &quot;fixme&quot;, &quot;xxx&quot;], &quot;location&quot;: &quot;start&quot; &#125;],//不能有警告备注 &quot;no-with&quot;: 2,//禁用with &quot;array-bracket-spacing&quot;: [2, &quot;never&quot;],//是否允许非空数组里面有多余的空格 &quot;arrow-parens&quot;: 0,//箭头函数用小括号括起来 &quot;arrow-spacing&quot;: 0,//=&gt;的前/后括号 &quot;accessor-pairs&quot;: 0,//在对象中使用getter/setter &quot;block-scoped-var&quot;: 0,//块语句中使用var &quot;brace-style&quot;: [1, &quot;1tbs&quot;],//大括号风格 &quot;callback-return&quot;: 1,//避免多次调用回调什么的 &quot;camelcase&quot;: 2,//强制驼峰法命名 &quot;comma-dangle&quot;: [2, &quot;never&quot;],//对象字面量项尾不能有逗号 &quot;comma-spacing&quot;: 0,//逗号前后的空格 &quot;comma-style&quot;: [2, &quot;last&quot;],//逗号风格，换行时在行首还是行尾 &quot;complexity&quot;: [0, 11],//循环复杂度 &quot;computed-property-spacing&quot;: [0, &quot;never&quot;],//是否允许计算后的键名什么的 &quot;consistent-return&quot;: 0,//return 后面是否允许省略 &quot;consistent-this&quot;: [2, &quot;that&quot;],//this别名 &quot;constructor-super&quot;: 0,//非派生类不能调用super，派生类必须调用super &quot;curly&quot;: [2, &quot;all&quot;],//必须使用 if()&#123;&#125; 中的&#123;&#125; &quot;default-case&quot;: 2,//switch语句最后必须有default &quot;dot-location&quot;: 0,//对象访问符的位置，换行的时候在行首还是行尾 &quot;dot-notation&quot;: [0, &#123; &quot;allowKeywords&quot;: true &#125;],//避免不必要的方括号 &quot;eol-last&quot;: 0,//文件以单一的换行符结束 &quot;eqeqeq&quot;: 2,//必须使用全等 &quot;func-names&quot;: 0,//函数表达式必须有名字 &quot;func-style&quot;: [0, &quot;declaration&quot;],//函数风格，规定只能使用函数声明/函数表达式 &quot;generator-star-spacing&quot;: 0,//生成器函数*的前后空格 &quot;guard-for-in&quot;: 0,//for in循环要用if语句过滤 &quot;handle-callback-err&quot;: 0,//nodejs 处理错误 &quot;id-length&quot;: 0,//变量名长度 &quot;indent&quot;: [2, 4],//缩进风格 &quot;init-declarations&quot;: 0,//声明时必须赋初值 &quot;key-spacing&quot;: [0, &#123; &quot;beforeColon&quot;: false, &quot;afterColon&quot;: true &#125;],//对象字面量中冒号的前后空格 &quot;lines-around-comment&quot;: 0,//行前/行后备注 &quot;max-depth&quot;: [0, 4],//嵌套块深度 &quot;max-len&quot;: [0, 80, 4],//字符串最大长度 &quot;max-nested-callbacks&quot;: [0, 2],//回调嵌套深度 &quot;max-params&quot;: [0, 3],//函数最多只能有3个参数 &quot;max-statements&quot;: [0, 10],//函数内最多有几个声明 &quot;new-cap&quot;: 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用 &quot;new-parens&quot;: 2,//new时必须加小括号 &quot;newline-after-var&quot;: 2,//变量声明后是否需要空一行 &quot;object-curly-spacing&quot;: [0, &quot;never&quot;],//大括号内是否允许不必要的空格 &quot;object-shorthand&quot;: 0,//强制对象字面量缩写语法 &quot;one-var&quot;: 1,//连续声明 &quot;operator-assignment&quot;: [0, &quot;always&quot;],//赋值运算符 += -=什么的 &quot;operator-linebreak&quot;: [2, &quot;after&quot;],//换行时运算符在行尾还是行首 &quot;padded-blocks&quot;: 0,//块语句内行首行尾是否要空行 &quot;prefer-const&quot;: 0,//首选const &quot;prefer-spread&quot;: 0,//首选展开运算 &quot;prefer-reflect&quot;: 0,//首选Reflect的方法 &quot;quotes&quot;: [1, &quot;single&quot;],//引号类型 `` &quot;&quot; &#x27;&#x27; &quot;quote-props&quot;:[2, &quot;always&quot;],//对象字面量中的属性名是否强制双引号 &quot;radix&quot;: 2,//parseInt必须指定第二个参数 &quot;id-match&quot;: 0,//命名检测 &quot;require-yield&quot;: 0,//生成器函数必须有yield &quot;semi&quot;: [2, &quot;always&quot;],//语句强制分号结尾 &quot;semi-spacing&quot;: [0, &#123;&quot;before&quot;: false, &quot;after&quot;: true&#125;],//分号前后空格 &quot;sort-vars&quot;: 0,//变量声明时排序 &quot;space-after-keywords&quot;: [0, &quot;always&quot;],//关键字后面是否要空一格 &quot;space-before-blocks&quot;: [0, &quot;always&quot;],//不以新行开始的块&#123;前面要不要有空格 &quot;space-before-function-paren&quot;: [0, &quot;always&quot;],//函数定义时括号前面要不要有空格 &quot;space-in-parens&quot;: [0, &quot;never&quot;],//小括号里面要不要有空格 &quot;space-infix-ops&quot;: 0,//中缀操作符周围要不要有空格 &quot;space-return-throw-case&quot;: 2,//return throw case后面要不要加空格 &quot;space-unary-ops&quot;: [0, &#123; &quot;words&quot;: true, &quot;nonwords&quot;: false &#125;],//一元运算符的前/后要不要加空格 &quot;spaced-comment&quot;: 0,//注释风格不要有空格什么的 &quot;strict&quot;: 2,//使用严格模式 &quot;use-isnan&quot;: 2,//禁止比较时使用NaN，只能用isNaN() &quot;valid-jsdoc&quot;: 0,//jsdoc规则 &quot;valid-typeof&quot;: 2,//必须使用合法的typeof的值 &quot;vars-on-top&quot;: 2,//var必须放在作用域顶部 &quot;wrap-iife&quot;: [2, &quot;inside&quot;],//立即执行函数表达式的小括号风格 &quot;wrap-regex&quot;: 0,//正则表达式字面量用小括号包起来 &quot;yoda&quot;: [2, &quot;never&quot;]//禁止尤达条件 &#125;&#125; 原文地址 &gt;&gt;&gt;","categories":[],"tags":[]},{"title":"学习笔记3 常见运算题","slug":"学习笔记3_常见运算题","date":"2020-02-21T06:15:45.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/1708901590/","link":"","permalink":"http://didiorg.com/1708901590/","excerpt":"一些讲运算结果类型的面试题【不定时更新】","text":"一些讲运算结果类型的面试题【不定时更新】 1234567891011var name = &quot;Hello&quot;;var object = &#123; name: &quot;world&quot;, getNameFunc: function() &#123; return function() &#123; return this.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()); // Hello object.getNameFunc() 返回的就是一个 function，function () &#123; return this.name &#125; 123456789101112var name = &quot;Hello&quot;;var object = &#123; name: &quot;world&quot;, getNameFunc: function() &#123; var that = this; return function() &#123; return that.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()); // world 这个 that = this 产生了闭包 123456789101112131415161718function fun(n, o) &#123; console.log(o); return &#123; fun: function(m) &#123; return fun(m, n); &#125; &#125;;&#125;var a = fun(0); // undefineda.fun(1); // undefined 0a.fun(2); // undefined 0a.fun(3); // undefined 0var b = fun(0).fun(1).fun(2).fun(3); // undefined 0 1 2var c = fun(0).fun(1); // undefined 0c.fun(2); // 1c.fun(3); // 1 作用域 123456789var x = 10;function fn() &#123; console.log(x);&#125;function show(f) &#123; var x = 20; f();&#125;show(fn); // 10 函数的作用域， 跟函数的调用位置的作用域没关系 123456789101112var fn = function() &#123; console.log(fn);&#125;;fn(); // f() &#123; console.log(fn) &#125;var obj = &#123; fn2: function() &#123; console.log(fn2); // 内部作用域里边没有 fn2， 外部作用域是 windon 也没有 &#125;&#125;;obj.fn2(); // 报错， fn2 is not defind","categories":[{"name":"learning notes","slug":"learning-notes","permalink":"http://didiorg.com/categories/learning-notes/"}],"tags":[{"name":"js","slug":"js","permalink":"http://didiorg.com/tags/js/"},{"name":"web","slug":"web","permalink":"http://didiorg.com/tags/web/"}]},{"title":"react render 原理","slug":"react-render-原理","date":"2020-02-20T04:31:43.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/2202868307/","link":"","permalink":"http://didiorg.com/2202868307/","excerpt":"","text":"JSX 代码经过 babel 编译之后变成 React.createElement 的表达式，这个表达式在 render 函数被调用的时候执行生成一个 element。 在首次渲染的时候，先去按照规则初始化 element，接着 ReactComponentComponentWrapper 通过递归，最终调用 ReactDOMComponent 的 mountComponent 方法来帮助生成真实 DOM 节点。 地址一： React 从渲染原理到性能优化（一） 地址二： React 从渲染原理到性能优化（二）– 更新渲染","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://didiorg.com/tags/js/"},{"name":"react","slug":"react","permalink":"http://didiorg.com/tags/react/"}]},{"title":"学习笔记2 JS基础知识","slug":"学习笔记2_JS基础知识","date":"2020-02-18T04:14:32.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/1015335320/","link":"","permalink":"http://didiorg.com/1015335320/","excerpt":"课程地址: JavaScript 基础知识","text":"课程地址: JavaScript 基础知识 基础数据类型js 数据类型： ‘usbno’ undefined: 未定义stringbooleannumberobjectnull JS 基本数据类型： undefined, string, number, boolean, null function 不是数据类型object 是复杂数据类型 NaNnot a number isNaN 跟谁都不相等， 包括它本身typeof NaN &#x2F;&#x2F; “number” 检测一个变量是不是 NaN ES6: isNaN()ES5: a !&#x3D; a 为 false 不是 NaN， 为 true 则是 NaN js 作用域链当前函数作用域找不到的时候就去它的父级找 123456789var a = 666;function show() &#123; var a = 233; show2();&#125;function show2() &#123; console.log(a);&#125;show(); // 666 这是因为 show2 所在的位置是跟 show 一个作用域的，show 函数并不是 show2 函数的父级在这里， show2 的父级跟 show 一样， 是 Window 123456789var a = 666;function show() &#123; var a = 2333; show2(); function show2() &#123; console.log(a); &#125;&#125;show(); // 2333 这里 show2 的父级就是 show， 所以会打印 2333 当前函数作用域找不到的时候就去它的父级找 这名话只跟物理位置有关，跟调用没关 IIFE 匿名函数自执行123(function() &#123; console.log(&quot;我就是匿名函数自执行&quot;);&#125;)(); 避免变量污染 以前写框架的时候经常用 闭包12345678function show() &#123; var num = 666; return function() &#123; console.log(num); &#125;;&#125;const show2 = show();show2(); // 666 1234567891011var arr = [];for (var i = 0; i &lt; 3; i++) &#123; (function(i) &#123; arr[i] = function() &#123; return i; &#125;; &#125;)(i);&#125;console.log(arr[0]()); // 0console.log(arr[1]()); // 1console.log(arr[2]()); // 2 事件流 捕获冒泡 this在浏览器下，全局 this 指向 Window， 对象引用时 指向引用它的那个对象 全局this 在浏览器下指向 Window 函数 this 1234function show() &#123; console.log(this);&#125;show(); // Window 12345&quot;use strict&quot;;function show() &#123; console.log(this);&#125;show(); // undefined 对象 12345678var info = &#123; name: &quot;ahui&quot;, showName: function() &#123; console.log(this.name); &#125;&#125;;info.showName(); // ahui 12345678910111213// &quot;use strict&quot;; // undefined 如果是在严格模式下的时候， this 为 undefinedvar name = &quot;angelee&quot;;var info = &#123; name: &quot;ahui&quot;, showName: function() &#123; function showMyName() &#123; console.log(this.name); &#125; showMyName(); &#125;&#125;;info.showName(); // angelee call apply bind 区别改变 this 指向 1234function show() &#123; console.log(this);&#125;show(); // Window 1234function show(a, b) &#123; console.log(this, a, b);&#125;show.call(666, 233, 6969); // Number &#123;666&#125; 233 6969 1234567891011var info = &#123; name: &quot;ahui&quot;, showName: function() &#123; function showMyName() &#123; console.log(this.name); &#125; showMyName.call(this); &#125;&#125;;info.showName(); // ahui bind() 不会执行， 只传递 this 指向 当一个方法需要添加默认参数的时候用得多， 其它的情况一般用 call 或者 apply 1234567891011var info = &#123; name: &quot;ahui&quot;, showName: function() &#123; showMyName = function() &#123; console.log(this.name); &#125;.bind(this); showMyName(); &#125;&#125;;info.showName(); // ahui apply 跟 call 一样， 就是第二个参数是数组而 call，如果碰到多个参数， 从第二个参数开始，就得一个一个写 12var arr = [12, 3, 5, 8];Math.max.apply(null, arr); //12 面向对象编辑和简单的设计模式创建对象的三种方式 单体模式 12345678var Ahui = &#123; name: &quot;angelee&quot;, age: 18, showName: function() &#123; return this.name; &#125;&#125;;Ahui.showName(); // &quot;angelee&quot; 原型模式属性放在构造函数，方法放在原型上 123456789function Ahui(name, age) &#123; this.name = name; this.age = age;&#125;Ahui.prototype.showName = function() &#123; return this.name;&#125;;var angelee = new Ahui(&quot;angelee&quot;, 18);angelee.showName(); // &quot;angelee&quot; 类模式通过 ea6 的 class 去定义对象 1234567891011class Ahui &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; showName() &#123; return this.name + this.age; &#125;&#125;var angelee = new Ahui(&quot;angelee&quot;, 18);angelee.showName(); // &quot;angelee18&quot; 面向对象继承 单体模式下的继承通过 Object.create() 方法继承 12345678910111213141516var Ahui = &#123; name: &quot;angelee&quot;, age: 18, showName: function() &#123; return this.name; &#125;&#125;;var DaHui = Object.create(Ahui);DaHui.name = &quot;lipenghui&quot;;DaHui.age = 188;DaHui.showAge = function() &#123; return this.age;&#125;;console.log(DaHui.showName()); // liepnghui`console.log(DaHui.showAge()); // 188 通过 ea6 的 class 方法 1234567891011121314151617181920212223// 父类class Ahui &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; showName() &#123; return this.name; &#125;&#125;class DaHui extends Ahui &#123; constructor(name, age, job) &#123; super(name, age); this.job = job; &#125; showInfo() &#123; return `name:$&#123;super.showName()&#125;, age: $&#123;this.age&#125;, job: $&#123;this.job&#125;`; &#125;&#125;var angelee = new DaHui(&quot;angelee&quot;, 16, &quot;fe&quot;);angelee.showInfo(); // &quot;name:angelee, age: 16, job: fe&quot; 记住关键字： extends、 super 就行， 这是规范， 刚开始觉得不习惯， 用久了之后， 就像用 if else 一样简单 跨域 JSONP 原理 js 是可以跨域的 服务器返回的数据，是相当于一个函数调用 本地 js 方法里边有一个方法的定义， 调用本地的方法的时候，就会去调用对应的函数 只能是 get 方法， 如果要用 pust 就用 CROS CROS 必须需要服务器端配合开发，否则不行","categories":[{"name":"learning notes","slug":"learning-notes","permalink":"http://didiorg.com/categories/learning-notes/"}],"tags":[{"name":"js","slug":"js","permalink":"http://didiorg.com/tags/js/"},{"name":"web","slug":"web","permalink":"http://didiorg.com/tags/web/"}]},{"title":"学习笔记1 ES6","slug":"学习笔记1_ES6","date":"2020-02-15T06:25:25.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/773176463/","link":"","permalink":"http://didiorg.com/773176463/","excerpt":"","text":"课程地址: 【JS 老毕】Javascript ES6 基础+核心课程 9. 字符串方法和 for ofincludes 是否包含，返回 true&#x2F;false 123const string = &quot;abc&quot;;const substring = &quot;ab&quot;;console.log(string.includes(substring)); // true startsWith 是否是以某个字符串开始， 返回 true&#x2F;falseendsWith 是否是以某个字符串结尾， 返回 true&#x2F;false 123const string = &quot;abc&quot;;const substring = &quot;ab&quot;;console.log(string.startsWith(substring)); // true for of 123456789101112131415161718192021222324252627const tests = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;];for (const test of tests) &#123; console.log(test);&#125;let maps = new Map();maps.set(&quot;name&quot;, &quot;ahui&quot;);maps.set(&quot;phone&quot;, &quot;17600888888&quot;);maps.set(&quot;city&quot;, [&quot;北京&quot;, &quot;上海&quot;]);for (const [key, value] of maps) &#123; console.log(key, value);&#125;// name, ahui// phone, 17600888888// city, [&quot;北京&quot;, &quot;上海&quot;]const tests = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;];// entries() 方法返回一个数组的迭代对象，该对象包含数组的键值对 (key/value)。for (const test of tests.entries()) &#123; console.log(test);&#125;// (2) [0, &quot;a&quot;]// (2) [1, &quot;b&quot;]// (2) [2, &quot;c&quot;]// (2) [3, &quot;d&quot;]// (2) [4, &quot;e&quot;] 8. 函数参数默认值12345function orderCombo(comboName = &quot;鸡块&quot;, drink = &quot;可乐&quot;) &#123; console.log(comboName); console.log(drink);&#125;orderCombo(&quot;蛋炒饭&quot;); 7. 剩余参数和扩展参数 …剩余参数是把多个打包成一个数组将一个数据拆分成多个项 1234567891011// 剩余参数const tests = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;];const [a, b, ...c] = tests;// 会把数组 tests 里边后边三项组合成一个数组赋值给 cconsole.log(a, b, c); // a, b, [c, d, e]// 扩展参数const a = &quot;a&quot;;const b = &quot;b&quot;;const c = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];console.log([a, b, ...c]); // [a, b , a, b, c] 6. 结构赋值object 结构赋值123456789101112131415161718192021const person = &#123; name: &quot;ahui&quot;, age: &quot;18&quot;, city: &quot;BJ&quot;, social: &#123; www: &quot;didiorg.com&quot;; email: &quot;ahuinet@163.com&quot; &#125;&#125;// 用已有的属性名 赋值const &#123;name, age, city&#125; = personconst &#123;www, email&#125; = person.socialconst &#123;name, social: &#123;www&#125;&#125; = personconsole.log(name, age, city, www, email)// 用新的变量名const &#123; name: ahuiName &#125; = person // ahui// 添加默认值const &#123; mony = 1008610010 &#125; = person 数组的结构赋值123456789const info = &quot;ahui, 18, 1000000000&quot;;const person = infor.split(&quot;,&quot;);const [name, age, mony] = person;console.log(name, age, mony); // ahui, 19, 1000000000let a = 1;let b = 2;[a, b] = [b, a];console.log(a, b); // 2, 1 5. map 对象map set 数据的时候，key 是唯一的，如果 set 一个原来有的属性，就会更新原来对应 key 的值 123456789101112let maps = new Map();// 添加maps.set(&quot;name&quot;, &quot;ahui&quot;);maps.set(&quot;phone&quot;, &quot;17600888888&quot;);// 删除maps.delete(&quot;name&quot;);// 查找maps.has(&quot;name&quot;);// 获取maps.get(&quot;name&quot;);// 遍历// for...of 4. set 对象set 里边不会有重复的值 12345678910let sets = new Set();// 添加sets.add(1); // 1 添加sets.add(2); // 1, 2// 删除sets.delete(1); // 返回 true， 删除成功返回 ture， 删除失败返回 false// 查找sets.has(1); // 返回 false，查找// 遍历sets.forEach((item, i) =&gt; &#123;&#125;); 3. 模板字符串 &#96;&#96;1234567const ahuiMsg = &#123; name: &quot;ahui&quot;, age: &quot;18&quot;, phone: &quot;17600888888&quot; email: &quot;ahuinet@163.com&quot;&#125;const intro = `大家好我叫$&#123;ahuiMsg.name&#125;,今年$&#123;ahuiMsg.age&#125;` 2. 箭头函数 &#x3D;&gt; 能使用函数写法更简洁 函数返回值可以被隐式返回，不需要写 return 不重新绑定 this 的值 1. let constlet 定义变量const 定义常量var 可以重复定义变量，let const 不可以重复定义var 函数作用域， let const 是块作用域 常用 const， 少用 let， 不用 var","categories":[{"name":"learning notes","slug":"learning-notes","permalink":"http://didiorg.com/categories/learning-notes/"}],"tags":[{"name":"js","slug":"js","permalink":"http://didiorg.com/tags/js/"},{"name":"web","slug":"web","permalink":"http://didiorg.com/tags/web/"},{"name":"ES6","slug":"ES6","permalink":"http://didiorg.com/tags/ES6/"}]},{"title":"JS __proto__和prototype的区别和关系","slug":"js-__proto__和prototype的区别和关系","date":"2020-02-15T04:23:39.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/proto/","link":"","permalink":"http://didiorg.com/proto/","excerpt":"首先，看别人怎么说的：1.在JS里，万物皆对象。方法（Function）是对象，方法的原型(Function.prototype)也是对象。它们都会具有对象共有的特点:对象具有属性 __proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。","text":"首先，看别人怎么说的：1.在JS里，万物皆对象。方法（Function）是对象，方法的原型(Function.prototype)也是对象。它们都会具有对象共有的特点:对象具有属性 __proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。 2.方法(Function)方法这个特殊的对象，除了和其他对象一样有上述 __proto__ 属性之外，还有自己特有的属性——原型属性（prototype），这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。 1.构造函数Foo()构造函数的原型属性Foo.prototype指向了原型对象，在原型对象里有共有的方法，所有构造函数声明的实例（这里是f1，f2）都可以共享这个方法。 2.原型对象Foo.prototypeFoo.prototype保存着实例共享的方法，有一个指针constructor指回构造函数。 3.实例f1和f2是Foo这个对象的两个实例，这两个对象也有属性__proto__，指向构造函数的原型对象，这样子就可以像上面1所说的访问原型对象的所有方法啦。另外：构造函数Foo()除了是方法，也是对象啊，它也有__proto__属性，指向谁呢？指向它的构造函数的原型对象呗。函数的构造函数不就是Function嘛，因此这里的__proto__指向了Function.prototype。其实除了Foo()，Function(), Object()也是一样的道理。 定义__proto__（隐式原型) JavaScript中任意对象都有一个内置属性[[prototype]]，在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过__proto__来访问 prototype（显式原型） 每一个函数在创建之后都会拥有一个名为prototype的属性，这个属性指向函数的原型对象。 js中每个数据类型都是对象（除了null和undefined），而每个对象都继承自另外一个对象，后者称为“原型”（prototype）对象，只有null除外，它没有自己的原型对象。 每一个函数在创建之后都会拥有一个名为prototype的属性，这个属性指向函数的原型对象。 __proto__ 跟 prototype的关系 对象有属性__proto__, 指向该对象的构造函数的原型对象。 方法除了有属性__proto__,还有属性prototype，prototype指向该方法的原型对象。 然后，自己理解123456789101112// 我有一个构造函数 Personfunction Person (name) &#123; this.naem = name&#125;// 这个构造函数的原型对象是 Person.prototype// 通过Pserson 实例出一个人 ahuilet ahui = new Person(&#x27;ahui&#x27;);// 现在 ahui 也是一个对象// 则 ahui 的 __proro__ 指向 Person 的原型对象 Person.prototypeahui.__proto__ === Person.prototype // true 通过上边的代码， 我们是不是可以想像一下:构造函数funcion Person 是不是也可以理解它是另外一个构造函数构Funcion造出来的 ? 12function Person() &#123;&#125;Person.__proto__ === Function.prototype // ture 想像成立！！ 那这个时间是不是又有可能在想 Function 又是谁造出来的呢？ 1234Function.__proto__ === Function.prototype // trueFunction.prototype.__proto__ === Object.prototype // trueObject.prototype.__proto__ === Object.prototype // falseObject.prototype.__proto__ === null // true 再看一段 1234Function instanceof Object // trueObject instanceof Function // trueFunction instanceof Function // trueObject instanceof Object // ture instanceof 左边操作数的__proto__原型链上是否包括右边操作数的prototype 123456Object.__proto__ === Function.prototype // trueFunction.__proto__ === Object.prototype // falseFunction.__proto__.__proto__ === Object.prototype // trueObject.__proto__ === Object.prototype // falseObject.__proto__.__proto__ === Object.prototype // true 是不是有点意思 ？？？ 参考下面文档： JavaScript instanceof 运算符深入剖析 js中__proto__和prototype的区别和关系 JS中Function和Object的关系研究分析 JavaScript之Function 和 Object 的区别和联系 JS Function与Object关系","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://didiorg.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js","slug":"js","permalink":"http://didiorg.com/tags/js/"},{"name":"web","slug":"web","permalink":"http://didiorg.com/tags/web/"},{"name":"浏览器","slug":"浏览器","permalink":"http://didiorg.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"Lightroom 学习笔记","slug":"Lightroom-学习笔记","date":"2020-02-14T14:16:26.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/3725880038/","link":"","permalink":"http://didiorg.com/3725880038/","excerpt":"课程资源: 秋凉 LightRoom4 教学视频课程来源: 华摄影师 2020 年元宵节送","text":"课程资源: 秋凉 LightRoom4 教学视频课程来源: 华摄影师 2020 年元宵节送 快捷键 commnd + shift + i: 导入 视图： E：放大G：网格F：全屏L：高亮C：比较Com + L： 打开&#x2F;关闭过滤器过滤器栏 面板 F5：上面板F6：下面板F7：左面板F8：右面板Tab： 两侧shit + Tab: 全部面板Command + 0 ~ 8 打开&#x2F;关闭面板 修图 \\: 调整前后的照片Y： 比较窗口Shift + Y:Q：污点去除工具R:：裁剪&#x2F;拉直V：黑白切换M：渐变滤镜K：调整画笔Command + N 新建快照Command + Z 复位Command + Shift + Z 重做 小技巧美白牙齿： 用画笔工具提高亮度 降低饱和度多打开蒙版图层查看所画的区域，是否画到了多余的地方，及时擦除 磨皮： 用画笔工具降低清晰度跟锐化程度多打开蒙版图层查看所画的区域，是否画到了多余的地方，及时擦除 同步： 修改完一张照片，选中其它想要同步的照片，点击同步。（主要，局部高速，剪切，污点，变换等局部的调整不要同步）也可以先选择照片，再打开自动同步，这个时候在照片上做的每一个修改都会自动同步到其它照片上这里选其它照片是通过按下 shift 去选要同步的照片","categories":[{"name":"摄影","slug":"摄影","permalink":"http://didiorg.com/categories/%E6%91%84%E5%BD%B1/"}],"tags":[{"name":"lightroom","slug":"lightroom","permalink":"http://didiorg.com/tags/lightroom/"}]},{"title":"mac 电脑支持 NTFS","slug":"mac-电脑支持-NTFS","date":"2020-01-31T16:35:04.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/2922130013/","link":"","permalink":"http://didiorg.com/2922130013/","excerpt":"让 mac 快速支持 NTFS， 无需安装任何软件","text":"让 mac 快速支持 NTFS， 无需安装任何软件 开启流程简介 挂载上你的 NTFS 硬盘，查看硬盘名称 编辑&#x2F;etc&#x2F;fstab 文件，使其支持 NTFS 写入 将&#x2F;Volumes 中的 NTFS 磁盘快捷方式到 Finder 详细流程 插上硬盘后，查看你的硬盘名称，这里假设名称是 AngleDisk，牢记之（你的可不是这个呀！！ 打开 Applications 的 Terminal, 你也可以直接 spotlight 输入 terminal 打开 在终端输入 sudo nano &#x2F;etc&#x2F;fstab 敲击回车 现在你看到了一个编辑界面，输入 LABEL&#x3D;AngleDisk none ntfs rw,auto,nobrowse 后，敲击回车，再 Ctrl+X，再敲击 Y，再敲击回车 此时，退出你的移动硬盘，再重新插入，你会发现磁盘没有显示在桌面或是 Finder 之前出现的地方，别慌 打开 Finder，Command+Shift+G，输入框中输入&#x2F;Volumes，回车，你就可以看到你的磁盘啦！是可以读写的 方便起见，你可以直接把磁盘拖到 Finder 侧边栏中，这样下次使用就不用进入到&#x2F;Volumes 目录打开了","categories":[],"tags":[]},{"title":"JS判断一个变量是否是数组","slug":"JS-判断一个变量是否是数组","date":"2020-01-30T04:23:45.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/isArray/","link":"","permalink":"http://didiorg.com/isArray/","excerpt":"1. isArray()isArray 是 Array 的一个方法， 如果是数组返回 true, 否则返回 false","text":"1. isArray()isArray 是 Array 的一个方法， 如果是数组返回 true, 否则返回 false 123var a = [1, 2, 3];console.log(typeof a); //返回“object”console.log(Array.isArray(a)); //true 2. instanceofinstanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 123object instanceof constructorobject // 实例constructor // 构造函数 用来检测 constructor.prototype 是否存在于参数 object 的原型链上 (object.__proto__/object.__proto__.__proto__.......__proto__) 1234567var arr = new Array();var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];var obj = &#123; a: &quot;a&quot;, b: &quot;b&quot;, c: &quot;c&quot; &#125;;console.log(arr instanceof Array); //trueconsole.log(arr instanceof Object); //trueconsole.log(obj instanceof Array); //falseconsole.log(obj instanceof Object); //true arr 的原型链上存在 Array.prototype 和 Object.prototype只有 Array 类型的变量才会满足 arr instanceof Array 和 arr instanceof Object 都返回 true也只有 Object 类型变量才满足 obj instanceof Array 返回 false，obj instanceof Object 返回 true 3. constructorconstructor 是 Array 对象的一个属性，该属性返回对创建此对象的数组函数的引用 12345var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];var obj = &#123; a: &quot;a&quot;, b: &quot;b&quot;, c: &quot;c&quot; &#125;;console.log(arr.constructor === Array); //trueconsole.log(arr.constructor === Object); //falseconsole.log(obj.constructor === Object); //true 4. Object.prototype.toString.call()toString()表示返回该对象的字符串 每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中 type 是对象的类型。 call()用来改变 this 指向，能够使用属于另一个对象的方法。 比如对象 b 没有方法 f(), 但是对象 a 有， 就可以直接 a.f.call(b), 这样 b 就使用了 a 里边的一个方法 更多关于 call() 的用法可以看这里&gt;&gt;&gt; 123456789101112131415161718192021222324var a = NaN;var b = &quot;222&quot;;var c = null;var d = false;var e = undefined;var f = Symbol();var arr = [&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;];var obj = &#123; a: &quot;aa&quot;, b: &quot;bb&quot;, c: &quot;cc&quot; &#125;;var res = Object.prototype.toString.call(arr);console.log(res); //[object Array]var res2 = Object.prototype.toString.call(obj);console.log(res2); //[object Object]var res3 = Object.prototype.toString.call(a);console.log(res3); //[object Number]var res4 = Object.prototype.toString.call(b);console.log(res4); //[object String]var res4 = Object.prototype.toString.call(c);console.log(res4); //[object Null]var res5 = Object.prototype.toString.call(d);console.log(res5); //[object Boolean]var res6 = Object.prototype.toString.call(e);console.log(res6); //[object Undefined]var res7 = Object.prototype.toString.call(f);console.log(res7); //[object Symbol] 我们可以使用Object.prototype.toString.call(arr) === &#39;[object Array]&#39;来判断变量是否是数组","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://didiorg.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js","slug":"js","permalink":"http://didiorg.com/tags/js/"},{"name":"web","slug":"web","permalink":"http://didiorg.com/tags/web/"},{"name":"浏览器","slug":"浏览器","permalink":"http://didiorg.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"array","slug":"array","permalink":"http://didiorg.com/tags/array/"}]},{"title":"浏览器 缓存","slug":"浏览器-缓存","date":"2020-01-14T14:07:07.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/cache/","link":"","permalink":"http://didiorg.com/cache/","excerpt":"浏览器缓存是啥？首先，浏览器缓存是指浏览器会把用户访问页面时，从服务器请求回来的东西保存在用户的本地，这些保存在本地的东西就是缓存。当用户再次访问刚才页面时， 浏览器不会真的再次去访问页面所对应该的服务器，而从原来保存在本地的内容中返回用户页面里需要的东西。 注意一下， 这个请求过程是指缓存存在并且有效的时候","text":"浏览器缓存是啥？首先，浏览器缓存是指浏览器会把用户访问页面时，从服务器请求回来的东西保存在用户的本地，这些保存在本地的东西就是缓存。当用户再次访问刚才页面时， 浏览器不会真的再次去访问页面所对应该的服务器，而从原来保存在本地的内容中返回用户页面里需要的东西。 注意一下， 这个请求过程是指缓存存在并且有效的时候 浏览器缓存有啥作用？从上面的请求过程发现，缓存最明显的作用就是减少了页面请求服务器的次数，浏览器性能得到优化，其它的作用还有： 缩短网页请求资源的时间 减少延迟 减少带宽 降低网络负荷 等。。。 但是，好是好，浏览器缓存有时候也会带来问题： 有时候就会碰到服务器的资源文件更新了，但是我们页面访问的时候，浏览器还是从本地缓存拿的内容，这个时候，就不是我们想要的结果了。解决方法就是把浏览器的缓存清掉，主要是刷新，强制刷新，再不行就打开控制台，右击页面刷新图标，点清空缓存并硬性重新加载 浏览器缓存是怎样工作的？先来看一个张浏览器发起一个 http 请求的图片 看完这个图片之后，很清楚的就明白了 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识浏览器每次拿到返回结果的时候，都会将该结果和缓存标识存入浏览器缓存中 以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取 浏览器缓存分为强缓存跟协商缓存 强缓存：不会向服务器重新发起 HTTP 请求，直接从缓存中读取资源协商缓存： 强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程 强缓存强缓存：不会向服务器发送请求，直接从缓存中读取资源，强缓存分为下面三种情况： 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果 当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的 HTTP 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 Expires 和 Cache-Control，其中 Cache-Control 优先级比 Expires 高。 1.Expires缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点 也就是说，Expires&#x3D;max-age + 请求时间，需要和 Last-modified 结合使用。Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。 Expires 是 HTTP&#x2F;1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。Expires: Wed, 22 Oct 2018 08:41:00 GMT 表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。 2.Cache-Controlhttp1.1 的产物， 由多个指令共同决定，主要用于控制网页缓存 public：所有内容都将被缓存（客户端和代理服务器都可缓存） private：所有内容只有客户端可以缓存，表示中间节点（代理服务器）不允许缓存，Cache-Control 的默认取值 no-cache：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定 设置了 no-cache 之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。 no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 max-age：max-age&#x3D;xxx (xxx is numeric)表示缓存内容将在 xxx 秒后失效 s-maxage（单位为 s)：同 max-age 作用一样，只在代理服务器中生效（比如 CDN 缓存） max-stale：能容忍的最大过期时间 min-fresh：能够容忍的最小新鲜度 协商缓存协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程 协商缓存生效，返回 304 和 Not Modified 协商缓存失效，返回 200 和请求结果 同样，协商缓存的标识也是在响应报文的 HTTP 头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified &#x2F; If-Modified-Since 和 Etag &#x2F; If-None-Match，其中 Etag &#x2F; If-None-Match 的优先级比 Last-Modified &#x2F; If-Modified-Since 高。 Last-Modified &#x2F; If-Modified-Since Last-Modified 是服务器响应请求时，返回该资源文件在服务器最后被修改的时间; If-Modified-Since 则是客户端再次发起该请求时，携带上次请求返回的 Last-Modified 值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间 服务器收到该请求，发现请求头含有 If-Modified-Since 字段，则会根据 If-Modified-Since 的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于 If-Modified-Since 的字段值，则重新返回资源，状态码为 200；否则则返回 304，代表资源无更新，可继续使用缓存文件 Etag &#x2F; If-None-Match Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，如下。 If-None-Match 是客户端再次发起该请求时，携带上次请求返回的唯一标识 Etag 值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。 服务器收到该请求后，发现该请求头中含有 If-None-Match，则会根据 If-None-Match 的字段值与该资源在服务器的 Etag 值做对比，一致则返回 304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为 200 注：Etag &#x2F; If-None-Match 优先级高于 Last-Modified &#x2F; If-Modified-Since，同时存在则只有 Etag &#x2F; If-None-Match 生效。 总结强制缓存优先于协商缓存进行，若强制缓存(Expires 和 Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified &#x2F; If-Modified-Since 和 Etag &#x2F; If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回 304，继续使用缓存","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://didiorg.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js","slug":"js","permalink":"http://didiorg.com/tags/js/"},{"name":"浏览器","slug":"浏览器","permalink":"http://didiorg.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"缓存","slug":"缓存","permalink":"http://didiorg.com/tags/%E7%BC%93%E5%AD%98/"}]},{"title":"让 hexo URL更加优雅","slug":"让-hexoURL更加优雅","date":"2020-01-14T13:37:19.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/3651303969/","link":"","permalink":"http://didiorg.com/3651303969/","excerpt":"大家都知道 hexo url 默认是通过日期加标题确定的，这样的 url 特别难看","text":"大家都知道 hexo url 默认是通过日期加标题确定的，这样的 url 特别难看 比如： 1http://didiorg.com/2020/01/13/%E5%B4%87%E7%A4%BC%E5%A4%AA%E8%88%9E%E6%BB%91%E9%9B%AA/ 说实话，看不懂，因为把后面的汉字转义了 这个时候 hexo 官方提供了一种解决方案： 123# permalink: :year/:month/:day/:title/# 改成：permalink: :id.html 就有了下面这个： 1http://didiorg.com/ck5dxcj8p00094dvzd8sirsit.html 这样其实也非常不友好 第一，url 还是太长了。第二，也是最重要的一点，每“hexo g”一次，“:id”生成的 url 都是不一样的，这非常影响 SEO。 只推荐一种方案，就是安装 hexo-abbrlink 插件1npm hexo-abbrlink --save 再修改一下配置文件 1234permalink: :abbrlink.html # 生成唯一链接abbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: dec # 进制：dec(default) and hex 这个时候的 url 就很好看了 比如： 1http://didiorg.com/10086.html 该插件的原理是在文章中插入一个“abbrlink”参数，参数值是使用算法生成的 id，根据该“abbrlink”参数的值生成文章的固定 url，从而实现文章 url 固定。 看下面的文章， 12345678---title: 2020健身记录tags: 健身categories: fittop: trueabbrlink: 10086date: 2020-01-09 09:58:39--- 这个插件确实会生成一个唯一的 abbrlink， 这样挺好， 但是，我觉得更好的是， 这个 abbrlink 后面的值是可以自己修改的， 你可以改成数据， 改成字母，都可以， 这样就极大的方便我们管理我们的 url 了，比如上边这个链接，我就把原来生成的 id 改成了 10086， 很友好。 再看下面一个： 123456---title: 崇礼太舞滑雪tags: skiabbrlink: thaiwooskidate: 2020-01-13 09:54:15--- url 为： 1http://didiorg.com/thaiwooski.html","categories":[],"tags":[]},{"title":"前端知识点 check list","slug":"前端知识点 check list","date":"2020-01-14T10:32:15.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/web/","link":"","permalink":"http://didiorg.com/web/","excerpt":"Don’t be anxious, just do it.","text":"Don’t be anxious, just do it. JS 浏览器缓存 性能优化 地址栏输完 url， 回车之后，浏览器做了哪些工作 JS数据类型 基本数据类型和复杂类型的区别 js prototype的理解 js 中__proto__和 prototype 的区别和关系 判断变量是数组的方法 原型与原型链 new 一个对象的过程 JS 函数实参转换为数组 typeof instanceof 底层原理实现 this指向,箭头函数特点 事件轮询, promise, async await Promisetry产生的初衷 可以用catch吗 什么是Promise.try script 标签 defer async axois实现原理 对象、数组、map、set，等遍历的方法，分别怎么用的，什么原理（想要for of能遍历原型上的东西，可以用iterator） 跨域以及使用cors浏览器需要做什么处理 为什么要跨域，为什么要有事件轮询的机制 限制了什么，主要是限制cookie 各种继承方案（主要是红宝书里的） 三次握手，四次挥手详细了解，对https的了解 cookie和session区别（cookie的数据是服务端返回后通过什么存到浏览器的，然后跨域会到服务器么，（分两个阶段）， cookie知多少包括用法，特性，domain和基本封装） 防止js攻击，xss crfs知多少 预编译以及变量声明提升函数提升等 Websocket 对浏览器兼容性的理解和方法或者做过哪些兼容性处理 正则表达式匹配（转换时间，验证手机号等） symbol作用 es5和es6区别 es5实现es6的class JS 算法 数据去重 去掉首尾空格 排序 深度拷贝 斐波那契数列求和 js操tabletable作并对排序 找出所有乘数 CSS flex(需要详细说明每个属性),flex1是什么 positionsticky 盒模型 百分比和vh的区别，height 100%和100vh的区别 em,rem计算 垂直居中方式 BFC相关知识 重排触发重新绘制的原理 节流防抖实现 React 做过和哪些回流和重绘相关的优化 虚拟dom的diff useEffect hook 新的声明周期 immutablereselect和有什么好处 生命周期hook react列表key Vue vue双向绑定的原理（vue答双向绑定的时候结合一些complie和watcher等流程答）（complie编译器编译的都是哪些东西，怎么抄编译的，把什么编译成什么） 实现一个vue底层的简单监听函数，就是实现订阅者发布者模式 vue父子组件传值（多种方式）以及vuex vue生命周期及每阶段都能做什么（vue父子组件嵌套生命周期的顺序） vue router跳转的原理（刷新不刷新） vue的高级用法 vuex是否是持久化的，持久化是需要结合本地缓存么 seo渲染是在服务器端的，会出现白屏情况，vue渲染是会先加载结构的，慢慢渲染 vue兼容性（2.0版本）（ie9以下不兼容因为object.defineProperty的兼容性） vue源码知多少 jquery和vue区别和react的区别，mvc和mvvm框架区别，模块化那些区别 props穿的数据和data里数据的区别 Vue首次渲染页面时触发了哪些生命周期，props传数据时又触发了哪些生命周期 vuex的api可以set（也能实现数据劫持），v-html，v-for, v-if同时用会怎么样，v-once，插槽等 Webpack 做过哪些优化 手写一个尽量多功能的webpack（快手问的QAQ） h5 项目遇到的问题及解决方式 Ts 为什么要是用Ts 开放题 如何设计组件table或UI 其它 IndexDB 数据库选型 link用法原理能干啥与@import区别等 浏览器几个标签页之间怎么传递数据 Flutter nginx 常用配置 js 异步编程 回调 事件监听 发布&#x2F;订阅 promise generator yield; async wait (终级方法) promise 使用以及实现击鼓传花， 每隔n出列一个人，求最后那个mobox原理node使用场景 柯理化实现两个数组求交集 合并两个有序数组为一个有序数组无序数组中的最大数和第二大数 Vue如何实现双向绑定template模版编译过程vue router 实现原理navigator 实现原理 webpack 源码分析https原理和tcp协议原理http缓存问题 vuex的设计模式 深拷贝数组去重如何快速创建一个长度为100数值为1的数组node next盒子模型垂直居中flex布局跟浮动布局排序算法判断对象和数组","categories":[{"name":"前端基础","slug":"前端基础","permalink":"http://didiorg.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"web","slug":"web","permalink":"http://didiorg.com/tags/web/"}]},{"title":"崇礼太舞滑雪","slug":"崇礼太舞滑雪","date":"2020-01-13T01:54:15.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/thaiwooski/","link":"","permalink":"http://didiorg.com/thaiwooski/","excerpt":"今天运气特别好，第一趟缆车就在车上碰到了刘哥 这次滑雪学习了平行转弯跟走刃","text":"今天运气特别好，第一趟缆车就在车上碰到了刘哥 这次滑雪学习了平行转弯跟走刃 当时缆车上就我跟家琦还有刘哥三人， 我上来就跟家琦说：『要不，我们跟这个大哥滑吧？』， 运气是真好，刘哥人特别好，很友善的说了一句：『我现在在练习基本功』，哇，我现在不正好是要练基本功么，哈哈， 然后故事就开始了 刘哥是这个雪场的 VIP 季卡客户，对这个雪场很熟悉，刚开始带我们滑了一趟华尔兹，说大实话， 我站在华尔兹上过的时候，是很害怕的，从没滑过这么长这么陡的雪道；刘哥在旁边给我加油打气，然后说跟着他滑就好了，然后我就真的跟上去了。这一趟，没想到真的滑下去了，刘哥在滑的过程中，滑一会停一会给我讲怎么滑，但是讲真的，我当时其实一脑子懵逼，除了听到了怎么停车之外，其它要领，细节都没听进去，因为当时真的太紧张了。 应该是滑到完第四趟的时候， 我才开始慢慢去琢磨刘哥跟我说的每一个动作要领，第一个动作细节，而这个时候，刘哥已经带我滑完高级道（曼波）了，刘哥跟我讲了很多很多很多现在回想一下， 能记住的不多了： 5 协调 1 重点：脚掌、脚跟、小腿、大腿、躯干要协调，重点是重心在脚掌跟脚跟中间位置 转弯大 C: 入弯前准备：重心下移，开始用山上脚用力，两个膝盖准备同时往转弯的方向拐。 注意点：上身躯干一定要保持直立，并且面朝山下； 入弯：重心持续下移，两膝盖往弯心(转弯的圆心)拐得越多，山上脚承重会越多，当山下脚逐渐没有承重的时候，开始反弓。 注意点：这个时候特别重心一定要跟着雪板滑行方向，也就是一定要向下向弯的方向，用小腿前面压住雪鞋。脑补一下， 这个时候，自己是一个上身躯干挺直，但是重心是往前，往山下的， 心里会有一种很严重的恐惧感，因为感觉自己要往山下摔了，这个时候很容易做出重心往后、往山上的本能动作来保护自己，然而，只要你一做这个动作，那 100%会摔倒，而且，如果你一直没有面对这种恐惧的勇气，不能把重心交给雪板，不把重心往前，往山下，就一直学不会。 弯中：重心下移到最底点，用山上脚往外用力，把滑板刻入雪中，感觉脚掌下有一个很强的力来推个自己整个身体，产生一个向心力， 实现转弯 注意点：转弯过程中， 只有山上脚在发力， 山下脚保持与山上脚平行，贴着雪面滑行，不用力，甚至，我们可以提起我们的山下脚来练习这个动作 准备出弯：重心逐渐上移，保持前倾，这个时候原来的山上山下脚已完成交换 注意点：躯干还是保持直立，并且还是面向山下，前面的动作要完成一个下半身的转体，记住一定是下半身，动的只有胯跟腿，上半身一直都是一个直立并面朝山下的状态 出弯后：重心上移到最高点，用小腿前沿压雪鞋，保持前倾，雪板平板，用板刃滑行 注意点： 这个动作我自己刚开始的时候感觉搓雪很严重，完全没有走刃， 就是因为自己还是没有把重心交给雪板 很重要的点： 重心上下移，千万别通过弯腰上下移，也不能通过扩大大腿与腰的角度来上下移，记住一点， 上身躯干跟大腿的角度始终保持不变(其实说完全不变是不可能的，这里的不变一定是指自己不用任何力去刻意的改变这个角度)，所有的重心上下移动都通过小腿跟大腿的角度，也就是膝盖的角度来控制，膝盖越弯，重心越下越靠前，膝盖越直，重心越高，但是不能靠后，还是靠前的， 因为，重心靠前，是保证不摔跤的唯一办法 最后来一组图片","categories":[],"tags":[{"name":"ski","slug":"ski","permalink":"http://didiorg.com/tags/ski/"}]},{"title":"2020健身记录","slug":"2020健身记录","date":"2020-01-09T01:58:39.000Z","updated":"2022-08-02T02:39:10.648Z","comments":true,"path":"/10086/","link":"","permalink":"http://didiorg.com/10086/","excerpt":"加油， 2020，要么健身，要么读书陪自己一辈子的，是自己的身体，今年目标增重 10 斤，目前 73.5 公斤","text":"加油， 2020，要么健身，要么读书陪自己一辈子的，是自己的身体，今年目标增重 10 斤，目前 73.5 公斤 1 月， 目标: 增重 1 斤1.20（周一）练胸 1 小时 20 分钟 上斜卧推（哑铃）左右各 15 公斤 10RM * 6 组 双杠臂屈伸 自重减 40 斤 10RM * 5 组 卧推（杠铃） 15 公斤 10RM * 3~4 组 绳索夹胸 左右各 15 公斤 10RM * 3 组 1.19（周日）起很早去儿童医院，开车在等红绿灯的时候都睡着了，太虚了今天休息一天 中午午睡睡了 2 小时，起来的时候特别渴，喝了 1.5L 水。。。。 想了想，好像又是 3 天没抽烟了，有戒烟症状了 1.18（周六）话说我感冒好了，牛牛又感冒了，还是流感，感觉是我我传染给他的 想各种办法希望小孩不要感冒，最后还是感冒了，原本今天的票回家过年的，都退票了。感觉今年不能回家过年了 1.17（周五）今天真的很虚1.16（周四）部门运动分 拔河居然把腰拉伤了 平板坚持了 3 分 30 秒 1.15（周三）明天部门运动分，今天休息1.14（周二）练胸 1 小时 20 分钟 上斜卧推（哑铃）左右各 12.5 公斤 10RM * 6 组 双杠臂屈伸 自重减 40 斤 10RM * 5 组 平板飞鸟加哑铃卧推 7.5 公斤 12RM * 3 组 绳索夹胸 左右各 15 公斤 10RM * 3 组 这两天居然感冒了。。。。。。尴尬 1.13（周一） 练腿 1 小时 颈后杠铃深蹲 左右各 15 公斤 20RM * 10 组 硬拉 左右各 15 公斤 10RM * 3 组 平板支撑 120S * 1 组 60S * 2 组； 为了后天的平板支撑比赛 今天试了一下左右 35 公斤的硬拉，没想到居然能拉 3 个， 哈哈 第一次玩深蹲，重量上得很轻，就是杠放肩上的时候有点不习惯 1.12（周日）今天没健身，处理 1.6 号下雪的时候车被别人撞了的事故去了 先在定损中心定损，再到 4S 店报价，然后保险公司给 4S 店钱， 然后定货，等货到了之后再修 一出事故很麻烦，就算是别人全责，也很麻烦，希望大家 2020 年一路顺风 1.11（周六） 崇礼太舞滑雪一天 学习了平行转大弯，体验到了走刃的快感，感受到了从黑道上滑下去的刺激 车费：￥ 162；雪票：￥ 308；吃饭：￥ 90；总费用：￥ 560 1.10（周五）划水 1 小时 今天练了 5 组平板， 一组 120S， 四组 60S 1.9（周四）练背 1 小时 10 分钟 引体向上 自重 3RM * 2 组， 减重 61 斤 10RM * 5 组 俯身杠铃划船 左右各 10 公斤 10RM * 5 组 高位下拉 130 斤 10RM * 5 组 绳索划船 50 斤 12RM * 5 组 1.8（周三）休息一天 今天感觉胸很酸痛，昨天的练胸感觉是健身以来练胸练得最到位的一次 1.7（周二） 练胸 1 小时 20 分钟 推胸 夹胸 平板卧推（杠铃）左右各 15 公斤 10RM * 10 组 上斜卧推（哑铃）左右各 7.5 公斤 10RM * 5 组 蝴蝶机夹胸 左右各 15 公斤 8RM * 5 组 绳索夹胸 左右各 15 公斤 10RM * 5 组 放一个练胸的练胸教程，没事的时候可以多看看 看了教程之后发现自己下胸练得还是没到位，因为练下胸的动作对我来讲太难了，下胸没一点力量，完全上不去 1.6（周一）练腿 1 小时 硬拉 40 公斤 10RM * 10 组 50 公斤 8RM*5 组 放一个练腿的练腿教程 ， 说实话， 感觉自己是在划水，而且动作及其不标准，我练完之后居然腰痛，想特别感谢每次都一块健身的小伙伴家琦同学，不厌其烦，一遍又一遍的帮我指正错误 1.1 ~ 1.5 雪乡旅游 体验很不错，用我老婆的话来讲就是比较值，记录一下费用 准备衣服： 1045，车费： 1385 （1254+131），门票： 580，跟团： 3648（ 2368 + 1280），吃的： 400，住： 371（ 128 + 143 ） 共计：7429","categories":[{"name":"fit","slug":"fit","permalink":"http://didiorg.com/categories/fit/"}],"tags":[{"name":"健身","slug":"健身","permalink":"http://didiorg.com/tags/%E5%81%A5%E8%BA%AB/"}]},{"title":"vuex Store store 千万别写错了","slug":"vuex-Store-store-千万别写错了","date":"2019-11-26T10:11:13.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/4068032706/","link":"","permalink":"http://didiorg.com/4068032706/","excerpt":"问题：刚才在使用vuex 的时候，碰到一个 this.$store 总是为 undefine 的问题 一开始的时候从控制台看到的是使用 action 的 this.$store.dispatch 的时候的报错","text":"问题：刚才在使用vuex 的时候，碰到一个 this.$store 总是为 undefine 的问题 一开始的时候从控制台看到的是使用 action 的 this.$store.dispatch 的时候的报错 代码： 123changeSourceSQL(sql) &#123; this.$store.dispatch(&#x27;updateSourceSQL&#x27;, sql)&#125;, 报错信息 分析过程：【分析】 看到这种报错的时候， 肯定先进一步打印 dispatch 的上一级： 12345changeSourceSQL(sql) &#123; console.log(sql, this.$store) this.$store.dispatch(&#x27;updateSourceSQL&#x27;, sql)&#125;, 结果是 undefined 【分析】 很明显这是因为$store 挂载到全局的时候失败了 此时，再去看 入口文件 index.js 代码： 123456789101112131415161718192021222324252627282930import &quot;babel-polyfill&quot;import Vue from &quot;vue&quot;import Vuex from &quot;vuex&quot;import Store from &quot;../store/index.js&quot;import VueRouter from &quot;vue-router&quot;import Routers from &quot;./router&quot;import App from &quot;./app.vue&quot;import ViewUI from &quot;view-design&quot;import &quot;../my-theme/index.less&quot;Vue.use(Vuex)Vue.use(VueRouter)Vue.use(ViewUI)console.log(Store) // 调试的时候打印一下这个， 看是不是 Store 为 null// 路由配置const RouterConfig = &#123; mode: &quot;hash&quot;, routes: Routers&#125;const router = new VueRouter(RouterConfig)new Vue(&#123; el: &quot;#app&quot;, router, Store, render: h =&gt; h(App)&#125;) 看上去没问题 ！！！！ 并且打印的 Store 也有内容： 但是， store 就是没有挂载成功 看 API ！！！ 看 API ！！！ 看 API ！！！ 找到原因：原文：vuex state 通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到 文档里说是 store 选项， 对一定要看清楚，是 store 不是 Store 解决方案：【解决】 把 index.js 里边的 Store 改成 store 完美运行 如果上边是写成 1import Store from &quot;../store/index.js&quot; 那么下边也可以写成 123456new Vue(&#123; el: &quot;#app&quot;, router, store: Store, render: h =&gt; h(App)&#125;) 【最后，附上目录结构】 1234567891011121314151617181920212223242526272829.├── api│ ├── base.js│ └── index.js├── components│ ├── base-info.vue│ ├── dataview.vue│ ├── editer.vue│ └── setkey.vue├── my-theme│ ├── base.less│ └── index.less├── pages│ ├── app.vue│ ├── index.html│ ├── index.js│ └── router.js├── store│ ├── actions.js│ ├── getters.js│ ├── index.js│ ├── mutations.js│ └── state.js└── views ├── index.vue ├── relationship.vue ├── report.vue ├── transform.vue └── upload.vue 总结：【总结】 其实这是一个很小的问题， 但是也是体现了平时项目中不细心，自己去从零开始写 vuex的经验少，基本功不扎实等问题 多自己从零开始建项目，写项目可以很好的巩固自己的基本功","categories":[{"name":"bugfix","slug":"bugfix","permalink":"http://didiorg.com/categories/bugfix/"}],"tags":[{"name":"vuex","slug":"vuex","permalink":"http://didiorg.com/tags/vuex/"}]},{"title":"bodybuilding notes","slug":"bodybuilding-notes","date":"2019-11-25T06:15:26.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/3947484483/","link":"","permalink":"http://didiorg.com/3947484483/","excerpt":"2019 已经结束， 不忘初心， 坚持就是胜利从跟家琦健身以来，来健身房也不下30次了，虽然说自己很多动作还是不标准，但是学到了很多，算是个对健身入门了，2020年好好加油，不忘初心。 一点小感悟：中午健身牺牲了原来的午睡时间，但是，这也许是一个上班族无法避免的问题吧，这也让我晚上睡得更早了 健身之后的那种快感，是很难得的，很舒服的，是打心底发出的一种自信，因为自己心底会说，今天我健身了，就是牛逼，再看到什么程序员猝死这类的新闻，心底会想，这一看就是个平时不健身的人","text":"2019 已经结束， 不忘初心， 坚持就是胜利从跟家琦健身以来，来健身房也不下30次了，虽然说自己很多动作还是不标准，但是学到了很多，算是个对健身入门了，2020年好好加油，不忘初心。 一点小感悟：中午健身牺牲了原来的午睡时间，但是，这也许是一个上班族无法避免的问题吧，这也让我晚上睡得更早了 健身之后的那种快感，是很难得的，很舒服的，是打心底发出的一种自信，因为自己心底会说，今天我健身了，就是牛逼，再看到什么程序员猝死这类的新闻，心底会想，这一看就是个平时不健身的人 记录一下中午健身的内容【时间】【时长】【锻炼肌肉】【地点：滴滴湾流】【教练：家琦】 【2019年12月30日 周一】【 中午】【胸，腹， 跑步】【2019年12月27日 周五】【 中午 】【胸，腹， 跑步】【2019年12月25日 周三】【 中午】【腿， 跑步】【2019年12月23日 周一】【 中午 】【背 跑步】【2019年12月20日 周五】【 中午 】【背 跑步】【2019年12月23日 周二】【 中午 】【胸 跑步】【2019年12月16日 周一】【 中午 】【背 跑步】【2019年12月4日 周三】【 中午 11:40 ~ 12:50 】【背】一公里热身跑 背 高位下拉： 5组&#x2F;12次 160Kg 划船：5组&#x2F;15次 40Kg 引体向上：5组&#x2F;10次 自重 - 48Kg 单臂俯身划船：3组&#x2F;15次 12.5Kg 【2019年12月3日 周二】【 中午 11:40 ~ 13:30 】【胸】一公里热身跑 胸 向前推胸： 5组&#x2F;12次 20Kg 向前上推胸： 5组&#x2F;12次 20Kg 引体向上：5组&#x2F;10次 自重 - 48Kg 夹胸机器：5组 【2019年11月28日 周四】【 中午 12:00 ~ 13:30 】【背】一公里热身跑 背 高位下拉： 5组&#x2F;12次 175Kg 划船：5组&#x2F;15次 15Kg 引体向上：5组&#x2F;10次 自重 - 61 单臂俯身划船：4组&#x2F;15次 12.5Kg 总结 这次高位下拉的时候， 我戴了教练的助力带，效果很明显，跟以前比起来感觉不要用力去抓住杆子，力量可以更好的从背部发出来，拉的重量更高，达到更好的训练效果 划船的时候，又很明显的感觉自己肱三真的很差，几下就酸了 练背的时候，一定要很明显的感觉到自己的力量是从背部肌肉发出来的， 最好还是要有人带着玩，要不然很容易搞错，今天我做单臂俯身划船的时候，就搞错了2组，一开始教练练腹去了，他过来的时候， 发现我只有大圆肌在发力，而背阔肌没有发力， 这样是很不好的 【2019年11月27日 周三】【 中午 12:00 ~ 13:30 】【腿】一公里热身跑 腿 硬拉： 5组&#x2F;10个 40Kg 深蹲：5组&#x2F;15个 12.5Kg 健步蹲：5组&#x2F;10个 5kg&#x2F;2 空手&#x2F;2 总结 硬拉的时候，如果脚张得比较开， 练的是大腿内则(股内肌)， 如果保持与肩同宽， 练的主要是股直肌跟股外肌；硬拉的时候腰一定要打直，脚张天比脚笥肩同宽要轻松点， 但是建议先练与肩同宽； 其实刚开始练硬拉就想要拉的时候腰打直是很难的，对新手来说，前期一定要练一下深蹲，练习方法是找一面墙，面向墙体，脚尖抵墙，双脚平行，与肩同宽，这个时候脸尽量帖着墙，然后往下坐，能坐多深就坐多深，到最底点坚持2到3秒，一组可以做十到二十次，平时没事的时候就可以练，对后期练力量很有好处 【2019年11月26日 周二】【 中午 13:10 ~ 14:00 】【腹、核心】一公里热身跑 核心、腹 平板支撑：5组&#x2F;60S 卷腹：4组&#x2F;10个 肱三 三头俯身哑铃屈伸：4组 2.5Kg&#x2F;2&#x2F;30 5Kg &#x2F; 2 &#x2F;15 总结 今天教练休息一天，自己就不知道怎么玩了，做了两个教练之前要我加强的动作； 平板到第五组的时候完全只能坚持50S 了，这个动作以后每周一定要做两次以上， 教练说这个是练基本功跟核心的， 没事的时候可以多做。 【2019年11月25日 周一】【 中午 12:00 ~ 13:40 】【肩、肱三】一公里热身跑肩： 肩上举：5组&#x2F;8次 哑铃 7.5KG 直臂前平举：5组&#x2F;10+5次 杠铃片 10Kg + 5Kg 面拉：5组&#x2F;12次 2片 哑铃俯身飞鸟：5组&#x2F;20次 哑铃 2.5Kg 肱三： 绳索三头下拉：5组&#x2F;14次 3片 三头俯身哑铃屈伸：4组&#x2F;30次 2.5Kg 总结： 现在是感觉每块肌肉都很弱，重量上的特别小，教练说我驼背太严重，一定要把肩打开，比起第一次教练让我练背的时候，一站直，拉紧后背就会头晕两眼发黑的状态要好","categories":[{"name":"fit","slug":"fit","permalink":"http://didiorg.com/categories/fit/"}],"tags":[{"name":"健身","slug":"健身","permalink":"http://didiorg.com/tags/%E5%81%A5%E8%BA%AB/"}]},{"title":"hello hexo","slug":"hello-hexo","date":"2019-11-21T10:00:10.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/1310372071/","link":"","permalink":"http://didiorg.com/1310372071/","excerpt":"记录在使用 hexo 过程中的一些心得","text":"记录在使用 hexo 过程中的一些心得 2020年3月21日给文章添加目录 修改 themes/next/_config.yml 下 toc.expand_all 为 true 2020年2月３０想要首行缩进的时候，必须用全角空格，半角空格是不能有效缩进的 实现首行缩进也可以用 &amp;nsbp; 2020年2月29编写markdown文档的时候，如果想给写的内容加样式，其实完全可以直接用html的语法写 比如： 1&lt;img src=&quot;/images/web/js/proto.jpg&quot; align=&quot;center&quot; style=&quot;margin: 0 auto;&quot;&gt; 这样就可以引入一张图片并居中显示图片 在 hexo 使用过程中遇到的一点小坑本站使用主题使用的是 next 版本是 7.5.0 到了这个版本，gitalk 是集成在 next 中的， 所以使用起来很方便： 但是还是遇到了坑： 未找到相关的 Issues 进行评论 请联系 @admin 初始化创建分析：​ 找不到，肯定是路径的问题，经过自己反复对比 api 发现 我在配置 OAuth Apps 的时候，Homepage URL 跟 Authorization callback URL 后面加了一个”&#x2F;“ 造成后面加了”&#x2F;“的原因是因为我写 URL 的时候，是直接人浏览器地址栏复制过来的， 默认带”&#x2F;“ 解决办法：去掉”&#x2F;“, 点击 Update application 按钮， 等个三五分钟， 就可以了","categories":[{"name":"tools","slug":"tools","permalink":"http://didiorg.com/categories/tools/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://didiorg.com/tags/hexo/"}]},{"title":"hello world","slug":"hello-world","date":"2019-11-21T03:15:32.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/222957957/","link":"","permalink":"http://didiorg.com/222957957/","excerpt":"Hello Adele Written by：Adele Adkins/Greg Kurstin Hello it's me","text":"Hello Adele Written by：Adele Adkins/Greg Kurstin Hello it's me I was wondering if after all these years you'd like to meet To go over everything They say that time's supposed to heal ya but I ain't done much healing Hello can you hear me I'm in california dreaming about who we used to be When we were younger and free I've forgotten how it felt before the world fell at our feet There's such a difference between us And a million miles Hello from the other side I must've called a thousand times to tell you I'm sorry for everything that I've done But when I call you never seem to be home Hello from the outside At least I can say that I've tried to tell you I'm sorry for breaking your heart But it don't matter it clearly doesn't tear you apart anymore Hello how are you It's so typical of me to talk about myself I'm sorry I hope that you're well Did you ever make it out of that town Where nothing ever happened It's no secret That the both of us are running out of time Hello from the other side I must've called a thousand times to tell you I'm sorry for everything that I've done But when I call you never seem to be home Hello from the outside At least I can say that I've tried to tell you I'm sorry for breaking your heart But it don't matter it clearly doesn't tear you apart anymore Ooooohh anymore Ooooohh anymore Ooooohh anymore Anymore Hello from the other side I must've called a thousand times to tell you I'm sorry for everything that I've done But when I call you never seem to be home Hello from the outside At least I can say that I've tried to tell you I'm sorry for breaking your heart But it don't matter it clearly doesn't tear you apart anymore","categories":[],"tags":[{"name":"hello","slug":"hello","permalink":"http://didiorg.com/tags/hello/"}]},{"title":"webpack 的详细执行过程","slug":"webpack","date":"2019-11-20T07:57:14.000Z","updated":"2022-08-02T02:39:10.647Z","comments":true,"path":"/3856502506/","link":"","permalink":"http://didiorg.com/3856502506/","excerpt":"问：webpack 究竟解决了什么问题 模块化解决方案 在早前web前端只需要一个简单的 html 页面，插入几条script标签 去引用 js 文件就可以满足需求，随着项目越来越复杂，要实现的功能越来越多，文件也越来越多，全部都这么引入已经不再现实，这时候前端模块化就出现了，从AMD、CMD 到现在的 ES6 模块化写法，我们可以把代码拆成一个个 JS 文件，通过 import 去关联依赖文件，最后再通过某个打包工具把这么多 js 文件按照依赖关系最终打包成一个或多个 js 文件在html 页面去引入。所以 webpack首要要解决的问题是将多个模块化的 js文件 按照依赖关系打包为一个或多个文件，所以我们通常都会说他是一个模块化解决方案","text":"问：webpack 究竟解决了什么问题 模块化解决方案 在早前web前端只需要一个简单的 html 页面，插入几条script标签 去引用 js 文件就可以满足需求，随着项目越来越复杂，要实现的功能越来越多，文件也越来越多，全部都这么引入已经不再现实，这时候前端模块化就出现了，从AMD、CMD 到现在的 ES6 模块化写法，我们可以把代码拆成一个个 JS 文件，通过 import 去关联依赖文件，最后再通过某个打包工具把这么多 js 文件按照依赖关系最终打包成一个或多个 js 文件在html 页面去引入。所以 webpack首要要解决的问题是将多个模块化的 js文件 按照依赖关系打包为一个或多个文件，所以我们通常都会说他是一个模块化解决方案 处理资源转换 随着 ES6，ES7，ES8 的出现，还有 vue、react 等前端框架的出现，我们发现这些文件浏览器是不能直接执行的，需要我们中间编译转换一下为浏览器可执行的文件，所以这时候 webpack 要做的事情又多了一项，按照依赖打包的同时，还要对源文件进行编译转换处理，也就是我们日常配置的 loader 处理。 tree-shaking以及代码压缩 现在webpack已经支持了对文件编译转换后再进行打包，满足了我们的基本需求。这时候我们又开始对性能提出了要求，希望打包出的体积越小越好。比如有些文件虽然整个引用了，但其实真正只用了其中部分代码，没用到的部分希望可以被剔除掉。这种是通过剔除无效代码来减小总的打包体积，另外一种方式是通过代码压缩，比如空格、较长的函数名都可以被压缩。因此webpack支持了 tree-shaking和代码压缩。 代码拆分(异步加载 + 抽出第三方公用库） 现在 webpack 打包结果是不是做到了极致了呢？不行，我们还是嫌弃最终打包出的文件体积太大了。这时候懒加载（异步加载）出现了，你只需要把进入首页时所需要的所有资源打包为一个文件输出就行，这样进入首页我只需要加载该文件就行，其他资源文件等我真正执行的时候再去加载就可以。就这样，webpack又支持了异步加载文件的拆包功能，这时候我们最终打包出的主文件只是当前首页需要的资源。 开发辅助工具的提供 我们对于打包的基本需求以及性能需求终于得到了满足，又开始追求开发时的体验了，开发越便捷越好，webpack 就提供了一系列的开发辅助功能，比如 devserver，HMR 等等什么的帮助我们高效的开发。 现在我们回过头总结下看，webpack帮我们做了好多事啊。 作为一个模块化解决方案，帮助我们将繁多的 JS 模块化文件按照依赖关系打包 为一个或多个文件输出 支持针对文件指定文件进行编译转换后再打包 支持针对打包后的内容优化、压缩处理来减小总的文件体积 支持异步加载以及其他拆包方式 提供一系列开发辅助工具 概述webpack的构建从处理入口文件开始着手，首先解析入口文件，需要 经过 loader转换编译这时候就转换编译，转换完了开始分析是否有依赖文件，有依赖文件就接着处理依赖文件，流程和刚刚一致，需要编译转换就转换，然后接着解析依赖文件是否还有依赖文件，有再接着处理。就这样通过入口文件以及依赖关系，webpack 可以获取并处理所有的依赖文件。然后再基于这些文件做进一步的优化处理，比如 treeshaking 或者 代码压缩，最后生成为我们需要的一个或多个js 文件。 1. 准备工作webpack 首先会将我们的配置文件和它自己的默认配置做一个 merge，生成最终的一个配置文件，其次会将这个最终配置文件里的所有插件plugin在这个时候都注册好，在这里要提一下 webpack 的事件机制，他是基于一个 tapable库做的事件流控制，在整个的编译过程中暴露出各种hook，而我们写的 plugin 也就是去注册监听了某个 hook，在这个 hook 触发时，去执行我们的 plugin。 2. 处理入口文件在 webpack 的处理中多种入口最后都会转化为同一方法去处理，单入口不用说，多入口我可以先遍历，再去执行该方法，动态入口，我先执行函数再去处理，最终都会进入到 生成入口文件 module 实例阶段。 12345678910111213141516// 入口文件module.exports = &#123; // 单入口 entry: &#123; main: &#x27;./src/index.js&#x27; &#125;, // 多入口 entry: &#123; app: &#x27;./src/app.js&#x27;, adminApp: &#x27;./src/adminApp.js&#x27; &#125;, // 动态入口 entry: () =&gt; new Promise((resolve) =&gt; resolve([&#x27;./demo&#x27;, &#x27;./demo2&#x27;]))&#125;; 大家都说 webpack 中一切文件都是 module，那 module 是什么呢，其实他就是一个存了当前文件所有信息的一个对象而已，这个文件包含了以下信息。 123456789101112module = &#123; type, request, userRequest, rawRequest, loaders, resource, matchResource, parser, generator, resolveOptions&#125; 3.生成文件 module实例1. resolve 阶段通过我们的 resolve 配置和 rules 配置去获取到当前文件的绝对路径和需要经过哪些loader 进行处理，然后将这些信息存到我们当前这个文件对应的 module 实例里面 2.执行 loader 阶段loader 的执行是倒序 loader的执行分为 2 个阶段: pitching,执行 loader 上的 pitch 方法;normal,执行 loader 常规方法 执行完 loader 后，也就是对文件做了编译转换，使其变成了最终可以被浏览器执行的代码。 3. parse 阶段webpack 是采用将loader 执行过后的源文件source转换为AST 去分析依赖。这里使用了acorn 库，将source生成对应的 AST。生成的 AST 划分为 3部分，ImportDeclaration、FunctionDeclaration和VariablesDeclaration，接下来遍历 AST 去收集依赖。找到 import 等关键字去达到依赖收集的目的。 4.递归处理依赖基于我们解析到的依赖文件，我们要开始递归处理依赖了，又回到了我们处理入口文件的整个流程，去生成依赖文件的 module 实例，再执行 对应loader。就这样 webpack 递归处理了所有的依赖文件并完成了所有文件的转换 4. 生成 chunk根据用户配置的 optimization.slitChunks 或者默认的配置，用上一步生成的module，来生成 chunk 生成 Module-graph 生成 Basic-chunk-graph 生成最终的 chunk-graph 5. 优化 首先生成对应的 moduleId ，不做任何配置的话，默认采用以自增 id 的方式，推荐 hash 的方式，有利于缓存 基于生成的 moduleId进行排序 接着类似于 module 的操作，对应生成 chunkId ，并根据 chunkId进行排序 分别为 module 和chunk 生成hash 6. 生成文件webpack 把这些文件按照内置的 template 渲染生成最终的打包文件。 总结总结一下 webpack 的整个构建打包过程，首先通过依赖关系和 loader 配置获取经过编译转换后的所有module 实例，然后再根据配置进行拆分为一个或多个chunk，最后按照内置的template 渲染出最终的文件输出。","categories":[{"name":"tools","slug":"tools","permalink":"http://didiorg.com/categories/tools/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://didiorg.com/tags/webpack/"}]}],"categories":[{"name":"前端进阶","slug":"前端进阶","permalink":"http://didiorg.com/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"},{"name":"前端基础","slug":"前端基础","permalink":"http://didiorg.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"name":"learning notes","slug":"learning-notes","permalink":"http://didiorg.com/categories/learning-notes/"},{"name":"摄影","slug":"摄影","permalink":"http://didiorg.com/categories/%E6%91%84%E5%BD%B1/"},{"name":"fit","slug":"fit","permalink":"http://didiorg.com/categories/fit/"},{"name":"bugfix","slug":"bugfix","permalink":"http://didiorg.com/categories/bugfix/"},{"name":"tools","slug":"tools","permalink":"http://didiorg.com/categories/tools/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://didiorg.com/tags/vue/"},{"name":"vue 原理","slug":"vue-原理","permalink":"http://didiorg.com/tags/vue-%E5%8E%9F%E7%90%86/"},{"name":"js","slug":"js","permalink":"http://didiorg.com/tags/js/"},{"name":"js 基础","slug":"js-基础","permalink":"http://didiorg.com/tags/js-%E5%9F%BA%E7%A1%80/"},{"name":"js 算法","slug":"js-算法","permalink":"http://didiorg.com/tags/js-%E7%AE%97%E6%B3%95/"},{"name":"js算法","slug":"js算法","permalink":"http://didiorg.com/tags/js%E7%AE%97%E6%B3%95/"},{"name":"web","slug":"web","permalink":"http://didiorg.com/tags/web/"},{"name":"浏览器","slug":"浏览器","permalink":"http://didiorg.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"性能优化","slug":"性能优化","permalink":"http://didiorg.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"this","slug":"this","permalink":"http://didiorg.com/tags/this/"},{"name":"array","slug":"array","permalink":"http://didiorg.com/tags/array/"},{"name":"dom","slug":"dom","permalink":"http://didiorg.com/tags/dom/"},{"name":"react","slug":"react","permalink":"http://didiorg.com/tags/react/"},{"name":"ES6","slug":"ES6","permalink":"http://didiorg.com/tags/ES6/"},{"name":"lightroom","slug":"lightroom","permalink":"http://didiorg.com/tags/lightroom/"},{"name":"缓存","slug":"缓存","permalink":"http://didiorg.com/tags/%E7%BC%93%E5%AD%98/"},{"name":"ski","slug":"ski","permalink":"http://didiorg.com/tags/ski/"},{"name":"健身","slug":"健身","permalink":"http://didiorg.com/tags/%E5%81%A5%E8%BA%AB/"},{"name":"vuex","slug":"vuex","permalink":"http://didiorg.com/tags/vuex/"},{"name":"hexo","slug":"hexo","permalink":"http://didiorg.com/tags/hexo/"},{"name":"hello","slug":"hello","permalink":"http://didiorg.com/tags/hello/"},{"name":"webpack","slug":"webpack","permalink":"http://didiorg.com/tags/webpack/"}]}